//Author(s)
//NClark, ZHelm, SDarling, JFaller
//IDEXX Laboratories, Inc.
//Westbrook, ME 04092

//Tool Calibrates for LYTES and QSDMA lots

//------------------Revision History for both script and Help File--
//  <-- NOTICE THE SPACE, SAGE!
//		  1.0 SDarling 042922
//		-> moved calFitfunc, subLotcharFunc, calBarcodeParse, Grubbs_Outlier_Detection, subLottabprep, prepCalData, prepLoopData, prepExpiration, SDMAPanelPrep, SDMALoopQualPrep, SDMAInstPrep, SDMAPatientPrep, assayType to tested section.
//		-> moved outlierDetectWithinGroup and outlierRecursion to unused function section.
//	RC3   1.0 SDarling 041922
//		-> updated SDMAInstPrep to delete excluded rows and outliers from table.
//		-> set d term to 0 in SDMAjsonPrepBase().
//	RC3	  1.0 NClark 041922
//		-> updated lytesAssStitching() to delete excluded rows and outliers from subset of Cal table
//		-> updated prepLoopData() to delete excluded rows and outliers from table
//		-> updated SDMAPanelPrep() to delete excluded rows and outliers from table
//	RC3	  1.0 SDarling 041422
//		-> added Grubbs_Outlier_Detection() to SDMAPanelPrep().
//		-> added Grubbs_Outlier_Detection() to prepCalData().
//		-> Grubbs_Outlier_Detection() added.
//		-> outlierDetectWithinGroup() removed from lytes workflow and will not be used currently as the function requires updates.
//		-> updated outlierDetectWithinGroup() to use a flexible dose column instead of Sample ID.
//	RC2	  1.0 SDarling 040822
//		-> updated calfitfunc() to have a try statement for creating the parameter estimates as only one plot was causing a failure in creating the combined data table. 
//	RC1	  1.0 SDarling 040722
//		-> updated calfitfunc() to include a split of the estimates at the end of the master path and close the non-split table.
//	RC1	  1.0 NClark 040622
//		-> updated calfitfunc() to remove all the median summary stuff from the "master" path
//		-> updated calfitfunc() copy all of the begining fits into the "master" path, but without Crossweb [Parse( colNamesublot )]
//		-> updated calfitfunc() shift all of the begining fits into the "non-master" path
//		-> updated calfitfunc() to delete columns from the fit table in the "master" path
//		-> added commented line to prepLoopQual for easy shift to neededloops being numeric and not character
//	RC1   1.0 SDarling 04062022
//		-> updated subLottabprep to include Inst Type for joining of the parameters into the loop qual table. This addresses an error where loop qual results were duplicated.
//		-> updated subLottabprep inside lytesAssStitching to require "Inst Type" as an input.
//		-> updated prepLoopData to create a Inst Type column using the InstrumentSerial column and substring out the first 4 letters. Also deletes formula.
//	BETA7 1.0 SDarling 033022
//		-> updated buildJSONarray to include a process variable to distingush the master json from SDMA and Lytes.
//		-> updated SDMAjsonPrepBase to turn lot into numeric at the end for JSON input.
//		-> updated sdmaAssStitching to create the final calc dose column in the panel data table.
//	BETA6 1.0 SDarling 032322
//		-> updated lytesAssStitching to add cubic curve to create concentrations instead of using the original 3P fit.
//		-> updated sdmaAssStitching to include a variable for event number that comes from the panel table. all tables will have this in the 2nd slot. Error checking opportunity?
//		-> updated SDMAjsonPrepBase to have event as an input.
//		-> left open the Patient Offset and Platform Offset tables for user viewing. Named these tables with Event # and Patient/Instrument Offset.
//	BETA5 1.0 NClark 032222
//		-> added seePrivateTables variable (boolean to trigger the showing of private tables)
//		-> added unprivatizeTable() function which, when executed will show a private table of choice (assuming boolean is 1)
//		-> implemented unprivatizeTable() function whenever a table is created in 'private' mode
//			-> this should allow the user to change the boolean to 1 in teh variable and when the code is run, the private tables will be shown without having to comment/uncomment them all indivitually
//		-> updated prepLoopData() function so the files pulled end in "processed.jmp"
//		-> updated prepLoopData() function so the extracted loop is character to match the neededLoops data types
//		-> updated prepExpiration() function on the non SDMA path to update 'Lot 2' to slide_lot and not 'Lot'
//		-> updated prepExpiration() function so the non SDMA path is explicit to LYTES
//	BETA4 1.0 NClark 031822
//		-> updated prepExpiration() to work with actual .xlsm file formatting in their "summary" worksheet
//		-> updated ionChemCalDialog() to set up the expiration date to come from an .xlsm (instead of .xlsx) file and on validate updated to match
//	BETA4 1.0 SDarling 030822
//		-> added into SDMAjsonPrepBase to include naming the table with event (if relevant) and lot number range.
//		-> added buildJSONarray into SDMA workflow. Is missing lot information currently.
//		-> added logic to force dose numeric, continuous in SDMALoopQualPrep and SDMAPanelPrep functions.
//		-> modified SDMALoopQualPrep to be able to do multiple slide lots with multiple loop qual events.
//		-> added logic to bring recode chem type from QSDMA to SDMA in SDMAPlatformPrep function.
//		-> changed subLot2DblockerFunc to include slide lot information for formula calculations.
//		-> modified ionChemCalDialog to accept a folder location instead of JMP file for QSDMA loop qual.
//		-> updated dialogOutput to be qsdmaLoopFolder output to create the loopQualDataPath for QSDMA.
//		-> updated SDMAjsonPrepCW to set crossweb_end and crossweb_start to numeric nominal instead of character.
//		-> reintroduced lot to SDMAjsonPrepBase output table.
//		-> set expiration date to character in prepExpiration.
//  BETA3 1.0 SDarling 030122
//		-> updated calFitfunc to support JMP16 column deletions.
//		-> added SDMALoopQualPrep, SDMAPanelPrep, SDMAPatientPrep, SDMAInstPrep functions.
//		-> updated ionChemCalDialog to support .XLSX extensions.
//		-> updated the Main to support SDMA functionality.
//		-> updated expirationprep to support SDMA.
//		-> added JSON prep functions for SDMA. Included in stitching function.
//		-> added JSON array to sdmaAssStitching. Needs adjusting to work with QSDMA workflow.
//	BETA2 1.0 NClark 022522
//		-> renamed preparation() to instIDpreparation() and defaulted intrument id column to "Instrument ID"
//		-> updated buildJSONarray
//			-> removed exiration from buildJSONarray parameters
//			-> grab event info and lot range info from base coeffs filename
//			-> updated the for each row to go by what the 1st word is not the uppercase version
//			-> upaated the saving of the JSOn file to incorporate "lots" and today()
//			-> added code to close the 3 tables, but commented out for now
//		-> updated lytesAssStitching()
//			-> prepare for JSON building for each table
//			-> call actuall buildJSONarray()
//		-> added three new functions to prepare tables for JSON work (finalizes columns and formatting for correct JSON formatting)
//			-> jsonPrepBase()
//			-> jsonPrepCW()
//			-> jsonPrepFoil()
//	BETA1 1.0 NClark, SDarling, ZHelm, JFaller 021822
//------------------------------------------------------------------

Names Default To Here( 1 );

//-----------Variable Declarations (above Main for easy access)--

//tested
	If(HostIs("MAC"),
		u = Get Environment Variable("USER");
		,
		u = Get Environment Variable("USERNAME");
	);
	addinID = "com.idexx.RoswellQCTools_Sublot_calibration";

	minJMPver = "16.1";

	//assaymidpoint
	assayMidPoint = Associative Array(
		{
			{"40", 115},
			{"41", 4.3},
			{"42", 153},
			{"CL", 115},
			{"K", 4.3},
			{"NA", 153}			
		}
	);
	// range lo, hi
	assayRange = Associative Array(
		{
			{"40", {50, 160}},
			{"41", {0.8, 10}},
			{"42", {85, 180}},
			{"CL", {50, 160}},
			{"K", {0.8, 10}},
			{"NA", {85, 180}}		
		}
	);
	//cubic coeffs for corrected 3P
	assayCorrectedCubic = Associative Array(
		{
			{"40", Associative Array(
					{
						{"int", 11.0422244319215},
						{"lin", 0.631429652798366},
						{"quad", 0.00384826612677856},
						{"cub", -0.0000126863381553078}		
					}
				)
			},
			{"41", Associative Array(
					{
						{"int", (0.491047025197684 + 0.01)},
						{"lin", 0.589025966029642},
						{"quad", 0.0928461121150412},
						{"cub", -0.00594812663885595}		
					}
				)
			},
			{"42", Associative Array(
					{
						{"int", 80.2669819780055},
						{"lin", -1.01470981530239},
						{"quad", 0.0162340428546581},
						{"cub", -0.0000421742221477125}	
					}
				)
			},
			{"CL", Associative Array(
					{
						{"int", 11.0422244319215},
						{"lin", 0.631429652798366},
						{"quad", 0.00384826612677856},
						{"cub", -0.0000126863381553078}		
					}
				)
			},
			{"K", Associative Array(
					{
						{"int", (0.491047025197684 + 0.01)},
						{"lin", 0.589025966029642},
						{"quad", 0.0928461121150412},
						{"cub", -0.00594812663885595}		
					}
				)
			},
			{"NA", Associative Array(
					{
						{"int", 80.2669819780055},
						{"lin", -1.01470981530239},
						{"quad", 0.0162340428546581},
						{"cub", -0.0000421742221477125}		
					}
				)
			}
		}
	);

//tested above ... add new below
	/* AR threshold EQN coeffs
	a + b * :"RepCount"n + c *
	:"Threshold Median AR"n + (:"RepCount"n - 7) * ((:"Threshold Median AR"n + d)
	* e)
	*/
	arThresholdCoeffs = Associative Array(
		{
			{40, Associative Array(
					{
						{"a",0.0012707971679844},
						{"b",-0.0000586962682322227},
						{"c",0.00254292011925348},
						{"d",-0.000153491812055332}
					}
				)
			},
			{41, Associative Array(
					{
						{"a",-0.000267089995094783},
						{"b",0.0000383105894415053},
						{"c",0.00505495064190689},
						{"d",-0.000340653064411896}
					}
				)
			},
			{42, Associative Array(
					{
						{"a",0.000414602187026228},
						{"b",-0.0000407295042376547},
						{"c",0.00399395551194415},
						{"d",-0.000179122017449908}
					}
				)
			}
		}
	);

	outlierLimitCount = 2;

	seePrivateTables = 0;
	/*example use
		createdTable = unprivatizeTable(seePrivateTables, createdTable);
	*/

//-----------/Variable Declarations-----------------------

path = ConvertFilePath("");
include(ConvertFilePath(path||"Utilities\utilities.jsl"));

////////////////////////////////////////
//                                    //
//            Functions               //
//                                    //
////////////////////////////////////////

	/////////////////////////////////////////
	//       Support functions             //
	/////////////////////////////////////////
//TESTED FUNCTIONS
checkVersion = Function( {minVer},
	{default local},
	currVer = JMP Version();
	currWords = words(currVer,".");
	minWords = words(minVer,".");
	minBackHalf = If(nitems(minWords)==1,"0",concatitems(minWords[2::nitems(minWords)],""));
	backHalf = If(nitems(currWords)==1,"0",concatitems(currWords[2::nitems(currWords)],""));
	newNumVer = Num(currWords[1]||"."||backHalf);
	newMinVer = Num(minWords[1]||"."||minBackHalf);
	
	If(newNumVer >= newMinVer, Return(1),Return(0));
);

wrongVer = Function( {maxVer},
	{Default Local},
	New Window( "Requires JMP " || Char( maxVer ),
		<<Modal,
		Text Box( "This addin requires the used of JMP " || Char( maxVer ) || "+" ),
		Button Box( "OK" )
	)
);

factorFinder = Function( {number},
	{default local}, 
	
	a = number;
	b = [];
	b |/= a;
	While( Modulo( a, 2 ) == 0,
		a = a / 2;
		b |/= a;
	);
	b |/= number/b;
	
	table = New Table( "Factor Table", <<Add Rows( N Rows( b ) ), New Column( "Factors", Numeric, Continuous, Set Values( b ) ),invisible );
	table << Sort( Replace Table, By( :Factors ) );
	table << Select Where( :Factors == 1 ) << Delete Rows;
	Return( table );
);

//eventually moved to libraries
assayTypes = Function({},{default local},
	assayTyp = Associative Array(
		{
			{"GLU",00},
			{"BUN",01},
			{"CA",03},
			{"URIC",05},
			{"TP",06},
			{"TRIG",07},
			{"CHOL",08},
			{"ALB",09},
			{"NH3",10},
			{"PHOS",12},
			{"TBIL",14},
			{"CREA",15},
			{"FRU",16},
			{"CRP",17},
			{"SDMA",18.04},
			{"BA",21},
			{"PROG",23},
			{"PHBR",25},
			{"TT4",28.30},
			{"MG",32},
			{"LAC",35},
			{"CL",40},
			{"K",41},
			{"NA",42},
			{"UPRO",54},
			{"ALTV",56},
			{"TCO2",57},
			{"LIPA",59},
			{"AMYL",60},
			{"ALT",62},
			{"LDH",63},
			{"CK",64},
			{"ALKP",65},
			{"GGT",67},
			{"UCRE",70},
			{"AST",73},
			{"WRS",90},
			{.,-999}
		}
	);
	Return(assayTyp)
);

//parse the barcode to get slide lot number, crossweb number, foil number, assay code.
calBarcodeParse = Function({tablename, barcodecol}, {default local},
	//tablename = current data table();
	//barcodecol = "Barcode";
	parse_barcodecol = Parse( Eval Insert( ":\!"^barcodecol^\!"n" ) );
	//show(parse_barcodecol);
	
	collist = tablename << get column names(string);
	//show(collist);
	
	if(!contains(collist, "Slide Lot_BC"),
		tablename << New Column("Slide Lot_BC", Character, Nominal, formula( Substr( Char( parse_barcodecol ), 1, 4 )));
	);

	if(!contains(collist, "Crossweb_BC"),
		tablename << New Column("Crossweb_BC", Character, Nominal, formula( Substr( Char( parse_barcodecol ), 7, 2 )));
	);

		
	if(!contains(collist, "Foil_BC"),
		tablename << New Column("Foil_BC", Character, Nominal, formula( Substr( Char( parse_barcodecol ), 5, 2 ) ));
	);
	
	if(!contains(collist, "Assay Code_BC"),
		tablename << New Column("Assay Code_BC", Character, Nominal, formula( Substr( Char( parse_barcodecol ), 9, 2 ) ));
	);	
	
	tablename:"Slide Lot_BC"n << delete property(Formula);
	tablename:"Crossweb_BC"n << delete property(Formula);
	tablename:"Foil_BC"n << delete property(Formula);
	tablename:"Assay Code_BC"n << delete property(Formula);
	
	return(tablename);	
);

Grubbs_Outlier_Detection = Function({tablename, yCol, alpha}, {default local},
	//variable names for troubleshooting inside function.
	//tablename = current data table();
	//yCol = "Corrected AR";
	//alpha = 0.001;
	//dosecol = "Panel Dose";

	//parse the input variables.
	parse_yCol = Parse( Eval Insert( "^tablename^:\!"^yCol^\!"n" ) );
	//show(parse_yCol);

	//create exclusion column. Do not add if one exists.
	collist = tablename << get column names(string);
	//show(collistsubfoil);

	//add exclusion rationale column.
	if(!contains(collist, "Exclusion Rationale"),
		tablename << New Column("Exclusion Rationale", Character, Nominal);
	);
	
	g = 1;
	g0 = 0;
	i=0;
	While(g > g0 &  i < 10,
		//create distribution of AR.
		dist = tablename << Distribution(
			Y(parse_yCol),
			Normal Quantile Plot(1),
			Fit Distribution( Normal( Goodness of Fit(1) ) )
		);
		distr = dist << Report;

		y_values = parse_yCol << Get As Matrix;
		exRows = tablename << Get Excluded Rows();
		y_values[exRows] = [];
		n = N Row(y_values);

		//tquantile and g/g0 calcs.
		t0Sqr =  t Quantile( 1 - alpha/(2*n), n-2 )^2;
		g = Maximum( Abs( y_values - Mean( y_values ) ) ) / Std Dev( y_values );
		g0 = ((n-1)/Sqrt(n)) * Sqrt( t0Sqr / (n - 2 + t0Sqr) );
	
		distr<<close window();
		//show(t0Sqr);
		//show(g);
		//show(g0);
		//show(i);
		if(
			g>g0,
			//print("true");
			Summarize(tablename, maxvalue=Max(parse_yCol));
			Summarize(tablename, minvalue=Min(parse_yCol));
			Summarize(tablename, meanvalue=Mean(parse_yCol));
			//show(maxvalue, minvalue, meanvalue);
			
			if((maxvalue-meanvalue)>(meanvalue-minvalue),
				print("max value greater");
				tablename << select where(parse_yCol==maxvalue) << hide(1) << exclude(1);
				row = tablename << get rows where(Selected());
				//show(row);
				For(i=1, i<=nrow(row),i++,
					tablename:Name("Exclusion Rationale")[row[i]] = tablename:Name("Exclusion Rationale")[row[i]] ||"NDE - Grubb's";
					show(i);
				);
				,
				print("min value greater");
				tablename << select where(parse_yCol==minvalue) << hide(1) << exclude(1);
				row = tablename << get rows where(Selected());
				//show(row);
				For(i=1, i<=nrow(row),i++,
					tablename:Name("Exclusion Rationale")[row[i]] = tablename:Name("Exclusion Rationale")[row[i]] ||"NDE - Grubb's";
					//show(i);
				);
			);
		);
		
		i++;
		//g=1;
		//g0=1;
	);
	Return(tablename);
);


//UNTESTED FUNCTIONS
//nate created, needs to test
instIDpreparation = Function( {tableName, instrumentIDcolumn = "Instrument ID"}, {default local},
	
	//variable shortening
	instID = instrumentIDcolumn;
	
	//convert text cols names into jsl local column variables
	//JMP 16 may have fixed issues that require needing both styles
	nameIDCol = EvalInsert(":\!"^instID^\!"n");
	
	parseIDCol = Parse(EvalInsert(":\!"^instID^\!"n"));

	//this will recode an existing Inst Type column with hopefully the correct layout
	Try(
		IsScriptable(Column(tableName, "Inst Type"));
		tableName << Recode Column(
			:"Inst Type"n,
			{lower_rcNow = Lowercase( _rcNow ); Map Value(
				lower_rcNow,
				{"catalyst dx", "ctdx", "catdx", "ctdx", "cat dx", "ctdx", "catalystdx", "ctdx", 
				"catone", "cat1", "cat one", "cat1", "catalyst one", "cat1", "catalystone", "cat1", "catalyst1", "cat1", "catalyst 1", "cat1"},
				Unmatched( lower_rcNow )
			)},
			Target Column(:"Inst Type"n)
		);
		,
		tableName << new column("Inst Type",Character,Nominal,
			Formula(
				Match(Substr(parseIDCol,1,4),
					"CTDX", "ctdx"
					,
					"CAT1", "cat1"
				)
			)
		);
		tableName:"Inst Type"n << delete formula;
	);

	Return(tableName);
);

//added by nate to turn Chem Types into Chem Codes

//UNTESTED FUNCTIONS

unprivatizeTable = Function({bool,tableName},{default local},
	If(bool == 1,
		tableName << New Data View;
		Return(tableName)
		,
		Return(tableName)
	)
);


	/////////////////////////////////////////
	//       Main functions                //
	/////////////////////////////////////////

//TESTED MAIN FUNCTIONS
calFitfunc = Function( {table, posCol, respCol, fluidCol, slideLotvar, chemTypecol, instTypecol, fitType, fitType2},
	{default local}, 
	
	/*table = the calibration data table
	posCol = the sub lot position identification
	respCol = intended to be AR
	fluidCol = to identify concentration for calibration purposes
	slideLotvar = the slide lot that excludes the sublot field
	fitType = the fit form specific to the assay*/
	
	/*
	dtCal = Current Data Table();
	table = dtCal;
	posCol = "Cross Web";
	respCol = "Script AR";
	fluidCol = "Script Dose Val";
	slideLotvar = "Slide Lot";
	chemTypecol = "Chem Type";
	instTypecol = "Inst Type";
	fitType = "3P";
	fitType2 = "Master";
	*/
	
	parseColNamesublot = Parse( Eval Insert( ":name(\!"^posCol^\!" )" ) );
	parseColNamedose = Parse( Eval Insert( ":name(\!"^fluidCol^\!" )" ) );
	parseColNameresponse = Parse( Eval Insert( ":name(\!"^respCol^\!" )" ) );
	parseColNamecoating = Parse( Eval Insert( ":name(\!"^slideLotvar^\!" )" ) );
	parseColNameresponsemean = Parse( Eval Insert( ":name(\!"Mean(\!^respCol^\!)\!" )" ) );
	parseColNamechem = Parse( Eval Insert( ":name(\!"^chemTypecol^\!" )" ) );
	parseColNameinst = Parse( Eval Insert( ":name(\!"^instTypecol^\!" )" ) );
	
	colNameinst = Eval Insert( ":name(\!"^instTypecol^\!" )" );
	colNamechem = Eval Insert( ":name(\!"^chemTypecol^\!" )" );
	colNamesublot = Eval Insert( ":name(\!"^posCol^\!" )" );
	colNameresponse = Eval Insert( ":name(\!"^respCol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	colNamedose = Eval Insert( ":name(\!"^fluidCol^\!" )" );
	
	If( fitType2 == "Master",
		// dt_Calparams1 = dt_Calparams << Summary(
		// 	Group( :Parameter, parseColNamecoating, parseColNamechem, parseColNameinst ),
		// 	Median( :Estimate ),
		// 	Link to Original Data Table( 0 ),
		// 	Invisible
		// );
		// dt_Calparams << Close Window;
		// dt_Calparams2 = dt_Calparams1 << Split(
		// 	Split( :Name( "Median(Estimate)" ) ),
		// 	Split By( :Parameter ),
		// 	Group( parseColNamecoating, parseColNamechem, parseColNameinst ),
		// 	Remaining Columns( Drop All )
		// );
		// dt_Calparams = dt_Calparams2;
		// dt_Calparams1 << Close Window;
		If(
			fitType == "3P",
				calFit = table << Fit Curve(
					Y( Parse( colNameresponse ) ),
					X( Parse( colNamedose ) ),
					By( Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Exponential 3P
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Exponential 3P" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Exponential 3P" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);
			,
			fitType == "Rodbard", 
				calFit = table << Fit Curve(
					Y( Parse( colNameresponse ) ),
					X( Parse( colNamedose ) ),
					By( Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Logistic 4P Rodbard
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Logistic 4P Rodbard" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Logistic 4P Rodbard" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);
			,
			fitType == "Quad", 
				calFit = table << Fit Curve(
					Y( Parse( colNameresponse ) ),
					X( Parse( colNamedose ) ),
					By( Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Quadratic
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Quadratic" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Quadratic" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);				
			, 
			fitType == "Linear", 
				calFit = table << Fit Curve(
					Y( Parse( colNameresponse ) ),
					X( Parse( colNamedose ) ),
					By( Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Linear
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Linear" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Linear" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);
			,
			fitType == "Cubic", 
				calFit = table << Fit Curve(
					Y( parseColNameresponse ),
					X( parseColNamedose ),
					By( Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Cubic
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Cubic" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Cubic" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);
			,
			fitType == "Cubic-3P", 
				/////call the Jesse function here
				Empty()
		);
		dt_Calparams << Delete Columns( :"Table"n, :"Std Error"n, :"Wald ChiSquare"n, :"Prob > ChiSquare"n , :"Lower 95%"n, :"Upper 95%"n);
		dt_Calparams1 = dt_Calparams << Split(
		 	Split( :Estimate  ),
		 	Split By( :Parameter ),
		 	Group( parseColNamecoating, parseColNamechem, parseColNameinst ),
		 	Remaining Columns( Drop All )
		);
		close(dt_Calparams, nosave);
		dt_Calparams = dt_Calparams1;
		,
		If(
			fitType == "3P",
				calFit = table << Fit Curve(
					Y( Parse( colNameresponse ) ),
					X( Parse( colNamedose ) ),
					By( Parse( colNamesublot ), Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Exponential 3P
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Exponential 3P" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Exponential 3P" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);
			, 
			fitType == "Rodbard", 
				calFit = table << Fit Curve(
					Y( Parse( colNameresponse ) ),
					X( Parse( colNamedose ) ),
					By( Parse( colNamesublot ), Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Logistic 4P Rodbard
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Logistic 4P Rodbard" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Logistic 4P Rodbard" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);
			, 
			fitType == "Quad", 
				calFit = table << Fit Curve(
					Y( Parse( colNameresponse ) ),
					X( Parse( colNamedose ) ),
					By( Parse( colNamesublot ), Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Quadratic
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Quadratic"  )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Quadratic"  )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);
			,		
			fitType == "Linear", 
				calFit = table << Fit Curve(
					Y( Parse( colNameresponse ) ),
					X( Parse( colNamedose ) ),
					By( Parse( colNamesublot ), Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Linear
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Linear"  )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Linear" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);
			, 
			fitType == "Cubic", 
				calFit = table << Fit Curve(
					Y( parseColNameresponse ),
					X( parseColNamedose ),
					By( Parse( colNamesublot ), Parse( colNamecoating ), Parse( colNamechem ), Parse( colNameinst ) ),
					Fit Cubic
				);
				Wait( 0 );
				Try( dt_Calparams = Report( calFit[1] )[Outline Box( "Cubic"  )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit[1] ) << Close Window;
					,
					dt_Calparams = Report( calFit )[Outline Box( "Cubic" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table(invisible(1));
					Report( calFit ) << Close Window;
				);
			,
			fitType == "Cubic-3P", 
				/////call the Jesse function here
				Empty()
		);
		dt_Calparams << Delete Columns( :"Table"n, :"Std Error"n, :"Wald ChiSquare"n, :"Prob > ChiSquare"n , :"Lower 95%"n, :"Upper 95%"n);
	);

	Return( dt_Calparams );
);

subLotcharFunc = Function( {table, posCol, respCol, slideLotvar, chemTypecol, lamda, cont},
	{default local}, 
	
	/*table = the loop qual data table
	posCol = the sub lot positions are going to correct around
	respCol = intended to be AR
	fluidCol = to cover in the event we have multiple fluid levels in the data this identifies unique fluids
	slideLotvar = the slide lot that excludes the sublot field
	cont = the type of sublot pattern we are correcting for*/
	
	/*
	table=dtSubop_cw;
	posCol="Cross Web";
	respCol="Offset Calc_Cross Web";
	slideLotvar="Slide Lot";
	chemTypecol="Chem Type";
	lamda=100;
	cont="Yes";
	*/
	
	parseColNamesublot = Parse( Eval Insert( "^table^:name(\!"^posCol^\!" )" ) );
	parseColNameresponse = Parse( Eval Insert( "^table^:name(\!"^respCol^\!" )" ) );
	parseColNamecoating = Parse( Eval Insert( "^table^:name(\!"^slideLotvar^\!" )" ) );
	parseColNameresponsemean = Parse( Eval Insert( "^table^:name(\!"Mean(\!^respCol^\!)\!" )" ) );
	parseColNamechem = Parse( Eval Insert( "^table^:name(\!"^chemTypecol^\!" )" ) );
	
	colNamechem = Eval Insert( ":name(\!"^chemTypecol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	colNamesublot = Eval Insert( ":name(\!"^posCol^\!" )" );
	colNameresponse = Eval Insert( ":name(\!"^respCol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	
	If( cont == "Yes", 
	
		dtSubsum2 = table << Summary(
			Group( parseColNamecoating, parseColNamechem ),
			Freq( "None" ),
			Weight( "None" ),
			Link to original data table( 0 ),
			Invisible
		);
		//Column( table, posCol ) << set data type("Numeric");
		posCount = Max( Column( table, posCol ) << Get Values );
	
		dtTempcount = New Table( "Arbritrary Positions", New Column( posCol, Numeric, Continuous, Set Values( 1 :: posCount :: 1 ) ), Invisible );
	
		dtTempcount << New Column( "Sublot Position_Char",
			Character,
			Nominal,
			Set Formula( If( parseColNamesublot < 10, "0" || Char( parseColNamesublot ), Char( parseColNamesublot ) ) )
		);
		Column( dtTempcount, "Sublot Position_Char" ) << Delete Formula;
		dtTempcount << New Column( posCol || "_Predicted Correction", Numeric, Continuous );
	
		dtSubsum = dtSubsum2 << Join( With( dtTempcount ), Cartesian Join, Invisible );
		dtSubsum2 << Close Window;
		dtTempcount << Close Window;
		
		splineFit = table << Bivariate(
			Y( Parse( colNameresponse ) ),
			X( Parse( colNamesublot ) ),
			By( Parse( colNamecoating ), Parse( colNamechem ) ),
			Fit Spline( lamda, {Line Color( {212, 73, 88} )} )
		);
	
		splineFit << (Curve[1] << Save Predicteds);
	
		splineFormula = Column( table, "Spline Predictor for " || respCol || " By " || slideLotvar || " By " || chemTypecol ) << Get Formula;
	
		Column( dtSubsum, posCol || "_Predicted Correction" ) << Set Formula( Name Expr( splineFormula ) );
		splineFit << Close Window;
	, 
	
		dtSubsum = table << Summary(
			Group( parseColNamesublot, parseColNamecoating, parseColNamechem ),
			Mean( parseColNameresponse ),
			Freq( "None" ),
			Weight( "None" ),
			Link to original data table( 0 )
		);

	);
	Return( dtSubsum );
);

subLottabprep = Function( {table1, table2, calPosxL, calPosxH, calPosy, posColx, posColy, respCol, fluidCol, slideLotvar, chemTypecol, instTypecol, fitType},
	{default local}, 
	/*table1 = sub lot characterization function output
	table2 = calibration function output
	posCol = the sub lot position identification
	respCol = intended to be AR
	slideLotvar = the slide lot that excludes the sublot field*/
	
	parseColNamesublotx = Parse( Eval Insert( ":name(\!"^posColx^\!" )" ) );
	parseColNamesubloty = Parse( Eval Insert( ":name(\!"^posColy^\!" )" ) );
	parseColNamecoating = Parse( Eval Insert( ":name(\!"^slideLotvar^\!" )" ) );
	parseColNameresponse = Parse( Eval Insert( ":name(\!"^respCol^\!" )" ) );
	parseColNamedose = Parse( Eval Insert( ":name(\!"^fluidCol^\!" )" ) );
	parseColNameresponsemean = Parse( Eval Insert( ":name(\!"Mean(\!^respCol^\!)\!" )" ) );
	parseColNamechem = Parse( Eval Insert( ":name(\!"^chemTypecol^\!" )" ) );
	parseColNameinst = Parse( Eval Insert( ":name(\!"^instTypecol^\!" )" ) );
	
	colNamechem = Eval Insert( ":name(\!"^chemTypecol^\!" )" );
	colNameresponse = Eval Insert( ":name(\!"^respCol^\!" )" );
	colNamesublotx = Eval Insert( ":name(\!"^posColx^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	colNamedose = Eval Insert( ":name(\!"^fluidCol^\!" )" );
	colNameresponsemean = Eval Insert( ":name(\!"Mean(\!^respCol^\!)\!" )" );
	colNameinst = Eval Insert( ":name(\!"^instTypecol^\!" )" );
	
	tableOut = table1 << Join(
		With( table2 ),
		Merge Same Name Columns,
		By Matching Columns( Eval( Parse( colNamecoating ) ) = Eval( Parse( colNamecoating ) ), Eval( Parse( colNamechem ) ) = Eval( Parse( colNamechem ) ) , Eval( Parse( colNameinst ) ) = Eval( Parse( colNameinst ) ) ),
		Drop multiples( 0, 0 ),
		Include Nonmatches( 0, 0 ),
		Preserve main table order( 1 ),
		Invisible
	);
	
	table2 << Close Window;
	
	If( fitType == "3P",
		tableOut << New Column( "Predicted Dose from Master",
			Numeric,
			Continuous,
			Set Formula( Log( (parseColNameresponse - :Asymptote) / :Scale ) / :Growth Rate )
		),
		Stop()
	);
	
	/*tableOuttemp = tableOut << Select Where( calPosxL <= parseColNamesublotx <= calPosxH & parseColNamesubloty == calPosy ) <<
	Subset( Selected Rows( 1 ), Selected Columns( 0 ), Invisible );
	
	tableOuttempsum = tableOuttemp << Summary(
		Group( parseColNamedose ),
		Mean( "Predicted Dose from Master" ),
		Link to Original Data Table( 0 ),
		Invisible
	);
	Column( tableOuttempsum, "Mean(Predicted Dose from Master)" ) << Set Name( "Target Dose" );
	tableOut << Update(
		With( tableOuttempsum ),
		Match Columns( Parse( colNamedose ) = Parse( colNamedose ) ),
		Add Columns from Update Table( :Target Dose )
	);
	tableOuttempsum << Close Window;
	tableOuttemp << Close Window;*/
	
	Return( tableOut );
);

prepCalData = Function( {calPathway, dataPath},
	{default local}, 
	/*
	calPathway = "LYTES";
	dataPath = calDataPath;
	*/
	//addin sages barcode function to this preparation
	dt = Open( dataPath );
	dt = calBarcodeParse(dt, "Barcode");
	dt:"Crossweb_BC"n << set data type("Numeric");
	dt:"Crossweb_BC"n << set name("Cross Web");
	
	//outlier determination and exclusion using Grubb's.
	dt << New Column( "CL Blocked AR for Outliers",
		Numeric,
		Continuous,
		Set Formula( 
			If( :"Assay"n == 40,
				:"AR"n - Col Median( :"AR"n, :"Assay"n, :"Dose"n, :"Slide Lot"n, :"Inst Type"n )
			)
		)
	);

	dt << New Column( "NA Blocked AR for Outliers",
		Numeric,
		Continuous,
		Set Formula( 
			If( :"Assay"n == 41,
				:"AR"n - Col Median( :"AR"n, :"Assay"n, :"Dose"n, :"Slide Lot"n, :"Inst Type"n )
			)
		)
	);

	dt << New Column( "K Blocked AR for Outliers",
		Numeric,
		Continuous,
		Set Formula( 
			If( :"Assay"n == 42,
				:"AR"n - Col Median( :"AR"n, :"Assay"n, :"Dose"n, :"Slide Lot"n, :"Inst Type"n )
			)
		)
	);

	dt:"CL Blocked AR for Outliers"n << Delete Formula;
	dt:"NA Blocked AR for Outliers"n << Delete Formula;
	dt:"K Blocked AR for Outliers"n << Delete Formula;

	Grubbs_Outlier_Detection(dt, "CL Blocked AR for Outliers", 0.001);
	Grubbs_Outlier_Detection(dt, "NA Blocked AR for Outliers", 0.001);
	Grubbs_Outlier_Detection(dt, "K Blocked AR for Outliers", 0.001);

	dt << Delete Columns("CL Blocked AR for Outliers", "NA Blocked AR for Outliers", "K Blocked AR for Outliers");

	dt << Clear Select;

	Return( dt );

);

prepLoopData = Function( {calPathway, dataPath, calData},
	{default local},
	/*
	calPathway = "LYTES";
	dataPath = loopDataPath;
	calData = calData;
	*/
	neededLoops = AssociativeArray(calData:"Loop Lot_DxRelease");
	removefrom(neededLoops,"");
	
	//loopQualPath = "/D:/IDEXX/Lytes One Loop = One Lot - Documents/Documentation/CO3489 - QC for OLOL/4. Species Calibration/Species File Check/";
	loopfileList = Files In Directory(dataPath,recursive);
	
	/// UPDATE to potentially key in on specific file AND/OR exclude any non .jmp files also
	For(i=nitems(loopfileList),i>=1,i--,
		If(
			/*Contains(loopfileList[i], "Loop Qualification") |
			Contains(loopfileList[i], "NDE Count") |
			Contains(loopfileList[i], "unchosen") |
			Contains(loopfileList[i], "Sublot Corrected"),*/
			Word( length( words( loopfileList[i], "_" ) ), loopfileList[i], "_") != "processed.jmp",
			RemoveFrom(loopfileList,i)
			,
			//show(word(1,loopfileList[i],"_"));
			//neededloops will be character
			loop = word(1,loopfileList[i],"_"); //surfs the folder names from Head
			//loop = Num(word(1,loopfileList[i],"_")); //surfs the folder names from Head
			If(neededLoops[loop] == 0,
				RemoveFrom(loopfileList,i)
			)
		);
	);
	
	loopFiles = {};
	For(i=1,i<=nitems(loopfileList),i++,
		loopFiles[i] = Open(
			dataPath||loopfileList[i],
			private
		);
		loopFiles[i] = unprivatizeTable(seePrivateTables, loopFiles[i]);
	);
	loopFiles1 = Remove(loopFiles,1);
	
	If(
		N Items( loopFiles ) == 1, 
			loopQualTable = loopFiles[1];
		,
		N Items( loopFiles ) > 1,
			loopQualTable = loopFiles[1] << concatenate( loopFiles1, create source column );
			For( i = 1, i <= N Items( loopFiles ), i++,
				Close( loopFiles[i], nosave )
			);
		,
		N Items( loopFiles ) == 0,
			Print( "no loop data, please try again" );
			Return(0);
	);
	
	loopQualTable << New Column("AR",numeric,continuous,
		Formula(
			Match( :Dry Reads Used,
				"6-7", :"DR Mean 6-7 offline_ar"n,
				"9-10", :"DR Mean 9-10 offline_ar"n,
				"9-10-11", :"DR Mean 9-10-11 offline_ar"n,
				"10-11", :"DR Mean 10-11 offline_ar"n
			)
		)
	);
	loopQualTable:"AR"n << delete formula;
	
	loopQualTable << New Column("Inst Type", character, nominal,
		Formula(
			If( Substr( :"InstrumentSerial"n, 1, 4 ) == "CTDX",
				"CatDx",
				"CatOne"
			);
		);
	);
	loopQualTable:"Inst Type"n << delete formula;
	
	Try(
		IsScriptable(Column(loopQualTable,"Foil"));
		loopQualTable:"Foil"n << Set Formula( :"Foil_LQ"n );
		loopQualTable:"Foil"n << delete formula;
		loopQualTable:"Foil"n << set data type("Numeric");
		,
		loopQualTable << New Column("Foil",
			Formula( :"Foil_LQ"n )
		);
		loopQualTable:"Foil"n << delete formula;
		loopQualTable:"Foil"n << set data type("Numeric");
	);
	loopQualTable:"Crossweb_LQ"n << Set Data Type("Numeric");
	loopQualTable:"Crossweb_LQ"n << Set Name("Cross Web");
	
	
	//create summary of slide lot and loop lot
	//add code to update the loopqual table with the slide lots from cal data (update with summary by loop lot)
	cdSum = calData << Summary(
		Group( :"Chem Type"n, :"Slide Lot"n, :"Loop Lot_DxRelease"n ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 ),
		private
	);
	cdSum = unprivatizeTable(seePrivateTables, cdSum);
	cdSum:"Loop Lot_DxRelease"n << set data type("Character");
	cdSum << delete columns("N Rows");
	
	loopQualTable << Update(
		With(cdSum),
		Match Columns(
			:"Chem Type"n = :"Chem Type"n,
			Transform Column(
				"fullLL_LQ",
				Formula( "4" || :"Loop Lot_LQ"n);
			) = :"Loop Lot_DxRelease"n
		)
	);
	Close(cdSum, nosave);
	/*
	Delete all manually excluded rows as well as rows deemed as outliers. Long term it would be ideal
	to ensure the exclusions could be honored (from columns and row states), but that will be a feature
	request for a later release
	*/
	loopQualTable << Select where( 
		:"Exclusion Rationale"n == "NDE - Grubb's"
		|
		:"Loop Lot_LQ"n == "*indet"
		|
		Excluded()
	) << delete rows;
	
	Return(loopQualTable);

);

prepExpiration = Function( {calPathway, dataPath},
	{default local},
	
	//def will need to be updated for QSDMA - that path will be a list of one to many files
	//do the updates to the expiration data fomratting here
	If(calPathway == "SDMA",
		datatables = {};
		listofthings = parse(dataPath);
		//loop through to open the data tables needed for analysis.
		For(i=1,i<=nitems(listofthings),i++,
			
			datatables[i] = Open(
				listofthings[i],
				Worksheets( "Sheet1" ),
				Use for all sheets( 1 ),
				Concatenate Worksheets( 0 ),
				Create Concatenation Column( 0 ),
				Worksheet Settings(
					1,
					Has Column Headers( 1 ),
					Number of Rows in Headers( 1 ),
					Headers Start on Row( 1 ),
					Data Starts on Row( 2 ),
					Data Starts on Column( 1 ),
					Data Ends on Row( 0 ),
					Data Ends on Column( 0 ),
					Replicated Spanned Rows( 1 ),
					Replicated Spanned Headers( 0 ),
					Suppress Hidden Rows( 1 ),
					Suppress Hidden Columns( 1 ),
					Suppress Empty Columns( 1 ),
					Treat as Hierarchy( 0 ),
					Multiple Series Stack( 0 ),
					Import Cell Colors( 0 ),
					Limit Column Detect( 0 ),
					Column Separator String( "-" )
				),
				Invisible
			);
			
			//process each file if needed
			
		);

		datatables1 = Remove(datatables,1);

		Try(
			concatTable = datatables[1] << Concatenate(
				datatables1
			);
			For(i=1,i<=nitems(datatables),i++,
				Close(datatables[i],nosave);
			);
			,
			concatTable = datatables[1];
		);

		//modify the concatenated tables to have just batch and expiration date and delete the empty rows inside Batch.
		concatTable << Select Columns(:"Batch"n, :"Exp. Date"n);
		concatTable << Invert Column Selection();
		concatTable << Delete Columns();
		concatTable << Select where(is missing(:"Batch"n));
		concatTable << Delete Rows();

		//format the date per what's needed for the JSON
		concatTable:"Exp. Date"n << Format(
			"Custom",
			Formula(
				Char( Year( value ) ) || "." || Match( Length( Char( Month( value ) ) ),
					1, "0" || Char( Month( value ) ),
					2, Char( Month( value ) )
				) || "." || Match( Length( Char( Day( value ) ) ),
					1, "0" || Char( Day( value ) ),
					2, Char( Day( value ) )
				)
			),
			10,
			0
		);

		//set the column names to the necessary values.	
		concatTable:"Exp. Date"n << set name("exp_date") << set data type("Character");
		concatTable:"Batch"n << set name("slide_lot");

		Return(concatTable);
		,
		calPathway == "LYTES",
		// adding expiration date table (will have more than just Exp dates) (will be opened by other stuff earlier)
		//.... ClipLot becomes cliplot ExpirationDate become exp_date
		//.... delete clip type
		//.... convert chemabbr to chemcode ... don't use array of chem codes, call function to get them and add function to overarching list of functions
		//.... other stuff too based on what comes in with this file
		//.... format Expiration dates as follows below
		//.... make format YYYY.MM.DD (not YYYY-MM-DD)
		/*Data Table( "basicTest_expDates" ):ExpirationDate <<
				Format(
					"Custom",
					Formula(
						Char( Year( value ) ) || "." || Match( Length( Char( Month( value ) ) ),
							1, "0" || Char( Month( value ) ),
							2, Char( Month( value ) )
						) || "." || Match( Length( Char( Day( value ) ) ),
							1, "0" || Char( Day( value ) ),
							2, Char( Day( value ) )
						)
					),
					10,
					0
				);
			*/
		//.... make date column character to be properly maintained in array and to JSON

		assayCodes = assayTypes();
		dt = Open(
			dataPath,
			Worksheets( "Summary" ),
			//Use for all sheets( 1 ),
			Concatenate Worksheets( 0 ),
			Create Concatenation Column( 0 ),
			Worksheet Settings(
				1,
				Has Column Headers( 1 ),
				Number of Rows in Headers( 1 ),
				Headers Start on Row( 2 ),
				Data Starts on Row( 3 ),
				Data Starts on Column( 1 ),
				Data Ends on Row( 0 ),
				Data Ends on Column( 0 ),
				Replicated Spanned Rows( 1 ),
				Replicated Spanned Headers( 0 ),
				Suppress Hidden Rows( 1 ),
				Suppress Hidden Columns( 1 ),
				Suppress Empty Columns( 1 ),
				Treat as Hierarchy( 0 ),
				Multiple Series Stack( 0 ),
				Import Cell Colors( 0 ),
				Limit Column Detect( 0 ),
				Column Separator String( "-" )
			)
		);
		dt << select where(IsMissing(:"ExpirationDate"n)) << delete rows;
		dt:ExpirationDate << Format(
			"Custom",
			Formula(
				Char( Year( value ) ) || "." || Match( Length( Char( Month( value ) ) ),
					1, "0" || Char( Month( value ) ),
					2, Char( Month( value ) )
				) || "." || Match( Length( Char( Day( value ) ) ),
					1, "0" || Char( Day( value ) ),
					2, Char( Day( value ) )
				)
			),
			10,
			0
		);
		dt:"ExpirationDate"n << set name("exp_date");
		dt:"Lot 2"n << set name("slide_lot");
		dt:"ClipLot"n << set name("cliplot");
		dt:"exp_date"n << set data type("Character");

		dt << New Column("chemcode",
			Formula(
				assayCodes[:"ChemAbbr"n]
			)
		);
		dt:"chemcode"n << delete formula;
		
		keepCols = {"cliplot","slide_lot","exp_date","chemcode"};
		For(i=ncol(dt),i>=1,i--,
			if(contains(keepCols, column(dt,i) << get name ), empty()
				,
				dt << delete columns(i)
			)
		);

		Return( dt );
	);
);

SDMALoopQualPrep = Function({loopQualDataPath, calData, DXrelease}, {default local},
	//loopQualDataPath = "/C:/Users/sdarling/Box/Roswell QSDMA Testing and Analysis/SDMA Loop Qual/Loop Lots/";
	//calData = Data Table("PAN01_Panel_justResults_Runsheet.jmp");
	//DXrelease = "/C:/Users/sdarling/OneDrive - IDEXX/Projects/Cal Tool Development/Trial Event/Build 10.75/Event PAN01/QSDMA Product Tracking Board Rev II.xlsm";

	dt = Open(
		DXrelease,
		Worksheets( "SDMA" ),
		Use for all sheets( 1 ),
		Concatenate Worksheets( 0 ),
		Create Concatenation Column( 0 ),
		Worksheet Settings(
			1,
			Has Column Headers( 1 ),
			Number of Rows in Headers( 1 ),
			Headers Start on Row( 4 ),
			Data Starts on Row( 5 ),
			Data Starts on Column( 1 ),
			Data Ends on Row( 0 ),
			Data Ends on Column( 0 ),
			Replicated Spanned Rows( 1 ),
			Replicated Spanned Headers( 0 ),
			Suppress Hidden Rows( 1 ),
			Suppress Hidden Columns( 1 ),
			Suppress Empty Columns( 1 ),
			Treat as Hierarchy( 0 ),
			Multiple Series Stack( 0 ),
			Import Cell Colors( 0 ),
			Limit Column Detect( 0 ),
			Column Separator String( "-" )
		)
	);

	Summarize(calData, neededlots = By(:"Slide Lot"n));
	//show(neededLots);

	dt << select where(Contains(neededLots, :"Slide Lot Number"n));

	dt << Select Columns(:"Slide Lot Number"n, :"Loop Lot Number"n);

	loopslideconfig = dt << Subset(
		Selected Rows(1),
		Selected columns only(1),
		Invisible
	);

	close(dt, nosave);

	loopslideconfig << Set Name("Loop Lot to Slide Lot");
	
	
	//array required switching loop lot number to numeric as the header of the folders are coming in numeric. From the DX release, this comes in as a character nominal. Switching it here for usage. We could have also switched loop to be character instead. This was the easiest for now as I change it anyway for joining into the loop qual table, where loop lot number is numeric continuous already.
	loopslideconfig:"Loop Lot Number"n << Set Data Type("Numeric") << Set Modeling Type("Continuous");
	
	neededLoops = AssociativeArray(loopslideconfig:"Loop Lot Number");
	removefrom(neededLoops,"");

	loopfileList = Files In Directory(loopQualDataPath,recursive);

	/// UPDATE to potentially key in on specific file AND/OR exclude any non .jmp files also
	For(i=nitems(loopfileList),i>=1,i--,
		If(
			/*Contains(loopfileList[i], "Loop Qualification") |
			Contains(loopfileList[i], "NDE Count") |
			Contains(loopfileList[i], "unchosen") |
			Contains(loopfileList[i], "Sublot Corrected"),*/
			Word( length( words( loopfileList[i], "_" ) ), loopfileList[i], "_") != "processed.jmp",
			RemoveFrom(loopfileList, i)
			,
			//show(word(1,loopfileList[i],"_"));
			loop = num(word(1,loopfileList[i],"_")); //surfs the folder names from Head
			If(neededLoops[loop] == 0,
				removefrom(loopfileList,i)
			);
		);
	);
	
	show(loopfileList);
	
	loopFiles = {};
	For(i=1,i<=nitems(loopfileList),i++,
		loopFiles[i] = Open(
			loopQualDataPath||loopfileList[i],
			private
		);
		loopFiles[i] = unprivatizeTable(seePrivateTables, loopFiles[i]);
	);
	loopFiles1 = Remove(loopFiles,1);
	
	If(
		N Items( loopFiles ) == 1, 
			loopQualTable = loopFiles[1];
		,
		N Items( loopFiles ) > 1,
			loopQualTable = loopFiles[1] << concatenate( loopFiles1, create source column );
			For( i = 1, i <= N Items( loopFiles ), i++,
				Close( loopFiles[i], nosave )
			);
		,
		N Items( loopFiles ) == 0,
			Print( "no loop data, please try again" );
			Return(0);
	);
	
	loopQualTable:"Slide Lot"n << Set Name("Slide Lot_Original");
	
	loopQualTable << Update(
		With( loopslideconfig ),
		Match Columns( :"Slide Mfg Loop Lot"n = :"Loop Lot Number"n ),
		Add Columns from Update Table( :"Slide Lot Number"n )
	);
	
	close(loopslideconfig, nosave);
	
	loopQualTable:"Slide Lot Number"n << Set Name("Slide Lot") << Set Data Type("Numeric") << Set Modeling Type("Continuous");
	
	//selecting the rows that are Grubb's outliers, barcodes that can't be read, or excluded for another purpose.
	loopQualTable << Row Selection(
		Select where( 
			:"Exclusion Rationale"n == "NDE - Grubb's"
			|
			:"Loop Lot_LQ"n == "*indet"
			|
			Excluded()
		)
	);
	
	loopQualTable << Invert Row Selection();
	/*
	This subset effectively deletes all manually excluded rows as well as rows deemed as outliers.
	Long term it would be ideal to ensure the exclusions could be honored (from columns and row states),
	but that will be a feature request for a later release
	*/
	//creating a subset with the exclusions out.
	dt_Sublot = loopQualTable << Subset( 
		Selected Rows(1),
		Selected Columns(0) 
	);
	
	dt_Sublot << Delete Columns("Foil"n);
	dt_Sublot:"Crossweb_LQ"n << set name("Cross Web");
	dt_Sublot:"Cross Web"n << Data Type( Numeric );
	dt_Sublot:"Foil_LQ"n << set name("Foil");
	dt_Sublot:"Foil"n << Data Type( Numeric ) << Set Modeling Type( Nominal );
	
	dt_Sublot << New Column( "Script Dose Val", Numeric, Continuous, Set Formula( num(:"Panel Dose"n) ) );
	Column( dt_Sublot, "Script Dose Val" ) << Delete Formula;
	
	dt_Sublot << New Column( "Script AR", Numeric, Continuous, Set Formula( :"Corrected AR"n ) );
	Column( dt_Sublot, "Script AR" ) << Delete Formula;
	close(loopQualTable, nosave);
	
	Return(dt_Sublot);
);

SDMAPanelPrep = Function({calPath}, {default local},
	//dt_Panel = current data table();
	//calPath = calDataPath;
	
	dt_Panel = Open(calPath);
	
	calBarcodeParse(dt_Panel, "Barcode");
	dt_Panel:"Crossweb_BC"n << set name("Cross Web");
	dt_Panel:"Cross Web"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	dt_Panel << Delete Columns("Foil"n);
	dt_Panel:"Foil_BC"n << set name("Foil");
	dt_Panel:"Foil"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	
	dt_Panel << New Column( "Script Dose Val", Numeric, Continuous, Set Formula( num(Try("Panel Dose (µg/dL)_RS"n, "Panel Dose (ug/dL)_RS"n ))));
		Column( dt_Panel, "Script Dose Val" ) << Delete Formula;
	
	dt_Panel << New Column( "Script AR", Numeric, Continuous, Set Formula( :"Corrected AR"n ) );
	Column(dt_Panel, "Script AR" ) << Delete Formula;

	//outlier detection
	dt_Panel << New Column( "Blocked AR for Outliers",
		Numeric,
		Continuous,
		Set Formula( 
				:"Corrected AR"n - Col Median( :"Corrected AR"n, :"Assay"n, :"Script Dose Val"n, :"Slide Lot"n, :"Cross Web"n )
		)
	);

	dt_Panel:"Blocked AR for Outliers"n << Delete Formula;

	Grubbs_Outlier_Detection(dt_Panel, "Blocked AR for Outliers", 0.001);

	dt_Panel << Delete Columns("Blocked AR for Outliers");
	/*
	Delete all manually excluded rows as well as rows deemed as outliers. Long term it would be ideal
	to ensure the exclusions could be honored (from columns and row states), but that will be a feature
	request for a later release
	*/
	dt_Panel << Select where( 
		:"Exclusion Rationale"n == "NDE - Grubb's"
		|
		Excluded()
	) << delete rows;

	dt_Panel << Clear Select;

	Return(dt_Panel);
);

SDMAPatientPrep = Function({patientPath}, {Default Local},
	
	dt_FineTune = Open(patientPath);
	
	//what is the purpose of this column?
	dt_FineTune << New Column( "Script AR", Numeric, Continuous, Set Formula( :"Corrected AR"n ) );
	Column( dt_FineTune, "Script AR" ) << Delete Formula;
	
	dt_FineTune:"Slide Lot"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	
	calBarcodeParse(dt_FineTune, "Barcode");
	dt_FineTune:"Crossweb_BC"n << set name("Cross Web");
	dt_FineTune:"Cross Web"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	dt_FineTune << Delete Columns("Foil"n);
	dt_FineTune:"Foil_BC"n << set name("Foil");
	dt_FineTune:"Foil"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	
	dt_FineTune << New Column("Lot Type", Character, Nominal, Set Formula(
		If( :"results.base_concentration"n == -1,
			"Test",
			"Reference"
		)
	));
	dt_FineTune:"Lot Type"n << Delete Formula;
	
	Return(dt_FineTune);
	
);

SDMAInstPrep = Function({platformPath}, {Default Local},
	//platformPath = platformDataPath;
	
	dt_InstTune = Open(platformPath);
	
	dt_InstTune << Recode Column(
		dt_InstTune:"Chem Type"n,
		{Map Value( _rcOrig, {"QSDMA", "SDMA"}, Unmatched( _rcNow ) )},
		Update Properties( 1 ),
		Target Column( :Chem Type )
	);
	
	//what's the point of this column?
	dt_InstTune << New Column( "Script AR", Numeric, Continuous, Set Formula( :"Corrected AR"n ) );
	Column( dt_InstTune, "Script AR" ) << Delete Formula;
	
	dt_InstTune:"Slide Lot"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	
	calBarcodeParse(dt_InstTune, "Barcode");
	dt_InstTune:"Crossweb_BC"n << set name("Cross Web");
	dt_InstTune:"Cross Web"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	dt_InstTune << Delete Columns("Foil"n);
	dt_InstTune:"Foil_BC"n << set name("Foil");
	dt_InstTune:"Foil"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");

	//outlier detection
	dt_InstTune << New Column( "Blocked AR for Outliers",
		Numeric,
		Continuous,
		Set Formula( 
				:"Corrected AR"n - Col Median( :"Corrected AR"n, :"Assay"n, :"Slide Lot"n, :"Inst Type"n )
		)
	);

	dt_InstTune:"Blocked AR for Outliers"n << Delete Formula;

	Grubbs_Outlier_Detection(dt_InstTune, "Blocked AR for Outliers", 0.001);

	dt_InstTune << Delete Columns("Blocked AR for Outliers");
	/*
	Delete all manually excluded rows as well as rows deemed as outliers. Long term it would be ideal
	to ensure the exclusions could be honored (from columns and row states), but that will be a feature
	request for a later release
	*/
	dt_InstTune << Select where( 
		:"Exclusion Rationale"n == "NDE - Grubb's"
		|
		Excluded()
	) << delete rows;

	dt_InstTune << Clear Select;

	
	Return(dt_InstTune);
);


//UNTESTED MAIN FUNCTIONS

subLot2DblockerFunc = Function( {table, respCol, posCol, blockCol, fluidCol, slideLotvar, outputCol, chemTypecol, blockType},
	{default Local}, 
	
	/*table = the loop qual data table
	posCol = the sub lot x positions are going to correct around
	blockCol = a value that the data needs to be blocked for to measure the posCol more accurately
	respCol = intended to be AR
	fluidCol = to cover in the event we have multiple fluid levels in the data this identifies unique fluids
	slideLotvar = the slide lot that excludes the sublot field
	cont = the type of sublot pattern we are correcting for*/
	
	/*
	table=dtSubop;
	respCol="Predicted Dose from Master";
	posCol="Crossweb_LQ";
	blockCol="Foil_LQ";
	fluidCol="Dose";
	slideLotvar="Slide Lot";
	outputCol="Cross Web Correction";
	chemTypecol="Chem Type";
	blockType="Relative"
	*/
	
	parseColNamesublotx = Parse( Eval Insert( ":name(\!"^posCol^\!" )" ) );
	parseColNameblocker = Parse( Eval Insert( ":name(\!"^blockCol^\!" )" ) );
	parseColNamedose = Parse( Eval Insert( ":name(\!"^fluidCol^\!" )" ) );
	parseColNameresponse = Parse( Eval Insert( ":name(\!"^respCol^\!" )" ) );
	parseColNamecoating = Parse( Eval Insert( ":name(\!"^slideLotvar^\!" )" ) );
	parseColNameresponsemean = Parse( Eval Insert( ":name(\!"Mean(\!^respCol^\!)\!" )" ) );
	parseColNamechem = Parse( Eval Insert( ":name(\!"^chemTypecol^\!" )" ) );
	
	colNamechem = Eval Insert( ":name(\!"^chemTypecol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	colNamesublotx = Eval Insert( ":name(\!"^posCol^\!" )" );
	colNameblocker = Eval Insert( ":name(\!"^blockCol^\!" )" );
	colNameresponse = Eval Insert( ":name(\!"^respCol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	
	If(
		blockType == "Relative",
			table << New Column( Char( outputCol ),
				Numeric,
				Continuous,
				Set Formula(
					Col Mean(
						parseColNameresponse - Col Mean( parseColNameresponse, parseColNameblocker, parseColNamedose, parseColNamecoating ),
						parseColNamesublotx,
						parseColNamedose,
						parseColNamecoating
					)
				)
			);
			Column( table, Char( outputCol ) ) << Delete Formula;, 
	
		blockType == "Absolute",
			table << New Column( Char( outputCol ),
				Numeric,
				Continuous,
				Set Formula( Col Mean( parseColNameresponse - parseColNameblocker, parseColNamesublotx, parseColNamedose, parseColNamecoating ) )
			);
			Column( table, Char( outputCol ) ) << Delete Formula;,
		Throw()
	);
);

linearFitadder = Function( {table, respCol, posCol, fluidCol, slideLotvar, chemTypecol, lowmSpec, highmSpec},
	{default Local}, 
	
	/*table = the loop qual data table
	posCol = the sub lot positions are going to correct around
	respCol = intended to be AR
	fluidCol = to cover in the event we have multiple fluid levels in the data this identifies unique fluids
	slideLotvar = the slide lot that excludes the sublot field
	cont = the type of sublot pattern we are correcting for*/
	
	parseColNamesublot = Parse( Eval Insert( ":name(\!"^posCol^\!" )" ) );
	parseColNamedose = Parse( Eval Insert( ":name(\!"^fluidCol^\!" )" ) );
	parseColNameresponse = Parse( Eval Insert( ":name(\!"^respCol^\!" )" ) );
	parseColNamecoating = Parse( Eval Insert( ":name(\!"^slideLotvar^\!" )" ) );
	parseColNameresponsemean = Parse( Eval Insert( ":name(\!"Mean(\!^respCol^\!)\!" )" ) );
	parseColNamechem = Parse( Eval Insert( ":name(\!"^chemTypecol^\!" )" ) );
	
	colNamechem = Eval Insert( ":name(\!"^chemTypecol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	colNamesublot = Eval Insert( ":name(\!"^posCol^\!" )" );
	colNameresponse = Eval Insert( ":name(\!"^respCol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	
	table << New Column( "Sub Lot Condition N",
		Numeric,
		Continous,
		Set Formula( Col Number( parseColNameresponse, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "sumYi",
		Numeric,
		Continuous,
		Set Formula( Col Sum( parseColNameresponse, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "sumXi",
		Numeric,
		Continuous,
		Set Formula( Col Sum( parseColNamedose, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "sumXi*Yi",
		Numeric,
		Continuous,
		Set Formula( Col Sum( parseColNamedose * parseColNameresponse, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "sumXi2",
		Numeric,
		Continuous,
		Set Formula( Col Sum( parseColNamedose ^ 2, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "tempa", Numeric, Continuous, Set Formula( :sumXi / :Sub Lot Condition N ) );
	table << New Column( "coeffb", Numeric, Continuous, Set Formula( -1 * :tempa / (-1 * :tempa * :sumXi + :sumXi2) ) );
	table << New Column( "coeffa", Numeric, Continuous, Set Formula( (1 - :coeffb * :sumXi) / :Sub Lot Condition N ) );
	table << New Column( "coeffd", Numeric, Continuous, Set Formula( 1 / (-1 * :tempa * :sumXi + :sumXi2) ) );
	table << New Column( "coeffc", Numeric, Continuous, Set Formula( -1 * (:coeffd * :sumXi) / :Sub Lot Condition N ) );
	table << New Column( "Offset Calc", Numeric, Continuous, Set Formula( :coeffa * :sumYi + :coeffb * :Name( "sumXi*Yi" ) ) );
	table << New Column( "Gain Calc", Numeric, Continuous, Set Formula( :coeffc * :sumYi + :coeffd * :Name( "sumXi*Yi" ) ) );
	table << New Column( "Gain Check", Numeric, Nominal, Set Formula( If( lowmSpec <= :Gain Calc <= highmSpec, 0, 1 ) ) );
	
	Column( table, "Gain Calc" ) << Set Name( "Gain Calc_" || posCol );
	Column( table, "Offset Calc" ) << Set Name( "Offset Calc_" || posCol );
	Column( table, "Gain Check" ) << Set Name( "Gain Check_" || posCol );
	
	Column( table, "Gain Calc_" || posCol ) << Delete Formula;
	Column( table, "Offset Calc_" || posCol ) << Delete Formula;
	Column( table, "Gain Check_" || posCol ) << Delete Formula;
	
	table << Delete Columns( "Sub Lot Condition N", "sumYi", "sumXi", "sumXi*Yi", "sumXi2", "tempa", "coeffb", "coeffa", "coeffd", "coeffc" );
);


//nate included, will cover UTs for function
buildJSONarray = Function( {mainCurveTable, crosswebTable, foilTable, jsonSavePath, processvar},
	{default local}, 
	///function should probably check to ensure first three are data tables and last is an associative array
	// ... not a must have, but would be good practice
	
	//additional parameters
	// loop qual table (or species cal table) to harvest dry read start/end)
	// build info
	// event info
	// lots covered
	//.... incorporate last 3 into JSON file name at event level (master only needs build level)
	// adding expiration date table (will have more than just Exp dates) (will be opened by other stuff earlier)
	//.... ClipLot becomes cliplot ExpirationDate become exp_date
	//.... delete clip type
	//.... convert chemabbr to chemcode ... don't use array of chem codes, call function to get them and add function to overarching list of functions
	//.... other stuff too based on what comes in with this file
	//.... format Expiration dates as follows below
	//.... make format YYYY.MM.DD (not YYYY-MM-DD)
	/*Data Table( "basicTest_expDates" ):ExpirationDate <<
			Format(
				"Custom",
				Formula(
					Char( Year( value ) ) || "." || Match( Length( Char( Month( value ) ) ),
						1, "0" || Char( Month( value ) ),
						2, Char( Month( value ) )
					) || "." || Match( Length( Char( Day( value ) ) ),
						1, "0" || Char( Day( value ) ),
						2, Char( Day( value ) )
					)
				),
				10,
				0
			);
		*/
	//.... make date column character to be properly maintained in array and to JSON
	//.... update to main curves by code AND lot
	// save (0/1) default to 1
	// json Save path
	
	/*
	mainCurveTable = Datatable("Event100_Base Curve_1001-1001");
	crosswebTable = Datatable("Cross Web");
	foilTable = Datatable("Foil");
	jsonSavePath = "C:\Users\sdarling\OneDrive - IDEXX\Projects\Cal Tool Development\qsdmaCalTestFiles_currentmethod\PQ2\Build 10.73\";
	*/
	//buildInfo = ;//maybe get from json Path?
	//eventInfo = "event500";//maybe get from loop qual table name?
	//lotRangeInEvent = "900-920";//maybe get from loop qual table name?
	//jsonSavePath = "D:\JSL Development\Official JMP Addin Working\UnitTesting\Calibration_LYTES swt-T0-0016988-00_UT\Files\cumulativeJSONtest\Build test99.99\";
	/*
	mainCurveTable = dtCaloutlast;
	crosswebTable = cwSplit2;
	foilTable = foilMasterall;
	jsonSavePath = jsonloc;
	*/
	//variable size reduction
	mainDT = mainCurveTable;
	cwDT = crosswebTable;
	fDT = foilTable;
	jsonPath = jsonSavePath;
	
	eventNum = Word(1,mainDT << get name);
	lotRange = Word(3,mainDT << get name);
		
	pathWords = Words( jsonPath, "/\" );
	For( i = 1, i <= N Items( pathWords ), i++,
		If( Contains( pathWords[i], "Build" ) > 0,
			buildLocale = i;
			Break();
		)
	);
	buildNum = Try( pathWords[buildLocale], "NULL" );
	
	allJSONfiles = Files In Directory( jsonPath );
	If( N Items( allJSONfiles ) == 0,
		jsonFiles = {},
		masterLocale = Contains( allJSONfiles, processvar || "_master_" || buildNum || ".json" );
		jsonFiles = Remove( allJSONfiles, masterLocale );
	);
		
	// goes through crossweb and foil data to turn all both into two entries, duplicate (one for each platform)
	For Each Row(
		cwDT,
		If( Uppercase( Word( 1, :"ID"n, "_" ) ) == "BOTH",
			w = Word( 1, :"ID"n, "_" );
			values = cwDT[Row(), 0];
			:"ID"n = Substitute( :"ID"n, w, "ctdx" );
			//show(w,values,:"ID"n);
			cwDT << add rows( 1 );
			cwDT[N Row( cwDT ), 0] = values;
			cwDT:"ID"n[N Row( cwDT )] = Substitute( :"ID"n, w, "cat1" );
		,
			Empty()
		)
	);
	For Each Row(
		fDT,
		If( Uppercase( Word( 1, :"ID"n, "_" ) ) == "BOTH",
			w = Word( 1, :"ID"n, "_" );
			values = fDT[Row(), 0];
			:"ID"n = Substitute( :"ID"n, w, "ctdx" );
			fDT << add rows( 1 );
			fDT[N Row( fDT ), 0] = values;
			fDT:"ID"n[N Row( fDT )] = Substitute( :"ID"n, w, "cat1" );
		,
			Empty()
		)
	);
	
	mainArray = Associative Array( mainDT:"ID"n );
	cwArray = Associative Array( cwDT:"ID"n );
	fArray = Associative Array( fDT:"ID"n );
	
	//improvement would be to check where "ID" is and if it's not there, error out
	mainCols = mainDT << get column names( string );
	cwCols = cwDT << get column names( string );
	fCols = fDT << get column names( string );
	Remove From( mainCols, 1 );//assumes ID is in 1st position
	Remove From( cwCols, 1 );//assumes ID is in 1st position
	Remove From( fCols, 1 );//assumes ID is in 1st position
	
	//sets of loops to create arrays from each of the three tables
	currentKey = mainArray << first;
	For( i = 1, i <= N Items( mainArray ), i++,
		idRow = mainDT << get rows where( :"ID"n == currentKey );//should only be 1 row
		mainArray[currentKey] = Associative Array();
		For( j = 1, j <= N Items( mainCols ), j++,
			mainArray[currentKey][mainCols[j]] = As Column( mainDT, mainCols[j] )[idRow][1]
		);
		currentKey = mainArray << next( currentKey );
	);
	currentKey = cwArray << first;
	For( i = 1, i <= N Items( cwArray ), i++,
		idRow = cwDT << get rows where( :"ID"n == currentKey );//may be more than 1 row
		cwArray[currentKey] = {};
		For( k = 1, k <= N Items( idRow ), k++,
			Insert Into( cwArray[currentKey], Associative Array() );
			For( j = 1, j <= N Items( cwCols ), j++,
				cwArray[currentKey][k][cwCols[j]] = As Column( cwDT, cwCols[j] )[idRow][k]
			);
		);
		currentKey = cwArray << next( currentKey );
	);
	currentKey = fArray << first;
	For( i = 1, i <= N Items( fArray ), i++,
		idRow = fDT << get rows where( :"ID"n == currentKey );//may be more than 1 row
		fArray[currentKey] = {};
		For( k = 1, k <= N Items( idRow ), k++,
			Insert Into( fArray[currentKey], Associative Array() );
			For( j = 1, j <= N Items( fCols ), j++,
				fArray[currentKey][k][fCols[j]] = As Column( fDT, fCols[j] )[idRow][k]
			);
		);
		currentKey = fArray << next( currentKey );
	);
	
	//combine the three arrays into the one, main array
	currentKey = mainArray << first;
	For( i = 1, i <= N Items( mainArray ), i++,
		subID = Substitute( currentKey, "_" || Word( Length( Words( currentKey, "_" ) ), currentKey, "_" ), "" );
		//Show( currentKey, subID );
		mainArray[currentKey]["crosswebs"] = cwArray[subID];
		mainArray[currentKey]["foils"] = fArray[subID];
		currentKey = mainArray << next( currentKey );
	);
	
	//building the final JSON matching the curve IDs to the correct assays and codes
	intermediateChems = Associative Array( {{"ctdx", {}}, {"cat1", {}}} );
	finalChemArray = Associative Array( {{"ctdx", Associative Array( {{"lots", {}}} )}, {"cat1", Associative Array( {{"lots", {}}} )}} );
	
	platformKey = finalChemArray << first;
	For( k = 1, k <= N Items( finalChemArray ), k++,
		currentKey1 = mainArray << first;
		For( j = 1, j <= N Items( mainArray ), j++,
			idPlatform = Word( 1, currentKey1, "_" );
			If( idPlatform == platformKey,
				Insert Into( intermediateChems[platformKey], currentKey1 ),
				Empty()
			);
			currentKey1 = mainArray << next( currentKey1 );
		);
		platformKey = finalChemArray << next( platformKey );
	);
	
	platformKey = intermediateChems << first;
	For( i = 1, i <= N Items( intermediateChems ), i++,
		For( j = 1, j <= N Items( intermediateChems[platformKey] ), j++,
			Insert Into( finalChemArray[platformKey]["lots"], mainArray[intermediateChems[platformKey][j]] )
		);
		platformKey = intermediateChems << next( platformKey );
	);
	
	eventJSONexpr = As JSON Expr( finalChemArray );
	//save finalChemArray for singular event
	Save Text File( jsonPath || buildNum || "_" || eventNum || "_LOTS_" || lotRange || "_" || char(today()) || ".json", eventJSONexpr );
	
	For( i = 1, i <= N Items( jsonFiles ), i++,
		tempJSONArray = Parse JSON( Load Text File( jsonPath || jsonFiles[i] ) );
		platformKey = finalChemArray << first;
		For(j=1,j<=nitems(finalChemArray),j++,
			insertinto(
				finalChemArray[platformKey]["lots"]
				,
				tempJSONArray[platformKey]["lots"]
			);
			platformKey = finalChemArray << Next(platformKey)
		)
	);
		
	jsonExpr = As JSON Expr( finalChemArray );
	
	//save final chem array as new master
	Save Text File( jsonPath || processvar ||"_master_" || buildNum || ".json", jsonExpr );
	
	//later release will close these as their information is in the other tables and JSON
	//Close(mainDT,nosave);
	//Close(cwDT,nosave);
	//Close(fDT,nosave);
	
	Return( eventJSONexpr, jsonExpr );
);

//from jesses work. Nate needs to test and integrate into calFitFunc
//untested
lytesCubicTo3P = Function( {table, responseColumn, concentrationColumn, slideLotColumn, assayColumn, instrumentTypeColumn},
	{default local}, 
	
	//will only work with Assay Code, currently. ChemType is not supported
	
	//table = currentdatatable();
	//responseColumn = "AR";
	//concentrationColumn = "Target";
	//slideLotColumn = "Lot";
	//assayCodeColumn = "Assay";
	
	//variable shortening
	respCol = responseColumn;
	concCol = concentrationColumn;
	lotCol = slideLotColumn;
	assayCol = assayColumn;
	instTypeCol = instrumentTypeColumn;
	
	//convert text cols names into jsl local column variables
	//JMP 16 may have fixed issues that require needing both styles
	nameRespCol = Eval Insert( ":\!"^respCol^\!"n" );
	nameConcCol = Eval Insert( ":\!"^concCol^\!"n" );
	nameLotCol = Eval Insert( ":\!"^lotCol^\!"n" );
	nameAssayCol = Eval Insert( ":\!"^assayCol^\!"n" );
	nameInstCol = Eval Insert( ":\!"^instTypeCol^\!"n" );
	
	parseRespCol = Parse( Eval Insert( ":\!"^respCol^\!"n" ) );
	parseConcCol = Parse( Eval Insert( ":\!"^concCol^\!"n" ) );
	parseLotCol = Parse( Eval Insert( ":\!"^lotCol^\!"n" ) );
	parseAssayCol = Parse( Eval Insert( ":\!"^assayCol^\!"n" ) );
	parseInstCol = Parse( Eval Insert( ":\!"^instTypeCol^\!"n" ) );

	platform = table << Fit Curve(
		Y( Parse( nameRespCol ) ),
		X( Parse( nameConcCol ) ), 
		//Group(:Lot),
		Fit Exponential 3P,
		By( Parse( nameInstCol ), Parse( nameAssayCol ), Parse( nameLotCol ) ),
		Invisible
	);
	Wait( 0 );
	dt_3p_uncorrected = Try(
		Report( platform[1] )[Outline Box( "Exponential 3P" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] <<
		Make Combined Data Table( private( 1 ) ),
		Report( platform )[Outline Box( "Exponential 3P" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] <<
		Make Combined Data Table( private( 1 ) )
	);
	dt_3p_uncorrected = unprivatizeTable(seePrivateTables, dt_3p_uncorrected);
	platform << close window;
	//dt_3p_uncorrected:"Group"n << Set Name("Lot") << Data Type( "Numeric" ) << Modeling Type( "Nominal" );
	
	dt_final_curves = dt_3p_uncorrected << Split(
		Split By( :"Parameter"n ),
		Split( :"Estimate"n ),
		Group( parseAssayCol, parseLotCol, parseInstCol ),
		Remaining Columns( Drop All ),
		Sort by Column Property,
		output table name( "cal curves by lot" ),
		private
	);
	dt_final_curves = unprivatizeTable(seePrivateTables, dt_final_curves);
	Close( dt_3p_uncorrected, no save );
	
	Summarize( table, a = by( parseAssayCol ) );
	// first, set up table with dose levels
	dt_dose_levels = New Table( "dose quantiles table", private );
	dt_dose_levels = unprivatizeTable(seePrivateTables, dt_dose_levels);
	dt_dose_levels << Add Rows( N Items( a ) * 101 ); //101 per assay present. we expect 3 always, but in case there isn't
	dt_dose_levels << Delete Columns( {"Column 1"} );
	dt_dose_levels << New Column( assayCol, character, nominal, values( Sort List( Repeat( a, 101 ) ) ) );
	dt_dose_levels << New Column( "Quantile", numeric, continuous, formula( Sequence( 0, 1, 0.01 ) ) );
	dt_dose_levels << New Column( "mid point for Chem Type", formula( assayMidPoint[parseAssayCol] ) );
	dt_dose_levels << New Column( "Concentration (3p uncorrected)",
		numeric,
		continuous,
		formula( assayRange[parseAssayCol][1] + (assayRange[parseAssayCol][2] - assayRange[parseAssayCol][1]) * :"Quantile"n )
	);
	
	// join with curves, duplicating for each:
	dt_full_dose_levels = dt_final_curves << Join(
		With( dt_dose_levels ),
		Merge Same Name Columns,
		By Matching Columns( Eval( Parse( nameAssayCol ) ) = Eval( Parse( nameAssayCol ) ) ),
		Drop multiples( 0, 0 ),
		Include Nonmatches( 1, 1 ),
		Preserve main table order( 1 ),
		output table name( "full dose levels" ),
		private
	);
	dt_full_dose_levels = unprivatizeTable(seePrivateTables, dt_full_dose_levels);
	Close( dt_dose_levels, no save );
	
	// add AR and new concentration columns:
	dt_full_dose_levels << New Column( "AR",
		Numeric,
		"Continuous",
		Formula( :"Asymptote"n + :"Scale"n * Exp( :"Growth Rate"n * :"Concentration (3p uncorrected)"n ) )
	);
	
	//the eval for int account for how it's displayed in the associative array (number plus offset)
	dt_full_dose_levels << New Column( "Concentration (3p corrected)",
		Numeric,
		"Continuous",
		Formula(
			Eval( assayCorrectedCubic[parseAssayCol]["int"] ) + assayCorrectedCubic[parseAssayCol]["lin"] * :"Concentration (3p uncorrected)"n
			+assayCorrectedCubic[parseAssayCol]["quad"] * :"Concentration (3p uncorrected)"n ^ 2 + assayCorrectedCubic[parseAssayCol]["cub"] *
			:"Concentration (3p uncorrected)"n ^ 3
		)
	);
	
	platform = dt_full_dose_levels << Fit Curve(
		Y( Parse( nameRespCol ) ),
		X( :"Concentration (3p corrected)"n ), 
		//Group( parse(nameLotCol) ),
		Fit Cubic,
		By( Parse( nameInstCol ), Parse( nameAssayCol ), Parse( nameLotCol ) ),
		invisible
	);
	Wait( 0 );
	dt_new_curves = Try(
		Report( platform[1] )[Outline Box( "Cubic" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] <<
		Make Combined Data Table( private( 1 ) ),
		Report( platform )[Outline Box( "Cubic" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table( private( 1 ) )
	);
	dt_new_curves = unprivatizeTable(seePrivateTables, dt_new_curves);
	platform << close window;
	//dt_new_curves:"Group"n << Set Name("Lot") << Data Type( "Numeric" ) << Modeling Type( "Nominal" );

	dt_new_curves_split = dt_new_curves << Split(
		Split By( :"Parameter"n ),
		Split( :"Estimate"n ),
		Group( parseAssayCol, parseLotCol, parseInstCol ),
		Remaining Columns( Drop All ),
		Sort by Column Property,
		output table name( "new curves split" )
	);
	
	Column( dt_new_curves_split, assayCol ) << data type( numeric );
	Close( dt_new_curves, no save );
	Close( dt_final_curves, nosave );
	
	Return( dt_new_curves_split )
	
	;
);


//brought in by nate for the starting dialog
//may change the name to something reasonable :)
// nate responsible for unit testing
ionChemCalDialog = Function({},{default local},
	nw = New Window("Operator inputs",
		//show Menu(0),
		//show toolbars(0),
		<< modal,
		
		<< on validate(			
			lyteCal = lytesCalDataPath << get text;
			lyteLoop = lytesLoopFolder << get text;
			lyteExp = lytesExpirationDataPath << get text;
			lyteJSON = lytesJSONSaveFolder << get text;
			
			qCal = qsdmaCalDataPath << get text;
			qLoop = qsdmaLoopFolder << get text;
			qPFT = qsdmaPlatformFTDataPath << get text;
			qSFT = qsdmaSpeciesFTDataPath << get text;
			qLoopMatch = qsdmaLoopMatchDataPath << get text;
			qExpList = If(Left(qsdmaExpirationDataPath<< get text,1) == "{",
				parse(qsdmaExpirationDataPath<< get text);
				,
				qsdmaExpirationDataPath<< get text
			);
			qJSON = qsdmaJSONSaveFolder << get text;
			If(IsMissing(qExpList) == 1,
				qExpSuccess = 0
				,
				IsString(qExpList) == 1,
				qLoopSuccess = 0
				,
				For(i=1,i<=nitems(qExpList),i++,
					if(
						Uppercase(Right(qExpList[i],5)) == ".XLSX" & IsFile(qExpList[i]), qExpSuccess = 1
						,
						qExpSuccess = 0; break()
					)
				);
			);
			//show(tb << get selected,lyteCal,lyteLoop,lyteExp,lyteJSON,qCal,qLoop,qPFT,qSFT,qLoopList,qExpList,qJSON,qExpSuccess);
			
			If(
				tb << get selected == 1, 0
				,
				tb << get selected == 2,
				Right(lyteCal, 4) == ".jmp" & 
				IsFile(lyteCal) &
				
				Is Directory Writable(lyteLoop) &
				(Right(lyteLoop,1) == "/" | Right(lyteLoop,1) == "\") &
				
				Right(lyteExp, 5) == ".xlsm" & 
				IsFile(lyteExp) &
				
				Is Directory Writable(lyteJSON) &
				(Right(lyteJSON,1) == "/" | Right(lyteJSON,1) == "\")
				,
				tb << get selected == 3,
				Right(qCal, 4) == ".jmp" & 
				IsFile(qCal) &
				
				Is Directory Writable(qLoop) &
				(Right(qLoop,1) == "/" | Right(qLoop,1) == "\") &
				
				Right(qPFT, 4) == ".jmp" & 
				IsFile(qPFT) &
				
				Right(qSFT, 4) == ".jmp" & 
				IsFile(qSFT) &
				
				Right(qLoopMatch, 5) == ".xlsm" & 
				IsFile(qLoopMatch) &
				
				qExpSuccess == 1 &
				
				Is Directory Writable(qJSON) &
				(Right(qJSON,1) == "/" | Right(qJSON,1) == "\")
				
			)
		),
		<< return result,
		tb = TabBox(
			Tab Page Box("",Icon("TabBox"),
				Text Box("Please choose your desired tab and fill in the necessary inputs",<< set font style("Bold"), << set font size(12))
			)
			,
			Tab Page Box("LYTES",
				V List Box(
					//TextBox("", << set font size(10)),
					PanelBox("",
						TextBox("Enter or navigate to each location and click 'Ok' to continue", << set wrap(800), << set font style("Bold"), << set font size(10)),
						TextBox("", << set font size(5)),
						HListBox(
							TextBox("Select Location of ", << set font size(10)),
							TextBox("Species Cal Data ", << set font style("Bold"), << set font size(10)),
							TextBox(".jmp file", << set font size(10))
						),
						H List Box(
							lytesCalDataPath = TextEditBox("",
								<< set width(300)
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									file = Pick File(
										,
										,
										{"All Files|jmp"},
										1,
										0,
										,
										//Multiple
									);
									lytesCalDataPath << set text(file);
								);
							);
						),
						TextBox("", << set font size(2)),
						HListBox(
							TextBox("Select Location of ", << set font size(10)),
							TextBox("Loop Qual ", << set font style("Bold"), << set font size(10)),
							TextBox("head folder", << set font size(10))
						),
						H List Box(
							lytesLoopFolder = TextEditBox("",
								<< set width(300)
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									dir = Pick Directory();
									lytesLoopFolder << set text(dir);
								)
							); 
						),
						//DX release not needed for lytes as species cal will have info from check
						/*TextBox("", << set font size(2)),
						HListBox(
							TextBox("Select Location of ",  << set font size(10)),
							TextBox("DX Release ",  << set font style("Bold"), << set font size(10)),
							TextBox(".xlsx file",  << set font size(10))
						),
						H List Box(
							lytesDxReleaseDataPath = TextEditBox("",
								<< set width(300),						
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									file = Pick File(
										,
										,
										{"All Files|xlsx"},
										1,
										0,
										,
										//Multiple
									);
									lytesDxReleaseDataPath << set text(file);
								);
							);
						),*/
						TextBox("", << set font size(2)),
						HListBox(
							TextBox("Select Location of ",  << set font size(10)),
							TextBox("Slide Lot Expiration ",  << set font style("Bold"), << set font size(10)),
							TextBox(".xlsm file",  << set font size(10))
						),
						H List Box(
							lytesExpirationDataPath = TextEditBox("",
								<< set width(300),						
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									file = Pick File(
										,
										,
										{"All Files|xlsm"},
										1,
										0,
										,
										//Multiple
									);
									lytesExpirationDataPath << set text(file);
								);
							);
						),
						TextBox("", << set font size(2)),
						HListBox(
							TextBox("Select where to save the ",  << set font size(10)),
							TextBox(".json ",  << set font style("Bold"), << set font size(10)),
							TextBox("file",  << set font size(10))
						),
						H List Box(
							lytesJSONSaveFolder = TextEditBox("",
								<< set width(300)
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									dir = Pick Directory();
									lytesJSONSaveFolder << set text(dir);
								)
							); 
						)
					)
				)
			)
			,
			Tab Page Box("SDMA(ChemCode 4)",
				V List Box(
					//TextBox("", << set font size(10)),
					PanelBox("",
						TextBox("Enter or navigate to each location and click 'Ok' to continue", << set wrap(800), << set font style("Bold"), << set font size(10)),
						TextBox("", << set font size(5)),
						HListBox(
							TextBox("Select Location of ", << set font size(10)),
							TextBox("Calibration Data ", << set font style("Bold"), << set font size(10)),
							TextBox(".jmp file", << set font size(10))
						),
						H List Box(
							qsdmaCalDataPath = TextEditBox("",
								<< set width(300)
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									file = Pick File(
										,
										,
										{"All Files|jmp"},
										1,
										0,
										,
										//Multiple
									);
									qsdmaCalDataPath << set text(file);
								);
							);
						),
						TextBox("", << set font size(2)),
						HListBox(
							TextBox("Select Location of ", << set font size(10)),
							TextBox("Loop Qual ", << set font style("Bold"), << set font size(10)),
							TextBox("head folder", << set font size(10))
						),
						H List Box(
							qsdmaLoopFolder = TextEditBox("",
								<< set width(300),
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									dir = Pick Directory();
									qsdmaLoopFolder << set text(dir);
								);
							);
						),
						TextBox("", << set font size(5)),
						HListBox(
							TextBox("Select Location of ", << set font size(10)),
							TextBox("Platform Finetune Data ", << set font style("Bold"), << set font size(10)),
							TextBox(".jmp file", << set font size(10))
						),
						H List Box(
							qsdmaPlatformFTDataPath = TextEditBox("",
								<< set width(300)
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									file = Pick File(
										,
										,
										{"All Files|jmp"},
										1,
										0,
										,
										//Multiple
									);
									qsdmaPlatformFTDataPath << set text(file);
								);
							);
						),
						TextBox("", << set font size(5)),
						HListBox(
							TextBox("Select Location of ", << set font size(10)),
							TextBox("Species Finetune Data ", << set font style("Bold"), << set font size(10)),
							TextBox(".jmp file", << set font size(10))
						),
						H List Box(
							qsdmaSpeciesFTDataPath = TextEditBox("",
								<< set width(300)
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									file = Pick File(
										,
										,
										{"All Files|jmp"},
										1,
										0,
										,
										//Multiple
									);
									qsdmaSpeciesFTDataPath << set text(file);
								);
							);
						),
						TextBox("", << set font size(2)),
						HListBox(
							TextBox("Select Location of ",  << set font size(10)),
							TextBox("QSDMA Tracking Board ",  << set font style("Bold"), << set font size(10)),
							TextBox(".xlsm file",  << set font size(10))
						),
						H List Box(
							qsdmaLoopMatchDataPath = TextEditBox("",
								<< set width(300),						
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									file = Pick File(
										,
										,
										{"All Files|xlsm"},
										1,
										0,
										,
										//Multiple
									);
									qsdmaLoopMatchDataPath << set text(file);
								);
							);
						),
						TextBox("", << set font size(2)),
						HListBox(
							TextBox("Select Location of ",  << set font size(10)),
							TextBox("Slide Lot Expiration ",  << set font style("Bold"), << set font size(10)),
							TextBox(".xlsx file(s)",  << set font size(10))
						),
						H List Box(
							qsdmaExpirationDataPath = TextEditBox("",
								<< set width(300),						
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									file = Pick File(
										,
										,
										{"All Files|xlsx"},
										1,
										0,
										,
										Multiple
									);
									qsdmaExpirationDataPath << set text(char(file));
								);
							);
						),
						TextBox("", << set font size(2)),
						HListBox(
							TextBox("Select where to save the ",  << set font size(10)),
							TextBox(".json ",  << set font style("Bold"), << set font size(10)),
							TextBox("file",  << set font size(10))
						),
						H List Box(
							qsdmaJSONSaveFolder = TextEditBox("",
								<< set width(300)
							),
							TextBox("  "),
							buttonbox("",
								<< Set Icon( "WinFileOpen" ),
								<< set script(
									dir = Pick Directory();
									qsdmaJSONSaveFolder << set text(dir);
								)
							); 
						)
					)
				)
			)
		)
		,
		TextBox("", << set font size(5)),
		H List Box(
			ButtonBox("Ok"),
			ButtonBox("Cancel")
		)
	);
	
	If(nw["Button"] == -1, Return(0), Return(nw));
);

//may change the inputs. still working on this.
lytesAssStitching = Function( {dtCal, dtLoop, dtSlideLotExpiration, jsonloc},
	{default local}, 
	//testing variables
	//dtCal = Data Table( "CAL_OLOL 1000-1002_CATwAVL9180.jmp" );
	//dtLoop = Data Table( "Untitled 10530.jmp" );
	//dtSlideLotExpiration = Data Table( "Summary.jmp" );
	//table that converts loop lot numbers to production lot numbers - there are a few things we need to do with that before the analysis takes off
	/*
	dtCal = calData;
	dtLoop = loopData;
	dtSlideLotExpiration = expiration;
	jsonloc = jsonPath;
	*/
	//setting variables
	dtSub = dtLoop;
	dtSLExp = dtSlideLotExpiration;
	cwPostotal = 40;
	foilPostotal = 30;
	defaultBin = 8;

	calCWlow = Min( Column( dtCal, "Cross Web" ) << Get Values );
	calCWhigh = Max( Column( dtCal, "Cross Web" ) << Get Values );
	calFoil = Mode( Column( dtCal, "Foil" ) << Get Values );

	dtCal2 = dtCal << Subset( Selected Rows( 0 ), Selected Columns( 0 ), Invisible );
	/*
	Typically the deletion of the exclusions would be done in the prep step like for other tables but this
	code already had the subset step in to maintain the original cal table. the decision was to delete the
	exclusions from that subset instead. long term it would be ideal to ensure the exclusions could be honored
	(from columns and row states), but that will be a feature request for a later release
	*/
	dtCal2 << Select where( 
		:"Exclusion Rationale"n == "NDE - Grubb's"
		|
		Excluded()
	) << delete rows;
	dtCalout = calFitfunc( dtCal, "Cross Web", "AR", "Dose", "Slide Lot", "Chem Type", "Inst Type", "3P", "Master" );
	Column( dtCalout, "Slide Lot" ) << Set Data Type( "Numeric" );
	
	dtCalout2 = dtCalout << Subset( Selected Rows( 0 ), Selected Columns( 0 ), Invisible );
	dtSubop = subLottabprep( dtSub, dtCalout, calCWlow, calCWhigh, calFoil, "Cross Web", "Foil", "AR", "Dose", "Slide Lot", "Chem Type", "Inst Type", "3P" );
	
	//this will be a place holder assigned target for the correction logic
	dtSubop << New Column( "Loop Average Dose",
		Numeric,
		Continuous,
		Set Formula( Col Mean( :Predicted Dose from Master, :Dose, :Slide Lot, :Chem Type ) )
	);

	//relative correction to evaluate the cross web pattern by dose level
	subLot2DblockerFunc(
		dtSubop,
		"Predicted Dose from Master",
		"Cross Web",
		"Foil",
		"Dose",
		"Slide Lot",
		"cal_CW Correction",
		"Chem Type",
		"Relative"
	);

	dtSubop << New Column( "cal_CW Corrected Dose", Numeric, Continuous, Set Formula( :Predicted Dose from Master - :"cal_CW Correction"n ) );
	
	//relative correction to evaluate the foil corrections by dose level
	subLot2DblockerFunc( dtSubop, "cal_CW Corrected Dose", "Foil", "Loop Average Dose", "Dose", "Slide Lot", "cal_Foil Correction", "Chem Type", "Absolute" );
	
	dtSubop << New Column( "cal_Foil Corrected Dose", Numeric, Continuous, Set Formula( :Predicted Dose from Master - :"cal_Foil Correction"n ) );
	
	//this is for informational purposes only and is used to later check the actual corrections vs. entitlement to know if we found any distressing discontinuities along the way
	dtSubop << New Column( "Entitlement Sublot Dose", Numeric, Continuous, Set Formula( :"cal_CW Corrected Dose"n - :"cal_Foil Correction"n ) );

	//now we're going to calculate the raw correction factors for cross web
	//first step is to subset out the raw CW corrections and associated dose information - I use a summary for this only because it was the easiest thing to do
	dtSubop_cw = dtSubop << Summary(
		Group( :"Chem Type"n, :"Slide Lot"n, :"Cross Web"n, :"Dose"n, :"Loop Average Dose"n, :"cal_CW Correction"n ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 )
	);
	
	
	//rebuilding the dose data with the indivdiual fluid corrections - this preserves any proportional bias should it exist
	//check that you applied the cross web correction right for this
	dtSubop_cw << New Column( "Cross Web Dose", Numeric, Continuous, Set Formula( :"Loop Average Dose"n - :"cal_CW Correction"n ) );
	
	//this is generating the slope and offset corrections by cross web position, slide lot, and chem type
	linearFitadder( dtSubop_cw, "Cross Web Dose", "Cross Web", "Loop Average Dose", "Slide Lot", "Chem Type", 0.5, 1.5 );
	

	//this is interpolating the slope and offset terms for cross web with the spline
	cwCorrsoffsetpred = subLotcharFunc( dtSubop_cw, "Cross Web", "Offset Calc_Cross Web", "Slide Lot", "Chem Type", 100, "Yes" );
	Wait( 0 );
	Column( cwCorrsoffsetpred, "Cross Web_Predicted Correction" ) << Set Name( "Cross Web Offset Predicted" );
	
	
	//this is producing no slope from time to time. Come back and troubleshoot. Missing Chem Type.
	cwCorrsslopepred = subLotcharFunc( dtSubop_cw, "Cross Web", "Gain Calc_Cross Web", "Slide Lot", "Chem Type", 100, "Yes" );
	Wait( 0 );
	Column( cwCorrsslopepred, "Cross Web_Predicted Correction" ) << Set Name( "Cross Web Slope Predicted" );
	

	
	//this is joining the offset and slope corrections for crossweb into one table
	crossWebmaster = cwCorrsoffsetpred << Join(
		With( cwCorrsslopepred ),
		Merge Same Name Columns,
		Match Flag( 0 ),
		By Matching Columns( :Chem Type = :Chem Type, :Slide Lot = :Slide Lot, :Cross Web = :Cross Web ),
		Drop multiples( 0, 0 ),
		Include Nonmatches( 1, 0 ),
		Preserve main table order( 1 )
	);
	
	
	//closing windows we don't need anymore
	cwCorrsoffsetpred << Close Window;
	cwCorrsslopepred << Close Window;
	
	//getting the spline formula for the CW terms to use elsewhere
	offsetCWspline = Column( crossWebmaster, "Cross Web Offset Predicted" ) << Get Formula;
	gainCWspline = Column( crossWebmaster, "Cross Web Slope Predicted" ) << Get Formula;

	Column( crossWebmaster, "Cross Web Offset Predicted" ) << Set Name( "CW Offset Spline" );
	Column( crossWebmaster, "Cross Web Slope Predicted" ) << Set Name( "CW Gain Spline" );

	cwMasterall = crossWebmaster;
	//show(cwMasterall, crossWebmaster);

	dtSubop_cw << Close Window;
	
	//////////////////foil stuff/////////////////////////////////////
	//now we're going to calculate the correction factors for foils
	//first step is to subset out the raw foil corrections and associated dose information - I use a summary for this only because it was the easiest thing to do
	dtSubop_foil = dtSubop << Summary(
		Group( :Chem Type, :Slide Lot, :Foil, :Dose, :"Loop Average Dose"n, :"cal_Foil Correction"n ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 )
	);

	//rebuilding the dose data with the indivdiual fluid corrections - this preserves any proportional bias should it exist
	dtSubop_foil << New Column( "Foil Dose", Numeric, Continuous, Set Formula( :"Loop Average Dose"n - :"cal_Foil Correction"n ) );


	//this is generating the slope and offset corrections by foil position, slide lot, and chem type
	linearFitadder( dtSubop_foil, "Foil Dose", "Foil", "Loop Average Dose", "Slide Lot", "Chem Type", 0.5, 1.5 );
	
	//this is interpolating the slope and offset terms for foil with the spline
	foilCorrsoffsetpred = subLotcharFunc( dtSubop_foil, "Foil", "Offset Calc_Foil", "Slide Lot", "Chem Type", 100, "Yes" );
	Wait( 0 );
	Column( foilCorrsoffsetpred, "Foil_Predicted Correction" ) << Set Name( "Foil Offset Predicted" );
	
	//show(foilCorrsoffsetpred);
	
	foilCorrsslopepred = subLotcharFunc( dtSubop_foil, "Foil", "Gain Calc_Foil", "Slide Lot", "Chem Type", 100, "Yes" );
	Wait( 0 );
	Column( foilCorrsslopepred, "Foil_Predicted Correction" ) << Set Name( "Foil Slope Predicted" );

	//show(foilCorrsslopepred);
	
	//this is joining the offset and slope corrections for foil into one table
	foilMaster = foilCorrsoffsetpred << Join(
		With( foilCorrsslopepred ),
		Merge Same Name Columns,
		Match Flag( 0 ),
		By Matching Columns( :Chem Type = :Chem Type, :Slide Lot = :Slide Lot, :Foil = :Foil ),
		Drop multiples( 0, 0 ),
		Include Nonmatches( 1, 0 ),
		Preserve main table order( 1 )
	);
	
	//closing windows we don't need anymore
	foilCorrsoffsetpred << Close Window;
	foilCorrsslopepred << Close Window;
	
	//getting the spline formula for the foil terms to use elsewhere
	offsetFoilspline = Column( foilMaster, "Foil Offset Predicted" ) << Get Formula;
	gainFoilspline = Column( foilMaster, "Foil Slope Predicted" ) << Get Formula;
	
	foilMasterall = foilMaster;
	
	Column( foilMasterall, "Foil Offset Predicted" ) << Set Name( "Foil Offset Spline" );
	Column( foilMasterall, "Foil Slope Predicted" ) << Set Name( "Foil Gain Spline" );

	dtSubop_foil << Close Window;
	
	//end of sub lot spline calculations - start of transforming sub lot coefficients into DB format//////////
	//we'll do foil first because it's easier!
	foilMasterall << New Column( "b", Numeric, Continuous, Set Formula( Round( :Foil Offset Spline * 10000, 0 ) / 10000 ) );
	foilMasterall << New Column( "a", Numeric, Continuous, Set Formula( Round( :Foil Gain Spline * 10000, 0 ) / 10000 ) );
	
	Column( foilMasterall, "a" ) << Delete Formula;
	Column( foilMasterall, "b" ) << Delete Formula;
	
	foilMasterall << Set Name( "Foil" );

	//now crossweb tranform to DB structure
	cwMasterall << New Column( "Cross Web Start", Numeric, Continuous, Set Formula( (Ceiling( :Cross Web / defaultBin ) - 1) * defaultBin + 1 ) );
	cwMasterall << New Column( "Cross Web End", Numeric, Continuous, Set Formula( :Cross Web Start + defaultBin - 1 ) );
	
	Column( cwMasterall, "Cross Web Start" ) << Delete Formula;
	Column( cwMasterall, "Cross Web End" ) << Delete Formula;

	dtFit = cwMasterall << Bivariate(
		Y( :CW Offset Spline, :CW Gain Spline ),
		X( :Cross Web ),
		By( :Chem Type, :Slide Lot, :Cross Web Start, :Cross Web End ),
		Fit Special( Degree( 3 ), Centered Polynomial( 0 ), {Line Color( {61, 174, 70} )} )
	);
	//Show( dtFit );
	//Show( dtFit[1] );
	Wait( 0 );
	
	//////////////////////////////////////////////////////////////////////////////////////////////
	////////The code for the variable cwInterptemp will be different for JMP 16 vs JMP 15. 15 requires  "Polynomial Fit Degree=3" whereas 16 supports the original code of  "Polynomial Fit Degree=3 Uncentered". Maybe a try/accept here to fix it?////////
	//////////////////////////////////////////////////////////////////////////////////////////////
	cwInterptemp = Report( dtFit[1] )[Outline Box( "Polynomial Fit Degree=3 Uncentered" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table;
	dtFit << Close Window;
	
	cwMasterall << Close Window;

	cwSplit1 = cwInterptemp << Split(
		Split By( :Term ),
		Split( :Estimate ),
		Group( :Slide Lot, :Chem Type, :Cross Web End, :Cross Web Start, :Y ),
		Remaining Columns( Drop All ),
		Sort by Column Property,
		Invisible
	);

	cwInterptemp << Close Window;
	
	
	cwSplit2 = cwSplit1 << Split(
		Split By( :Y ),
		Split( :Cross Web, :"Cross Web^2"n, :"Cross Web^3"n, :Intercept ),
		Group( :Slide Lot, :Chem Type, :Cross Web End, :Cross Web Start ),
		Sort by Column Property
	);
		
	cwSplit1 << Close Window;

	Column( cwSplit2, "Cross Web End" ) << Set Data Type( "Numeric" );
	Column( cwSplit2, "Cross Web Start" ) << Set Data Type( "Numeric" );
	Column( cwSplit2, "Slide Lot" ) << Set Data Type( "Numeric" );

	Column( cwSplit2, "Intercept CW Offset Spline" ) << Set Name( "e" );
	Column( cwSplit2, "Cross Web CW Offset Spline" ) << Set Name( "f" );
	Column( cwSplit2, "Cross Web^2 CW Offset Spline" ) << Set Name( "g" );
	Column( cwSplit2, "Cross Web^3 CW Offset Spline" ) << Set Name( "h" );
	Column( cwSplit2, "Intercept CW Gain Spline" ) << Set Name( "a" );
	Column( cwSplit2, "Cross Web CW Gain Spline" ) << Set Name( "b" );
	Column( cwSplit2, "Cross Web^2 CW Gain Spline" ) << Set Name( "c" );
	Column( cwSplit2, "Cross Web^3 CW Gain Spline" ) << Set Name( "d" );
	
	cwSplit2 << Set Name( "Cross Web" );
	
	////apply the initial base curve and sub lot corrections to calibration data
	//adding initial base 3P coefficients to calibration data table
	dtCal2 << Update(
		With( dtCalout2 ),
		Match Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type, :Inst Type = :Inst Type ),
		Add Columns from Update Table( :Asymptote, :Growth Rate, :Scale )
	);
	dtCal2 << New Column( "Base Concentration", Numeric, Continuous, Set Formula( Log( (:AR - :Asymptote) / :Scale ) / :Growth Rate ) );
	dtCal2 << Set Name( "Base Cal Table" );
	
	
	//adding foil corrections to calibration data table
	dtCal3 = dtCal2 << Join(
		With( foilMasterall ),
		By Matching Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type, :Foil = :Foil ),
		Merge Same Name Columns,
		Invisible
	);
	
	Column( dtCal3, "b" ) << Set Name( "Foil b" );
	Column( dtCal3, "a" ) << Set Name( "Foil a" );
	
	//adding cross web corrections to calibration data table
	dtCal3 << New Column( "Cross Web Start", Numeric, Continuous, Set Formula( (Ceiling( :Cross Web / defaultBin ) - 1) * defaultBin + 1 ) );
	dtCal3 << New Column( "Cross Web End", Numeric, Continuous, Set Formula( :Cross Web Start + defaultBin - 1 ) );
	
	dtCalfinal = dtCal3 << Join(
		With( cwSplit2 ),
		By Matching Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type, :Cross Web Start = :Cross Web Start, :Cross Web End = :Cross Web End ),
		Merge Same Name Columns,
		Invisible
	);

	//desktop clean up
	dtCal3 << Close Window;
	dtCal2 << Close Window;

	//calculate the cross web corrections from parameter system
	dtCalfinal << New Column( "Cross Web Gain",
		Numeric,
		Continuous,
		Set Formula( :a + :b * :Cross Web + :c * :Cross Web ^ 2 + :d * :Cross Web ^ 3 )
	);
	dtCalfinal << New Column( "Cross Web Offset",
		Numeric,
		Continuous,
		Set Formula( :e + :f * :Cross Web + :g * :Cross Web ^ 2 + :h * :Cross Web ^ 3 )
	);

	//calculate the full sub lot corrections from the foil and cross web corrections
	dtCalfinal << New Column( "Sub Lot Gain", Numeric, Continuous, Set Formula( :Foil a * :Cross Web Gain ) );
	dtCalfinal << New Column( "Sub Lot Offset", Numeric, Continuous, Set Formula( :Foil a * :Cross Web Offset + :Foil b ) );

	dtCalfinal << New Column( "Sub Lot Corrected Dose", Numeric, Continuous, Set Formula( :Sub Lot Gain * :Base Concentration + :Sub Lot Offset ) );

	////adjust master curve coefficients to make calibration data perfectly accurate
	dtCalfinal << New Column( "Sub Lot Adjusted Dose", Numeric, Continuous, Set Formula( (:Dose - :Sub Lot Offset) / :Sub Lot Gain ) );

	////produce master curve JMP file - modify this to be dynamic for the assay////////////////////////////////
	///instead of calFitfunc -- would call jesses func. sub lot adjusted dose as your x. AR as normal.
	//dtCaloutlast = calFitfunc( dtCalfinal, "Cross Web", "AR", "Sub Lot Adjusted Dose", "Slide Lot", "Chem Type", "Inst Type", "3P", "Master" );
	dtCaloutlast = lytesCubicTo3P(dtCalfinal, "AR", "Sub Lot Adjusted Dose", "Slide Lot", "Assay", "Inst Type");
	dtCaloutlast << Set Name( "Final Curve Coefficients" );
	Column( dtCaloutlast, "Slide Lot" ) << Set Data Type( "Numeric" ) << Set Modeling Type( "Continuous" );

	//Newton Rhaphson if we wanted to check this.
	dtCalfinal << Update(
		With( dtCaloutlast ),
		Match Columns( :Slide Lot = :Slide Lot, :Assay = :Assay, :Inst Type = :Inst Type ),
		//Replace Columns in Main Table( :Asymptote, :Growth Rate, :Scale ) Removed as this is for a 3P not a cubic.
		Add Columns from Update Table( :Cubic, :Intercept, :Quadratic, :Slope),
		Replace Columns in Main Table( None )
	);

	dtCalfinal << delete columns("Base Concentration", "Sub Lot Corrected Dose", "Sub Lot Adjusted Dose");

	dtCalfinal << new column(
		"Base Concentration Char",
		Character,
		Nominal,
		Formula(
			p=((3*:"Slope"n)/:"Cubic"n - (:"Quadratic"n/:"Cubic"n)^2)/3;
			q=(2*(:"Quadratic"n/:"Cubic"n)^3 - ((9*:"Quadratic"n*:"Slope"n)/:"Cubic"n)/:"Cubic"n + (27*(:"Intercept"n-:"AR"n)/:"Cubic"n))/27;
			newD=(p/3)^3 + (q/2)^2;
			phi=ArcCosine((-q/2)/((abs(p)^3)/27)^0.5);

			If(newD>=0,
				u=Root((-q/2 + (newD)^0.5),3);
				v=Root((-q/2 - (newD)^0.5),3);
				y1=u+v;
				x1=y1 - (:"Quadratic"n/:"Cubic"n)/3;
				char(x1),
				y1=2*((abs(p)/3)^0.5) * Cosine(phi/3);
				y2=-2*((abs(p)/3)^0.5) * Cosine((phi+Pi())/3);
				y3=-2*((abs(p)/3)^0.5) * Cosine((phi-Pi())/3);
				x1=y1-(:"Quadratic"n/:"Cubic"n)/3;
				x2=y2-(:"Quadratic"n/:"Cubic"n)/3;
				x3=y3-(:"Quadratic"n/:"Cubic"n)/3;
				char(x1)||" "||char(x2)||" "||char(x3)
			);
		);
	);

	dtCalfinal:"Base Concentration Char"n << delete formula;

	dtCalfinal << New Column( "Base Concentration",
		Numeric,
		Continuous,
		Set Formula( num(:"Base Concentration Char"n) )
	);

	dtCalfinal << New Column( "Sub Lot Corrected Dose", Numeric, Continuous, Set Formula( :"Sub Lot Gain"n * :"Base Concentration"n + :"Sub Lot Offset"n ) );
	
	////////////////////////////////////////////////////////////////////////////

	//column name cleanup in the calibration data table
	Column( dtCalfinal, "Sub Lot Corrected Dose" ) << Set Name( "Calc Dose" );	
	
	//crossWebmaster << Close Window; Table closed long before this step.
	//foilMaster << Close Window; This closes the Data Table("Foil"). Which is called in a later step.
	dtCalout2 << Close Window;

	////clean up all the tables that go into the JSON maker

	//cwSplit2 = cross web table
	//foilMasterall = foil table
	//dtCaloutlast = master curve coefficients

	foilMasterall << Delete Columns( "N Rows", "Foil Gain Spline", "Foil Offset Spline" );

	/* For QSDMA as Lytes is a Cubic fit.
	Column( dtCaloutlast, "Asymptote" ) << Set Name( "a" );
	Column( dtCaloutlast, "Scale" ) << Set Name( "b" );
	Column( dtCaloutlast, "Growth Rate" ) << Set Name( "c" );
	*/
	
	Column( dtCaloutlast, "Cubic" ) << Set Name( "d" );
	Column( dtCaloutlast, "Quadratic" ) << Set Name( "c" );
	Column( dtCaloutlast, "Slope" ) << Set Name( "b" );
	Column( dtCaloutlast, "Intercept" ) << Set Name( "a" );
	
	////add all the calibration and sublot corrections to the sub lot table to check that it's all good

	foilMastertemp = foilMasterall << Subset( All rows, Selected columns only( 0 ), Invisible );
	cwMastertemp = cwSplit2 << Subset( All rows, Selected columns only( 0 ), Invisible );
	dtCaloutlasttemp = dtCaloutlast << Subset( All rows, Selected columns only( 0 ), Invisible );
	
	///changing paramater column names so that when everyone is joined in we don't overwrite existing columns
	Column( foilMastertemp, "a" ) << Set Name( "Foil a" );
	Column( foilMastertemp, "b" ) << Set Name( "Foil b" );

	Column( cwMastertemp, "a" ) << Set Name( "CW a" );
	Column( cwMastertemp, "b" ) << Set Name( "CW b" );
	Column( cwMastertemp, "c" ) << Set Name( "CW c" );
	Column( cwMastertemp, "d" ) << Set Name( "CW d" );
	Column( cwMastertemp, "e" ) << Set Name( "CW e" );
	Column( cwMastertemp, "f" ) << Set Name( "CW f" );
	Column( cwMastertemp, "g" ) << Set Name( "CW g" );
	Column( cwMastertemp, "h" ) << Set Name( "CW h" );

	Column( dtCaloutlasttemp, "a" ) << Set Name( "Base a" );
	Column( dtCaloutlasttemp, "b" ) << Set Name( "Base b" );
	Column( dtCaloutlasttemp, "c" ) << Set Name( "Base c" );
	Column( dtCaloutlasttemp, "d" ) << Set Name( "Base d" );
	//Try( Column( dtCaloutlasttemp, "d" ) << Set Name( "Base d" ), Throw() ); Lytes will have a column d because it's a cubic fit. QSDMA will not.
	
	///updating the loop qual table to check the precision post sub lot corrections
	//adding base curve data to loop qual
	Try(
		dtSubop << Update(
			With( dtCaloutlasttemp ),
			Match Columns( :Slide Lot = :Slide Lot, :Assay = :Assay, :Inst Type = :Inst Type ),
			Add Columns from Update Table( :Base a, :Base b, :Base c, :Base d )
		),
		dtSubop << Update(
			With( dtCaloutlasttemp ),
			Match Columns( :Slide Lot = :Slide Lot, :Assay = :Assay, :Inst Type = :Inst Type ),
			Add Columns from Update Table( :Base a, :Base b, :Base c )
		)
	);
	
	dtCaloutlasttemp << Close Window;

	//adding cross web corrections to loop qual table
	dtSubop << New Column( "Cross Web Start", Numeric, Continuous, Set Formula( (Ceiling( :Cross Web / defaultBin ) - 1) * defaultBin + 1 ) );
	dtSubop << New Column( "Cross Web End", Numeric, Continuous, Set Formula( :Cross Web Start + defaultBin - 1 ) );
	Column( dtSubop, "Cross Web Start" ) << Delete Formula;
	Column( dtSubop, "Cross Web End" ) << Delete Formula;
	
	dtSubop << Update(
		With( cwMastertemp ),
		Match Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type, :Cross Web Start = :Cross Web Start, :Cross Web End = :Cross Web End ),
		Add Columns from Update Table( :CW b, :CW f, :CW c, :CW g, :CW d, :CW h, :CW a, :CW e )
	);
	cwMastertemp << Close Window;
	
	
	//adding foil corrections to the loop qual table
	dtSubop << Update(
		With( foilMastertemp ),
		Match Columns( :Foil = :Foil, :Chem Type = :Chem Type, :Slide Lot = :Slide Lot ),
		Add Columns from Update Table( :Foil b, :Foil a )
	);
	foilMastertemp << Close Window;

	dtCalfinal << Set Name( "Calibration Data" );
	dtSubop << Set Name( "Loop Qual Data" );
	dtCalfinal << show window(1);
	dtSubop << show window(1);

	////adding in the dose calculation columns to the loop qual table
	/*If(
		:Chem Type == "SDMA",
			
		,
		:Chem Type == "NA" | :Chem Type == "K" | :Chem Type == "CL", :Base a + :Base b * :AR + :Base c * :AR ^ 2 + :Base d * AR ^ 3,
		Stop()
	);*/
	/*
	dtSubop << New Column( "Base Concentration", Numeric, Continuous, 
		Set Formula(
			If(
				:Chem Type == "SDMA",
					Log( (:AR - :Base a) / :Base b ) / :Base c 
				,
				:Chem Type == "NA" | :Chem Type == "K" | :Chem Type == "CL", 
					:Base a + :Base b * :AR + :Base c * :AR ^ 2 + :Base d * AR ^ 3
			)
		)
	);*/
	
	//base concentration will now be added using a method to solve a cubic function for lytes as lytes is fit with a cubic.
	dtSubop << new column(
		"Base Concentration Char",
		Numeric,
		Continuous,
		Formula(
			p=((3*:"Base b"n)/:"Base d"n - (:"Base c"n/:"Base d"n)^2)/3;
			q=(2*(:"Base c"n/:"Base d"n)^3 - ((9*:"Base c"n*:"Base b"n)/:"Base d"n)/:"Base d"n + (27*(:"Base a"n-:"AR"n)/:"Base d"n))/27;
			D=(p/3)^3 + (q/2)^2;
			phi=ArcCosine((-q/2)/((abs(p)^3)/27)^0.5);

			If(D>=0,
				u=Root((-q/2 + (D)^0.5),3);
				v=Root((-q/2 - (D)^0.5),3);
				y1=u+v;
				x1=y1 - (:"Base c"n/:"Base d"n)/3;
				char(x1),
				y1=2*((abs(p)/3)^0.5) * Cosine(phi/3);
				y2=-2*((abs(p)/3)^0.5) * Cosine((phi+Pi())/3);
				y3=-2*((abs(p)/3)^0.5) * Cosine((phi-Pi())/3);
				x1=y1-(:"Base c"n/:"Base d"n)/3;
				x2=y2-(:"Base c"n/:"Base d"n)/3;
				x3=y3-(:"Base c"n/:"Base d"n)/3;
				char(x1)||" "||char(x2)||" "||char(x3)
			);
		);
	);
	
	dtSubop << New Column( "Base Concentration",
		Numeric,
		Continuous,
		Set Formula( num(:"Base Concentration Char"n) )
	);
	
	dtSubop << New Column( "Cross Web Gain",
		Numeric,
		Continuous,
		Set Formula( :CW a + :CW b * :Cross Web + :CW c * :Cross Web ^ 2 + :CW d * :Cross Web ^ 3 )
	);
	dtSubop << New Column( "Cross Web Offset",
		Numeric,
		Continuous,
		Set Formula( :CW e + :CW f * :Cross Web + :CW g * :Cross Web ^ 2 + :CW h * :Cross Web ^ 3 )
	);

	dtSubop << New Column( "Sub Lot Gain", Numeric, Continuous, Set Formula( :Foil a * :Cross Web Gain ) );
	dtSubop << New Column( "Sub Lot Offset", Numeric, Continuous, Set Formula( :Foil a * :Cross Web Offset + :Foil b ) );
	
	dtSubop << New Column( "Calc Dose", Numeric, Continuous, Set Formula( :"Sub Lot Gain"n * :"Base Concentration"n + :"Sub Lot Offset"n ) );

	//do a little work with dtcal to getdry reads and table name on based coeffs then do JSON stuffs
	//the assumption is dtCal (the original cal table) will be named with something like: CALxx LOTS yyyyyy-zzzzzz
	//xx = the Cal Event for the build
	//yyyyyy = lot range start for the event
	//zzzzzz = lot range end for the event

	dtCaloutlast << set name( dtCal << get name || "_base coefficients");
	
	dtCal << close window;
	dtSub << close window;
	
	////MAY NEED TO DELETE CLIP LOT FROM EXP DATE SINCE IT WILL BE IN CAL DATA FROM DX RELEASE
	dtCalFinal << Update(
		With( dtSLExp ),
		Match Columns( :Assay = :chemcode, :Slide Lot = :slide_lot )
	);
	Close(dtSLExp,nosave);
	///preparation for JSON stuff (move into own function??)
	jsonPrepBase(dtCalFinal,dtCaloutLast);
	//
	jsonPrepCW(cwSplit2);
	//
	jsonPrepFoil(foilMasterall);
	//
		
	buildJSONarray(dtCaloutlast, cwSplit2, foilMasterall, jsonloc, "Lytes");
		//JSON building won't close any of these tables - currently
	//return the necessary tables
	Return(dtCalfinal, dtSubop);
	
);

inputCleanup = Function( {dialogOutput},
	{default local}, 
	
	Match( dialogOutput["tb"],
		2,
			here:calibrationPathway = "LYTES";
			calibrationDataPath = dialogOutput["lytesCalDataPath"];
			loopQualDataPath = dialogOutput["lytesLoopFolder"];
			expirationDataPath = dialogOutput["lytesExpirationDataPath"];
			jsonFolderPath = dialogOutput["lytesJSONSaveFolder"];

			Return( calibrationDataPath, loopQualDataPath, expirationDataPath, jsonFolderPath );,
		3,
			here:calibrationPathway = "QSDMA";
			calibrationDataPath = dialogOutput["qsdmaCalDataPath"];
			loopQualDataPath = dialogOutput["qsdmaLoopFolder"];
			expirationDataPath = dialogOutput["qsdmaExpirationDataPath"]; //will be list for QSDMA
			jsonFolderPath = dialogOutput["qsdmaJSONSaveFolder"];
			platformFineTuneDataPath = dialogOutput["qsdmaPlatformFTDataPath"];
			speciesFineTuneDataPath = dialogOutput["qsdmaSpeciesFTDataPath"];
			slideLoopMatchDataPath = dialogOutput["qsdmaLoopMatchDataPath"];
			
			Return(
				calibrationDataPath,
				loopQualDataPath,
				expirationDataPath,
				jsonFolderPath,
				platformFineTuneDataPath,
				speciesFineTuneDataPath,
				slideLoopMatchDataPath
			);
	)
);

sdmaAssStitching = Function({dt_Panel, dt_Loop, dt_FineTune, dt_InstTune, dt_Expiration, jsonloc}, {default local},
	/*testing variables
	dt_Panel = calData;
	dt_Loop = loopData;
	dt_FineTune = patientData;
	dt_InstTune = platformData;
	dt_Expiration = expirationData;
	*/
	
	dt_Cal = dt_Panel;
	dt_Sublot = dt_Loop;
	
	//get the event number from the cal data table
	Caltablename = dt_Cal << get name;
	Eventnum = "Event" || Word(2, Caltablename, "_");
	
	//QSDMA specific fitting routine settings
	lamda = 100;
	calFoil = 15;
	defaultBin = 8;

	subLot2DblockerFunc( dt_Sublot, "Script AR", "Cross Web", "Foil", "Script Dose Val", "Slide Lot", "Blocked AR", "Chem Type", "Relative" );

	dtSubsum1 = dt_Sublot << Summary(
		Group( :Script Dose Val, :Slide Lot, :Cross Web, :Chem Type ),
		Mean( :Blocked AR ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 ),
		Invisible
	);
	
	dtSubsum2 = dtSubsum1 << Summary( 
		Group( :Slide Lot, :Chem Type ), 
		Freq( "None" ), 
		Weight( "None" ), 
		Link to original data table( 0 ),
		Invisible
	);
	
	splineFit = dtSubsum1 << Bivariate(
		Y( :Name( "Mean(Blocked AR)" ) ),
		X( :Cross Web ),
		By( :Slide Lot, :Chem Type ),
		Fit Spline( lamda, {Line Color( {212, 73, 88} )} ),
		Invisible
	);
	
	splineFit << (Curve[1] << Save Predicteds);
	
	//this requires a explicit column name that comes from saving the predicteds. if we change anything about the Bivariate, this will have to be changed as well.
	splineFormula = Column( dtSubsum1, "Spline Predictor for Mean(Blocked AR) By Slide Lot By Chem Type" ) << Get Formula;
	
	posCount = Max( Column( dtSubsum1, "Cross Web" ) << Get Values );
	
	dtTempcount = New Table( "Arbritrary Positions", New Column( "Cross Web", Numeric, Continuous, Set Values( 1 :: posCount :: 1 ) ), Invisible );
	
	dtTempcount << New Column( "Cross Web_Char",
		Character,
		Nominal,
		Set Formula( 
			If( :Cross Web < 10, "0" || Char( :Cross Web ), Char( :Cross Web ) ) 
		)
	);
	
	Column( dtTempcount, "Cross Web_Char" ) << Delete Formula;
	dtTempcount << New Column( "Predicted Mean AR", Numeric, Continuous );
	
	dtSubsum = dtSubsum2 << Join( With( dtTempcount ), Cartesian Join, Invisible );
	Column( dtSubsum, "Predicted Mean AR" ) << Set Formula( Name Expr( splineFormula ) );
	
	dtSubsum1 << Close Window;
	dtSubsum2 << Close Window;
	dtTempcount << Close Window;
	Wait( 1 );

	dt_Calparams = calFitfunc( dt_Cal, "Cross Web", "Script AR", "Script Dose Val", "Slide Lot", "Chem Type", "Inst Type", "3P", "Master" );
	
	dt_Calparams:"Slide Lot"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	
	dt_Cal << Update(
		With( dt_Calparams ),
		Match Columns( :Slide Lot = :Slide Lot, :Inst Type = :Inst Type, :Chem Type = :Chem Type ),
		Add Columns from Update Table( "Asymptote", "Scale", "Growth Rate" )
	);
	
	dt_Cal << New Column( "Master Curve", Numeric, Continuous, Set Formula( Log( (:Script AR - :Asymptote) / :Scale ) / :Growth Rate ) );
	dt_Cal << New Column( "Target Dose", Numeric, Continuous, Set Formula( Col Mean( :Master Curve, :Script Dose Val, :Inst Type, :Chem Type ) ) );
	
	dt_Calparams2 = calFitfunc(
		dt_Cal, "Cross Web", "Target Dose", "Master Curve", "Slide Lot", "Chem Type", "Inst Type", "Linear", "Normal"
	);
	
	dt_Calparams2:"Slide Lot"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	dt_Calparams2:"Cross Web"n << Set Data Type(Numeric) << Set Modeling Type("Continuous");
	
	dt_Calparams1 = dt_Calparams2 << Join(
		With( dtSubsum ),
		Merge Same Name Columns,
		Match Flag( 0 ),
		By Matching Columns( :Slide Lot = :Slide Lot, :Cross Web = :Cross Web, :Chem Type = :Chem Type ),
		Drop multiples( 0, 0 ),
		Include Nonmatches( 0, 0 ),
		Preserve main table order( 1 ),
		Invisible
	);

	dt_Calparams2 << close window;

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	paramFitting = dt_Calparams1 << Bivariate(
		Y( :Estimate ),
		X( :Predicted Mean AR ),
		Fit Line( {Line Color( {212, 73, 88} )} ),
		By( :Parameter, :Slide Lot, :Chem Type )
	);

	Wait( 0 );
	paramForms = Report( paramFitting[1] )[Outline Box( "Linear Fit" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] <<
	Make Combined Data Table;
	Report( paramFitting[1] ) << Close Window;

	paramsReady = paramForms << Split(
		Split By( :Term ),
		Split( :Estimate ),
		Group( :Slide Lot, :Parameter, :Chem Type ),
		Remaining Columns( Drop All ),
		Sort by Column Property,
		Invisible
	);

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	Column( paramsReady, "Predicted Mean AR" ) << Set Name( "Slope2" );
	Column( paramsReady, "Intercept" ) << Set Name( "Intercept2" );
	
	paramsReady:"Slide Lot"n << Set Data Type(Numeric) << Set Modeling Type("Nominal");
	
	paramCalcs = dtSubsum << Join(
		With( paramsReady ),
		Merge Same Name Columns,
		By Matching Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type ),
		Drop multiples( 0, 0 ),
		Include Nonmatches( 0, 0 ),
		Preserve main table order( 1 ),
		Invisible
	);

	paramCalcs << New Column( "Param Value", Numeric, Continuous, Set Formula( :Predicted Mean AR * :Slope2 + :Intercept2 ) );

	paramsFinal = paramCalcs << Split(
		Split By( :Parameter ),
		Split( :Param Value ),
		Group( :Slide Lot, :Cross Web, :Chem Type ),
		Remaining Columns( Drop All ),
		Sort by Column Property
	);
	
	Column( paramsFinal, "Slope" ) << Set Name( "Cross Web Gain" );
	Column( paramsFinal, "Intercept" ) << Set Name( "Cross Web Offset" );

	dt_Sublot_New = dt_Sublot << Join(
		With( paramsFinal ),
		Merge Same Name Columns,
		By Matching Columns( :Cross Web = :Cross Web, :Slide Lot = :Slide Lot, :Chem Type = :Chem Type ),
		Drop multiples( 0, 0 ),
		Include Nonmatches( 0, 0 ),
		Preserve main table order( 1 )
	);

	dt_Cal << Update(
		With( paramsFinal ),
		Match Columns( :Cross Web = :Cross Web, :Slide Lot = :Slide Lot, :Chem Type = :Chem Type ),
		Add Columns from Update Table( :Cross Web Gain, :Cross Web Offset )
	);
	
	dt_Sublot_New << Update(
		With( dt_Calparams ),
		Match Columns( :Slide Lot = :Slide Lot, :Inst Type = :Inst Type, :Chem Type = :Chem Type ),
		Add Columns from Update Table( :Asymptote, :Growth Rate, :Scale )
	);

	dt_Sublot_New << New Column( "Master Curve", Numeric, Continuous, Set Formula( Log( (:Script AR - :Asymptote) / :Scale ) / :Growth Rate ) );
	
	dt_Sublot_New << New Column( "Cross Web Corrected Dose",
		Numeric,
		Continuous,
		Set Formula( :Master Curve * :Cross Web Gain + :Cross Web Offset )
	);
	
	dt_Sublot_New << Set Name("Loop Qual Results with Calibration Parameters");
	
	dtSublot2mean = dt_Sublot_New << Summary(
		Group( :Script Dose Val, :Slide Lot, :Foil, :Chem Type ),
		Mean( :Cross Web Corrected Dose ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 ),
		Invisible
	);
	
	//algorithm to remove the panel closest to 30. one of the target levels is 30 and that's the one we don't want. thus it should be closer.
	value = 30;
	decider = Abs((dtSublot2mean:"Script Dose Val"n << get values) - value);
	row_where = Loc(decider == Min(decider));
	dtSublot2mean << delete rows(row_where);
	
	dtSublot2meantemp = dtSublot2mean << Select Where( :Foil == calFoil ) << Subset(
		Selected Rows( 1 ),
		Columns( "Slide Lot", "Script Dose Val", "Chem Type", "Mean(Cross Web Corrected Dose)" )
	);
	
	Column( dtSublot2meantemp, "Mean(Cross Web Corrected Dose)" ) << Set Name( "Target Dose" );
	
	dtSublot2mean << Update(
		With( dtSublot2meantemp ),
		Match Columns( :Slide Lot = :Slide Lot, :Script Dose Val = :Script Dose Val, :Chem Type = :Chem Type ),
		Add Columns from Update Table( :Target Dose )
	);

	dtSublot2meantemp << Close Window;
	
	dtSublot2mean << New Column( "Foil Correction Raw",
		Numeric,
		Continuous,
		Set Formula( :Target Dose - :Name( "Mean(Cross Web Corrected Dose)" ) )
	);
	
	splineFit2 = dtSublot2mean << Bivariate(
		Y( :Foil Correction Raw ),
		X( :Foil ),
		By( :Slide Lot, :Chem Type ),
		Fit Spline( lamda, {Line Color( {212, 73, 88} )} ),
		Invisible
	);
	
	splineFit2 << (Curve[1] << Save Predicteds);
	
	splineFormula2 = Column( dtSublot2mean, "Spline Predictor for Foil Correction Raw By Slide Lot By Chem Type" ) << Get Formula;
	Column( dtSublot2mean, "Spline Predictor for Foil Correction Raw By Slide Lot By Chem Type" ) << Set Name( "Foil Offset" );
	Column( dtSublot2mean, "Foil Correction Raw" ) << Delete Formula;
	Column( dtSublot2mean, "Foil Offset" ) << Delete Formula;
	dtSublot2mean << Delete Columns( "Script Dose Val"n, "Mean(Cross Web Corrected Dose)"n );
	dtSublot2mean << New Column( "Foil Gain", Numeric, Continuous, Set Formula( 1 ) );
	Wait( 0 );
	Column( dtSublot2mean, "Foil Gain" ) << Delete Formula;
	
	//add foil params to loop qual table and cal table
	dt_Sublot_New << Update(
		With( dtSublot2mean ),
		Match Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type, :Foil = :Foil ),
		Add Columns from Update Table( :Foil Offset, :Foil Gain )
	);
	
	dt_Cal << Update(
		With( dtSublot2mean ),
		Match Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type, :Foil = :Foil ),
		Add Columns from Update Table( :Foil Offset, :Foil Gain )
	);
	
	dt_Sublot_New << New Column( "Final Calc Dose", Numeric, Continuous, Set Formula( :Cross Web Corrected Dose + :Foil Offset ) );

	dt_Cal << New Column( "Final Calc Dose",
		Numeric,
		Continuous,
		Set Formula( :Master Curve * :Cross Web Gain + :Cross Web Offset + :Foil Offset )
	);

	dt_Foil = dtSublot2mean;
	dt_Crossweb = paramsFinal;
	dt_Basecurve = dt_Calparams;

	dt_Basecurve << Delete Columns( "Inst Type" );
	
	splineFit2 << Close Window;
	paramCalcs << Close Window;
	paramsReady << Close Window;
	paramForms << Close Window;
	dtSubsum << Close Window;
	dt_Calparams1 << Close Window;
	
	////////////////species fine tune math////////////////////////////////
	
	dt_FineTune << Update(
		With( dt_Basecurve ),
		Match Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type ),
		Add Columns from Update Table( :Asymptote, :Scale, :Growth Rate )
	);
	
	dt_FineTune << Update(
		With( dt_Crossweb ),
		Match Columns( :Cross Web = :Cross Web, :Slide Lot = :Slide Lot, :Chem Type = :Chem Type ),
		Add Columns from Update Table( :Cross Web Gain, :Cross Web Offset )
	);	
	
	dt_FineTune << Update(
		With( dt_Foil ),
		Match Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type, :Foil = :Foil ),
		Add Columns from Update Table( :Foil Offset, :Foil Gain )
	);
	
	dt_FineTune << New Column( "Master Curve", Numeric, Continuous, Set Formula( Log( (:Script AR - :Asymptote) / :Scale ) / :Growth Rate ) );
	
	dt_FineTune << New Column( "Cross Web Corrected Dose", Numeric, Continuous, Set Formula( :Master Curve * :Cross Web Gain + :Cross Web Offset ) );
	
	dt_FineTune << New Column( "Test Lot Calc Dose", Numeric, Continuous, Set Formula( :Cross Web Corrected Dose + :Foil Offset ) );
	
	///////////this area will need to be modified to get the control lots vs test lots and combining concentrations for analysis. This code is for PQ1 but will need to be modified. Test table also already has lot type built in. We can get this from the runsheet starting with PQ3.////////// Handling this in the prep step.
	
	dt_FineTune << New Column( "Final Calc Dose",
		Numeric,
		Continuous,
		Set Formula(
			if( dt_FineTune:"Lot Type"n == "Reference",
				dt_FineTune:"results.base_concentration"n,
				dt_FineTune:"Test Lot Calc Dose"n
			)
		)
	);
	dt_FineTune:"Final Calc Dose"n << Delete Formula;
	
	
	dt_FineTunesummary = dt_FineTune << Summary(
		Group( :Slide Lot, :Lot Type, :Patient Name, :Species Name, :Chem Type ),
		Mean( :Final Calc Dose ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 ),
		Invisible
	);

	dt_Finetunetemp = dt_FineTunesummary << Summary(
		Group(:Lot Type, :Patient Name, :Species Name, :Chem Type ),
		Mean( :"Mean(Final Calc Dose)"n ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 ),
		Invisible
	);

	dt_Finetunetemp << Select Where( :Lot Type == "Test" ) << Delete Rows;
	Column( dt_Finetunetemp, "Mean(Mean(Final Calc Dose))" ) << Set Name( "Target Dose" );
	dt_Finetunetemp << Delete Columns( "N Rows", "Lot Type" );
	
	dt_FineTunesummary << Update(
		With( dt_Finetunetemp ),
		Match Columns( :Chem Type = :Chem Type, :Patient Name = :Patient Name, :Species Name = :Species Name ),
		Add Columns from Update Table( :Target Dose )
	);
	
	dt_Finetunetemp << Close Window;
	
	dt_FineTunesummary << New Column( "Bias to Target", Numeric, Continuous, Set Formula( :Target Dose - :"Mean(Final Calc Dose)"n ) );
	
	dt_FineTuneout = dt_FineTunesummary << Summary(
		Group( :Lot Type, :Slide Lot, :Species Name, :Chem Type ),
		Mean( :Bias to Target ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 ),
		Invisible
	);
	
	Column( dt_FineTuneout, "Mean(Bias to Target)" ) << Set Name( "Species Adjustment" );
	dt_FineTunesummary << Close Window;
	dt_FineTuneout << Select Where( :Lot Type == "Reference" ) << Delete Rows;
	dt_FineTuneout << Delete Columns( "Lot Type" );
	//dt_FineTuneout << Set Name("Species Fine Tune");


	///////////////inst type fine tune math///////////////////////////////
	
	dt_InstTune << Update(
		With( dt_Basecurve ),
		Match Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type ),
		Add Columns from Update Table( :Asymptote, :Scale, :Growth Rate )
	);
	dt_InstTune << Update(
		With( dt_Crossweb ),
		Match Columns( :Cross Web = :Cross Web, :Slide Lot = :Slide Lot, :Chem Type = :Chem Type ),
		Add Columns from Update Table( :Cross Web Gain, :Cross Web Offset )
	);
	dt_InstTune << Update(
		With( dt_Foil ),
		Match Columns( :Slide Lot = :Slide Lot, :Chem Type = :Chem Type, :Foil = :Foil ),
		Add Columns from Update Table( :Foil Offset, :Foil Gain )
	);
	
	dt_InstTune << New Column( "Master Curve", Numeric, Continuous, Set Formula( Log( (:Script AR - :Asymptote) / :Scale ) / :Growth Rate ) );
		
	dt_InstTune << New Column( "Cross Web Corrected Dose", Numeric, Continuous, Set Formula( :Master Curve * :Cross Web Gain + :Cross Web Offset ) );
	
	dt_InstTune << New Column( "Final Calc Dose", Numeric, Continuous, Set Formula( :Cross Web Corrected Dose + :Foil Offset ) );
	
	dt_Insttunesummary = dt_InstTune << Summary(
		Group( :Chem Type, :Slide Lot, :Inst Type ),
		Mean( :Final Calc Dose ),
		Link to Original Data Table( 0 ),
		Invisible
	);
	
	dt_Insttemp = dt_Insttunesummary << Select Where( :Inst Type == "CatOne" ) << Subset( Selected Rows( 1 ), Selected Columns( 0 ), Invisible );
	
	dt_Insttemp << Delete Columns( "Inst Type", "N Rows" );
	Column( dt_Insttemp, "Mean(Final Calc Dose)" ) << Set Name( "Target Dose" );

	dt_Insttunesummary << Update(
		With( dt_Insttemp ),
		Match Columns( :Chem Type = :Chem Type, :Slide Lot = :Slide Lot ),
		Add Columns from Update Table( :Target Dose )
	);
	
	dt_Insttunesummary << New Column( "Platform Adjustment", Numeric, Continuous, Set Formula( :Target Dose - :Name( "Mean(Final Calc Dose)" ) ) );
	Column( dt_Insttunesummary, "Platform Adjustment" ) << Delete Formula;
	
	dt_Insttunesummary << Delete Columns( "Mean(Final Calc Dose)", "Target Dose", "N Rows" );
	//dt_Insttunesummary << Set Name("Platform Fine Tune");
	
	dt_Insttemp << Close Window;
	//dt_InstTune << Close Window;
	
	
	///////////making the tables to transform the CatOne base curve with the offsets to the final curve version///////////////////////
	dt_Dose = New Table( "Dose Temp", <<Add Rows( 101 ), New Column( "Dose", Numeric, Continuous, Set Values( 0 :: 100 :: 1 ) ), Invisible );
	dt_Species = New Table( "Species Temp",
		<<Add Rows( 2 ),
		New Column( "Species", Character, Nominal, Set Formula( If( Row() == 1, "Canine", "Feline" ) ) ),
		Invisible
	);
	dt_Platform = New Table( "Inst Temp",
		<<Add Rows( 2 ),
		New Column( "Inst Type", Character, Nominal, Set Formula( If( Row() == 1, "CatOne", "CatDx" ) ) ),
		Invisible
	); 
	
	dt_Temp = dt_Basecurve << Join( With( dt_Dose ), Cartesian Join, Invisible );
	wait(0.1);
	dt_Temp2 = dt_Temp << Join( With( dt_Species ), Cartesian Join, Invisible );
	wait(0.1);
	dt_Curvemaker = dt_Temp2 << Join( With( dt_Platform ), Cartesian Join, Invisible );
	wait(0.1);
	
	///merge in dx and one adjustment
	dt_Curvemaker << Update(
		With( dt_Insttunesummary ),
		Match Columns( :Chem Type = :Chem Type, :Slide Lot = :Slide Lot, :Inst Type = :Inst Type ),
		Add Columns from Update Table( :Platform Adjustment )
	);
	
	///merge in species adjustment(s)
	dt_Curvemaker << Update(
		With( dt_FineTuneout ),
		Match Columns( :Chem Type = :Chem Type, :Slide Lot = :Slide Lot, :Species = :Species Name),
		Add Columns from Update Table( :Species Adjustment )
	);
	
	//add ref dose column that accounts for offsets
	dt_Curvemaker << New Column( "Updated Ref Dose", Numeric, Continuous, Set Formula( :Dose + :Platform Adjustment + :Species Adjustment ) );
	dt_Curvemaker << New Column( "AR", Numeric, Continuous, Set Formula( :Asymptote + :Scale * Exp( :Growth Rate * :Dose ) ) );
	
	dtFitnew = dt_Curvemaker << Fit Curve(
		Y( :AR ),
		X( :Updated Ref Dose ),
		By( :Slide Lot, :Chem Type, :Inst Type, :Species ),
		Fit Exponential 3P,
		Invisible
	);
	
	Wait( 0 );
	dt_Basecurvetemp = Report( dtFitnew[1] )[Outline Box( "Exponential 3P" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table;
	dtFitnew << Close Window;
	
	dt_Basecurvefinal = dt_Basecurvetemp << Split(
		Split Columns( :Estimate ),
		Split By( :Parameter ),
		Group( :Slide Lot, :Chem Type, :Inst Type, :Species ),
		Remaining Columns( Drop All )
	);
	
	dt_Basecurvetemp << Close Window;
	dt_Curvemaker << Close Window;
	dt_Dose << Close Window;
	dt_Species << Close Window;
	dt_Platform << Close Window;
	dt_Temp << Close Window;
	dt_Temp2 << Close Window;
	//dt_FineTuneout << Close Window;
	dt_FineTuneout << Set Name(Eventnum || " Patient Offset");
	dt_FineTuneout << Show Window(1);
	//dt_Insttunesummary << Close Window;
	dt_Insttunesummary << Set Name(Eventnum || " Platform Offset");
	dt_Insttunesummary << Show Window(1);
	dt_Basecurve << Close Window;
	dt_Basecurvefinal << Set Name("Base Curve");
	
	BaseFinal = SDMAjsonPrepBase(dt_Basecurvefinal, dt_expiration, Eventnum);
	FoilFinal = SDMAjsonPrepFoil(dt_Foil);
	CWFinal = SDMAjsonPrepCW(dt_Crossweb);
	
	close(dt_expiration, nosave);
	close(dt_Sublot, nosave);
	close(dtSublot2mean, nosave);
	
	//currently does not close the base/foil/cw tables.
	buildJSONarray(BaseFinal, CWFinal, FoilFinal, jsonloc, "SDMA4");
	
	//Return the analysis tables.
	Return(dt_Cal, dt_Sublot, dt_FineTune, dt_InstTune);
	
);

SDMAjsonPrepBase = Function({dt_Basecurvefinal, dt_expiration, eventnum}, {default local},
	//dt_Basecurvefinal = DataTable("Base Curve");
	//dt_expiration = DataTable("Untitled 479");
	
	Column( dt_Basecurvefinal, "Asymptote" ) << Set Name( "a" );
	Column( dt_Basecurvefinal, "Scale" ) << Set Name( "b" );
	Column( dt_Basecurvefinal, "Growth Rate" ) << Set Name( "c" );
	dt_Basecurvefinal << New Column( "d", Numeric, Continuous, << set each value(0) );
	dt_Basecurvefinal << New Column( "e", Numeric, Continuous );
	dt_Basecurvefinal << New Column( "numWavelengths", Numeric, Nominal, Set Formula( 1 ) );
	dt_Basecurvefinal << New Column( "species",
		Numeric,
		Nominal,
		Set Formula( If( :Species == "Canine", 99, :Species == "Feline", 2, Empty() ) )
	);
	//dt_Basecurvefinal << New Column( "hidden", Numeric, Nominal, Set Formula( 0 ) );
	dt_Basecurvefinal << New Column( "chemCode", Numeric, Nominal, Set Formula( If( :Chem Type == "SDMA", 4, Emtpy() ) ) );	
	dt_Basecurvefinal << New Column( "dryread_start", Numeric, Continuous );
	dt_Basecurvefinal << New Column( "dryread_end", Numeric, Continuous );
	
	//get the min and max lot numbers for table naming
	Summarize(dt_Basecurvefinal, lot_list = by(:"Slide Lot"n));
	//using for each which is JMP 16 only
	For Each( {value, index}, lot_list, lot_list[index] = num(value) );
	Min_lot = Char(Min(lot_list));
	Max_lot = Char(Max(lot_list));
	
	
	Column( dt_Basecurvefinal, "Slide Lot" ) << Set Name( "lot" );
	dt_expiration:"slide_lot"n << Set Data Type("Character") << Set Modeling Type("Nominal");
	dt_Basecurvefinal << Update(
		With(dt_expiration),
		Match Columns( :lot = :slide_lot),
		Add Columns from Update Table( :exp_date ),
		Replace Columns in Maine Table( None )
	);
	dt_Basecurvefinal << New Column( "ID",
		Character,
		Nominal,
		Set Formula(
			If(
				:Inst Type == "CatOne", "cat1",
				:Inst Type == "CatDx", "ctdx",
				Empty()
			) || "_" || Char( :chemCode ) || "_" || Char( :lot ) || "_" || Char( :species )
		)
	);
	
	Column( dt_Basecurvefinal, "lot") << Set Data Type("Numeric") << Set Modeling Type("Nominal");
	Column( dt_Basecurvefinal, "ID" ) << Delete Formula;
	Column( dt_Basecurvefinal, "numWavelengths" ) << Delete Formula;
	Column( dt_Basecurvefinal, "species" ) << Delete Formula;
	//Column( dt_Basecurvefinal, "hidden" ) << Delete Formula;
	Column( dt_Basecurvefinal, "chemCode" ) << Delete Formula;
	dt_Basecurvefinal << Delete Columns( "Inst Type", "Species Name", "Chem Type", "Species" );
	dt_Basecurvefinal << Move Selected Columns("ID"n, To first );
	
	//will need to make event more dynamic. idk if this is relevant to QSDMA or not... *insert shrug here*
	dt_BaseCurvefinal << Set Name(eventnum || " BaseCurve " || Min_lot || "-" || Max_lot );
	
	return(dt_Basecurvefinal);
);

SDMAjsonPrepFoil = Function({dt_Foil}, {Default Local},
		//////transform the foil corrections to the low bit number type
	dt_Foil << New Column( "b", Numeric, Continuous, Set Formula( Round( :Foil Offset * 10000, 0 ) / 10000 ) );
	dt_Foil << New Column( "a", Numeric, Continuous, Set Formula( Round( :Foil Gain * 10000, 0 ) / 10000 ) );

	Column( dt_Foil, "a" ) << Delete Formula;
	Column( dt_Foil, "b" ) << Delete Formula;
	
	dt_Foil << Delete Columns( "Foil Offset", "Foil Gain" );
	
	//dt_Foil << Set Name( "Foil" );
	dt_Platform = New Table( "Inst Temp",
		<<Add Rows( 2 ),
		New Column( "Inst Type", Character, Nominal, Set Formula( If( Row() == 1, "CatOne", "CatDx" ) ) ),
		Invisible
	);
	wait(0.1);
	dtFoil = dt_Foil << Join( With( dt_Platform ), Cartesian Join );
	
	dtFoil << New Column( "ID",
		Character,
		Nominal,
		Set Formula(
			If(
				:Inst Type == "CatOne", "cat1",
				:Inst Type == "CatDx", "ctdx",
				Empty()
			) || "_" || If( :Chem Type == "SDMA",
				"4",
				Empty()
			) || "_" || Char( :Slide Lot )
		)
	);
	Column( dtFoil, "ID" ) << Delete Formula;
	
	dtFoil << Delete Columns( "Slide Lot", "Chem Type", "Inst Type", "N Rows", "Target Dose", "Foil Correction Raw" );
	dtFoil << Move Selected Columns("ID"n, To first );
	Column( dtFoil, "Foil" ) << Set Name( "foil" );
	dtFoil << Set Name("Foil");
	close(dt_Platform, nosave);
	
	Return(dtFoil);
);

SDMAjsonPrepCW = Function({dt_Crossweb}, {Default Local},


	dt_Crossweb << New Column( "Cross Web Start", Numeric, Continuous, Set Formula( (Ceiling( :Cross Web / defaultBin ) - 1) * defaultBin + 1 ) );
	dt_Crossweb << New Column( "Cross Web End", Numeric, Continuous, Set Formula( :Cross Web Start + defaultBin - 1 ) );

	Column( dt_Crossweb, "Cross Web Start" ) << Delete Formula;
	Column( dt_Crossweb, "Cross Web End" ) << Delete Formula;

	dtFit = dt_Crossweb << Bivariate(
		Y( :Cross Web Offset, :Cross Web Gain ),
		X( :Cross Web ),
		By( :Chem Type, :Slide Lot, :Cross Web Start, :Cross Web End ),
		Fit Special( Degree( 3 ), Centered Polynomial( 0 ), {Line Color( {61, 174, 70} )} )
	);
	Wait( 0 );
	cwInterptemp = Report( dtFit[1] )[Outline Box( "Polynomial Fit Degree=3 Uncentered" )][Outline Box( "Parameter Estimates" )][Table Box( 1 )] << Make Combined Data Table;
	dtFit << Close Window;

	dt_Crossweb << Close Window;

	cwSplit1 = cwInterptemp << Split(
		Split By( :Term ),
		Split( :Estimate ),
		Group( :Slide Lot, :Chem Type, :Cross Web End, :Cross Web Start, :Y ),
		Remaining Columns( Drop All ),
		Sort by Column Property,
		Invisible
	);

	cwInterptemp << Close Window;

	cwSplit2 = cwSplit1 << Split(
		Split By( :Y ),
		Split( :Cross Web, :"Cross Web^2"n, :"Cross Web^3"n, :Intercept ),
		Group( :Slide Lot, :Chem Type, :Cross Web End, :Cross Web Start ),
		Sort by Column Property,
		Invisible
	);

	cwSplit1 << Close Window;
	
	Column( cwSplit2, "Intercept Cross Web Offset" ) << Set Name( "e" );
	Column( cwSplit2, "Cross Web Cross Web Offset" ) << Set Name( "f" );
	Column( cwSplit2, "Cross Web^2 Cross Web Offset" ) << Set Name( "g" );
	Column( cwSplit2, "Cross Web^3 Cross Web Offset" ) << Set Name( "h" );
	Column( cwSplit2, "Intercept Cross Web Gain" ) << Set Name( "a" );
	Column( cwSplit2, "Cross Web Cross Web Gain" ) << Set Name( "b" );
	Column( cwSplit2, "Cross Web^2 Cross Web Gain" ) << Set Name( "c" );
	Column( cwSplit2, "Cross Web^3 Cross Web Gain" ) << Set Name( "d" );
	
	
	cwSplit2 << Set Name( "Cross Web" );
	Column( cwSplit2, "Cross Web End" ) << Set Name( "crossweb_end" );
	Column( cwSplit2, "Cross Web Start" ) << Set Name( "crossweb_start" );
	cwSplit2:"crossweb_end"n << Set Data Type("Numeric") << Set Modeling Type("Nominal");
	cwSplit2:"crossweb_start"n << Set Data Type("Numeric") << Set Modeling Type("Nominal");
	
	dt_Platform = New Table( "Inst Temp",
		<<Add Rows( 2 ),
		New Column( "Inst Type", Character, Nominal, Set Formula( If( Row() == 1, "CatOne", "CatDx" ) ) ),
		Invisible
	);
	wait(0.1);
	
	cwSplit3 = cwSplit2 << Join( With( dt_Platform ), Cartesian Join );
	cwSplit3 << New Column( "ID",
		Character,
		Nominal,
		Set Formula(
			If(
				:Inst Type == "CatOne", "cat1",
				:Inst Type == "CatDx", "ctdx",
				Empty()
			) || "_" || If( :Chem Type == "SDMA",
				"4",
				Empty()
			) || "_" || Char( :Slide Lot )
		)
	);
	Column( cwSplit3, "ID" ) << Delete Formula;
	
	
	dt_Platform << Close Window;
	cwSplit2 << Close Window;
	
	cwSplit3 << Delete Columns( "Slide Lot", "Chem Type", "Inst Type");
	cwSplit3 << Move Selected Columns("ID"n, To first );
	cwSplit3 << Set Name("Cross Web");
	
	dt_Crossweb = cwSplit3;
	Return(dt_Crossweb);
);

jsonPrepBase = Function({finalCalibrationData,baseCoeffs},{default local},
	
	finalCal = finalCalibrationData;
	//expTbl = expirationTable;
	
	//--dtCaloutLast
	dtCalFinalSumm = finalCal << Summary(
		Group( :Assay, :Slide Lot, :cliplot, :Dry Read Start, :Dry Read End, :exp_date ),
		Freq( "None" ),
		Weight( "None" )
	);
	dtCalFinalSumm << delete columns("N Rows");
	baseCoeffs << Update(
		With( dtCalFinalSumm ),
		Match Columns( :Assay = :Assay, :Slide Lot = :Slide Lot )
	);
	//baseCoeffs << Update(
	//	With( expTbl ),
	//	Match Columns( :Assay = :chemcode, :Slide Lot = :slide_lot )
	//);
	Close(dtCalFinalSumm,nosave);
	//Close(dtSLExp,nosave);
	
	instIDpreparation(baseCoeffs);

	baseCoeffs << New Column("species",Numeric,
		<< set each value(99)
	);
	baseCoeffs << New Column("numWavelengths",Numeric,
		<< set each value(1)
	);
	baseCoeffs:"Assay"n << set name("chemCode");
	temp = baseCoeffs << New Column("ID",Character,
		Formula(
			:Inst Type || "_" || Char( :chemCode ) || "_" || Char( :Slide Lot ) || "_" || Char( :species )
		)
	);
	
	temp << delete formula;
	baseCoeffs:"Slide Lot"n << set name("lot");
	baseCoeffs:"Dry Read Start"n << set name("dryread_start");
	baseCoeffs:"Dry Read End"n << set name("dryread_end");
	baseCoeffs << Move Selected Columns({"ID"}, To First);
	/*
	If d parameter is present, makes sure they are all 0 if not filled with another
	number. If d is missing, add it and set it to 0
	*/
	Try(
		For each row(baseCoeffs,
			if(ismissing(:"d"n),:"d"n = 0)
		);
		,
		baseCoeffs << new column("d",numeric, continuous,
			<< set each value(0)
		);
	);
	baseCoeffs << delete columns({"Inst Type"});
	
);

jsonPrepCW = Function({crossWebTable},{default local},
	
	//--cwSplit2
	crossWebTable << New Column("Inst Type",Character,
		<< set each value("both")
	);
	temp = crossWebTable << New Column("chemcode",Numeric,
		Formula(
			Match( :Chem Type, "CL", 40, "K", 41, "NA", 42 )
		)
	);
	temp << delete formula;
	temp = crossWebTable << New Column("ID",Character,
		Formula(
			:Inst Type || "_" || Char( :chemcode ) || "_" || Char( :Slide Lot )
		)
	);
	temp << delete formula;
	crossWebTable:"Cross Web Start"n << set name("crossweb_start");
	crossWebTable:"Cross Web End"n << set name("crossweb_end");
	crossWebTable << Move Selected Columns({"ID"}, To First);
	crossWebTable << delete columns({"Inst Type","Chem Type","Slide Lot","species","chemcode"});
	
);

jsonPrepFoil = Function({foilTable},{default local},
	
	//--foilMasterAll
	foilTable << New Column("Inst Type",Character,
		<< set each value("both")
	);
	temp = foilTable << New Column("chemcode",Numeric,
		Formula(
			Match( :Chem Type, "CL", 40, "K", 41, "NA", 42 )
		)
	);
	temp << delete formula;
	temp = foilTable << New Column("ID",Character,
		Formula(
			:Inst Type || "_" || Char( :chemcode ) || "_" || Char( :Slide Lot )
		)
	);
	temp << delete formula;
	foilTable:"Foil"n << set name("foil");
	foilTable << Move Selected Columns({"ID"}, To First);
	foilTable << delete columns({"Inst Type","Chem Type","Sublot Position_Char","Slide Lot","species","chemcode"});
	
);

//UNUSED FUNCTIONS
//Nates mods of Jesse's mods of Tim's outlier function
// example: outlierDetectWithinGroup(dt,"AR","Assay","Lot","Instrument Type");
outlierDetectWithinGroup = Function({DTinitial,responseColumn,assayCodeColumn,slideLotColumn,instrumentTypeColumn,doseColumn},{default local},

	/* testing variables
	DTinitial = current data table();
	responseColumn = "AR";
	assayCodeColumn = "Assay";
	slideLotColumn = "Slide Lot";
	instrumentTypeColumn = "Instrument Type";
	doseColumn = "Dose";
	*/
	
	//variable shortening
	respCol = responseColumn;
	assayCol = assayCodeColumn;
	lotCol = slideLotColumn;
	instCol = instrumentTypeColumn;
	doseCol = doseColumn;
	
	//convert text cols names into jsl local column variables
	//JMP 16 may have fixed issues that require needing both styles
	nameRespCol = EvalInsert(":\!"^respCol^\!"n");
	nameLotCol = EvalInsert(":\!"^lotCol^\!"n");
	nameAssayCol = EvalInsert(":\!"^assayCol^\!"n");
	nameInstCol = EvalInsert(":\!"^instCol^\!"n");
	nameDoseCol = EvalInsert(":\!"^doseCol^\!"n");
	
	parseRespCol = Parse(EvalInsert(":\!"^respCol^\!"n"));
	parseLotCol = Parse(EvalInsert(":\!"^lotCol^\!"n"));
	parseAssayCol = Parse(EvalInsert(":\!"^assayCol^\!"n"));
	parseInstCol = Parse(EvalInsert(":\!"^instCol^\!"n"));
	parseDoseCol = Parse(EvalInsert(":\!"^doseCol^\!"n"));
	
	//**********Sort Table**********
	DTinitial << Clear Column Selection();
	temp = DTinitial << New Column("Calibration Group",character,formula( char(parseAssayCol) || char(parseLotCol) || parseInstCol));
	temp1 = DTinitial << New Column("Calibration Within Group",character,formula(:"Calibration Group"n || char(parseDoseCol)));
	DTinitial << sort( replace table, By( :"Calibration Within Group"n, :"DateTime"n), Order(Ascending, Ascending));

	//**********Run Order Column**********
	temp2 = DTinitial << New Column( "GroupRunOrder",
		Numeric,
		"Continuous",
		Format( "Best", 12 ),
		Formula(
			If( Row() == 1 | :"Calibration Within Group"n != Lag( :"Calibration Within Group"n, 1 ),
				1,
				Lag( :"GroupRunOrder"n, 1 ) + 1
			)
		)
	);
	
		
	//**********Result List Column**********
	temp3 = DTinitial << New Column( "BuildGroupList",
		Expression,
		"None",
		Formula( If( :"GroupRunOrder"n == 1, Eval List( {parseRespCol} ), Sort List( Insert( Eval List( Lag( :"BuildGroupList"n, 1 ) ), Eval List( {parseRespCol} ) ) ) ) )
	);

	//**********Mean for Threshold Calc Column**********
	temp4 = DTinitial << New Column( "Threshold Median AR",
		Numeric,
		"Continuous",
		Format( "Best", 12 ),
		Formula( Median( :"BuildGroupList"n ) )
	);
			
	//**********AR Threshold Column**********
	//prediction model version
	//RepCount = 3;
	temp5 = DTinitial << New Column("RepCount",numeric,continuous,set each value(3));
	temp6 = DTinitial << New Column( "ARthreshold",
		Numeric,
		"Continuous",
		Format( "Best", 12 ),
		Formula(
			arThresholdCoeffs[parseAssayCol]["a"] + arThresholdCoeffs[parseAssayCol]["b"] * :"RepCount"n + arThresholdCoeffs[parseAssayCol]["c"] * :"Threshold Median AR"n + :"RepCount"n * :"Threshold Median AR"n * arThresholdCoeffs[parseAssayCol]["d"]
		)
	);

	//**********Results Without Outliers Column**********
	temp7 = DTinitial << New Column( "RecurseResultList",
		Expression,
		"None",
		Formula(
			If( :"GroupRunOrder"n > Lag( :"GroupRunOrder"n, -1 ) | Is Missing( Lag( :"GroupRunOrder"n, -1 ) ),
				outlierRecursion( :"BuildGroupList"n, :"ARthreshold"n )
			)
		)
	);

	//**********Result list Applied to All Rows**********
	temp8 = DTinitial << New Column( "FinalResultList",
		Expression,
		"None",
		Formula(
			Index = -1;
			While( :"GroupRunOrder"n < Lag( :"GroupRunOrder"n, Index ), Index-- );
			Eval List( Lag( :"RecurseResultList"n, Index + 1 ) );
		)
	);
		
	//**********Include / Exclude**********	
	temp9 = DTinitial << New Column( "Outlier Status",
		Character,
		"Nominal",
		Formula( If( Contains( :"FinalResultList"n, "Fail" ), "Failed Level", Contains( :"FinalResultList"n, :AR ), "Include", "Exclude" ) )
	);
	temp10 = DTinitial << New Column( "Outlier 1/0", numeric,nominal,formula(Match(:"Outlier Status"n,"Include",0,"Exclude",1,"Failed Level",1)));

	temp11 = DTinitial << New Column("N Outliers (within group)",Numeric,Continuous,
		Formula(
			Col Sum( :"Outlier 1/0"n, :"Calibration Within Group"n )
		)
	);
	temp12 = DTinitial << New Column( "N Outliers (lot)",Numeric,Continuous,
		Formula(
			Col Sum( :"Outlier 1/0"n, :"Calibration Group"n ) 
		)
	);
	
	Try(temp << delete formula);
	Try(temp1 << delete formula);
	Try(temp2 << delete formula);
	Try(temp3 << delete formula);
	Try(temp4 << delete formula);
	Try(temp5 << delete formula);
	Try(temp6 << delete formula);
	Try(temp7 << delete formula);
	Try(temp8 << delete formula);
	Try(temp9 << delete formula);
	Try(temp10 << delete formula);
	Try(temp11 << delete formula);
	Try(temp12 << delete formula);
	
	DTinitial << delete columns(
		temp,
		temp1,
		temp2,
		temp3,
		temp4,
		temp5,
		temp6,
		temp7,
		temp8,
		temp9
	);
	
	DTinitial << selectwhere( :"Outlier 1/0"n == 1) << exclude(1);
	DTinitial << select all rows;
	DTinitial << invert row selection;
	
	return(DTinitial);
	
);

//nate brought in, from Tim's function probably won't be tested specifically.
//outlierRecursion will not be used.
outlierRecursion = Function( {resultlist, threshold, outlierLimitCount},
	{default local},
	//**********recursive function to create the final result list*********

	TempMedian = Median( resultlist );
	TempMean = Mean( resultlist );
	TempN = Length( resultlist );
	If( TempN < outlierLimitCount,
		Return( {"Fail"} ),
		If( Abs( TempMedian - TempMean ) > threshold,
			If( TempMedian - TempMean < 0,
				resultlist = Remove( resultlist, TempN, 1 ),
				resultlist = Remove( resultlist, 1, 1 )
			);
			resultlist = outlierRecursion( resultlist, threshold );
		,
			Return( resultlist )
		);
		Return( resultlist );
	);
);


////////////////////////////////////////
//                                    //
//              Main                  //
//                                    //
////////////////////////////////////////

If( Length( Include File List() ) == 1, 
	//batchUpdateChk(updateIDs);
	trackUsage( u, addinID );

	If( checkVersion( minJMPver ) == 1, 
			
		opInputs = ionChemCalDialog();
		If( opInputs == 0,
			Stop()
			,
			datatables = inputCleanup( opInputs );
			Match( calibrationPathway,
				"LYTES", 
				//create path vars from datatables Var to pass into stitch so it's more clear??
					calDataPath = datatables[1];
					loopDataPath = datatables[2];
					expirationPath = datatables[3];
					jsonPath = datatables[4];
				
				/*Preps the tables individually so functions can be updated with error checks, if need be*/
					calData = prepCalData( "LYTES", calDataPath );
					loopData = prepLoopData( "LYTES", loopDataPath, calData );
					expiration = prepExpiration( "LYTES", expirationPath );

					If( calData == 0 | loopData == 0 | expiration == 0,
						Close All( data tables, nosave );
						Stop();
					,
						lytesAssStitching( calData, loopData, expiration, jsonPath )
					);
				,
				"QSDMA",
					//creating variables to pass into stitch for more clarity.
					calDataPath = datatables[1];
					loopDataPath = datatables[2];
					expirationPath = datatables[3];
					jsonPath = datatables[4];
					platformDataPath = datatables[5];
					patientDataPath = datatables[6];
					loopslideDataPath = datatables[7];
					//show(loopslideDataPath);
					//prepping the data tables individually to bring together.
					calData = SDMAPanelPrep(calDataPath);
					loopData = SDMALoopQualPrep(loopDataPath, calData, loopslideDataPath);
					platformData = SDMAInstPrep(platformDataPath);
					patientData = SDMAPatientPrep(patientDataPath);
					expirationData = prepExpiration( "SDMA", expirationPath );
					If( calData == 0 | loopData == 0 | platformData == 0 | patientData == 0,
						Close All( data tables, nosave );
						Stop();
					,
						sdmaAssStitching( calData, loopData, patientData, platformData, expirationData, jsonPath )
					);
			);
		);
	,
		wrongVer( minJMPver )
	);
	,
	Print( "Calibration script was included from another source" );

);