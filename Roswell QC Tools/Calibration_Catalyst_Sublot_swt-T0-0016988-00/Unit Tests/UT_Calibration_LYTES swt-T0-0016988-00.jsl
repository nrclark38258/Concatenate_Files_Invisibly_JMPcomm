//////OLOL Catalyst Sublot Calibration jslHamcrest Unit Tests//////
t1=today();
lytesCalUT = New Namespace("sublotCalUnitTest");

lytesCalUT:varFunct = Function({},
	lytesCalUT:saveFile = 0;
	lytesCalUT:savePath = "C:\Users\nclark\Desktop/";
	lytesCalUT:reportName = "00_swt-T0-0016988-00_v1.0x_UnitTestReport.txt";
	///////////////////////////////////////////////
	////////UPDATE YOUR VARIABLES NATE!////////////
	///////////////////////////////////////////////
	Match(
		Get Environment Variable("USERNAME"),
			"nclark",
			lytesCalUT:toolPath = "/D:\JSL Development\Official JMP Addin Working\Calibration_Catalyst_Sublot_swt-T0-0016988-00\addin Files/CatalystSublotCalibration.jsl";
			lytesCalUT:filePath = "/D:\JSL Development\Official JMP Addin Working\Calibration_Catalyst_Sublot_swt-T0-0016988-00\Unit Tests/Files/";
			,
			"sdarling",
			lytesCalUT:toolPath = "/C:/Users/sdarling/OneDrive - IDEXX/Sages JSL Working Folders/Roswell QC Tools/Calibration_Catalyst_Sublot_swt-T0-0016988-00/addin Files/CatalystSublotCalibration.jsl";
			lytesCalUT:filePath = "/C:/Users/sdarling/OneDrive - IDEXX/Sages JSL Working Folders/Roswell QC Tools/Calibration_Catalyst_Sublot_swt-T0-0016988-00/Unit Tests/Files/";
			
	);
	
);

//use in setup / teardown or UT Tests
lytesCalUT:saveTable = Function({tableName,savePath,filePrefix,fileSuffix,testingBOOL = 0,journalSave = 0},{default Local},
	If( testingBOOL == 1,
		If(journalSave == 0,
			baseName = tableName << get name;
			fileName = filePrefix || "_" || baseName || "_" || fileSuffix;
			tableName << SaveAs(savePath||fileName);
			tableName << Set Name(baseName);
			,
			baseName = tableName << get window title;
			Substituteinto(baseName,":","");
			fileName = filePrefix || "_" || baseName || "_" || fileSuffix;
			//show(savePath,fileName);
			tableName << Save Journal(savePath||fileName||".jrn")
		)
		,
		Return(0)
	);
	Return(1);
);

//High level note that how we test table compare varies between JMP 15 and 16
//Unit tests could be updated to test differently based on version being tested...
lytesCalUT:tableCompare = Function({actual, expected},{default local},
	result = actual << Compare Data Tables(
		Compare with( expected ),
		Compare Table Properties,
		Compare Column Attributes and Properties,
		Compare Data,
		Show Difference Summary,
		Show Difference Plot
	);
	
	r = result << report;
	Return(r,result)
);

lytesCalUT:unitTests = Function({},
	Match(lytesCalUT:saveFile,
		1, ut global reporter = New Object("ut collecting reporter")
	);
	wait(3);		
	/////////////////////////////////////////////////////////////
	//                                                         //
	//          TEST CASES                                     //
	//                                                         //
	/////////////////////////////////////////////////////////////

	varCheckTC = ut test case("A_Variable Checks")
		<<Setup(Expr(
			Include(lytesCalUT:toolPath);
		));

	quickFunctionsTC = ut test case("B_Easy Function Tests")
		<<Setup(Expr(
			Include(lytesCalUT:toolPath);
		));

	jsonObjTC = ut test case("C_Creating JSON Object")
		<<Setup(Expr(
			Include(lytesCalUT:toolPath);
			filePath = lytesCalUT:filePath;
			table1 = Open(lytesCalUT:filePath||"basicTest_MainCurves.jmp",invisible);
			table2 = Open(lytesCalUT:filePath||"basicTest_crosswebs.jmp",invisible);
			table3 = Open(lytesCalUT:filePath||"basicTest_foils.jmp",invisible);
			table4 = Open(lytesCalUT:filePath||"basicTest_MainCurves_addRemoveCols.jmp",invisible);
			table5 = Open(lytesCalUT:filePath||"basicTest_crosswebs_addRemoveCols.jmp",invisible);
			table6 = Open(lytesCalUT:filePath||"basicTest_foils_addRemoveCols.jmp",invisible);
		));

	calfitTC = ut test case("D_calFitfunc")
		<< setup(expr(
			include(lytesCalUT:toolPath);
			tablename = open(lytesCalUT:filePath||"calFitfunc_input_lytes_Master.jmp",invisible);
			sdma_table = open(lytesCalUT:filePath||"calFitfunc_input_SDMA_Panel_OneLot.jmp", invisible);
			sdma_table_multi_in = open(lytesCalUT:filePath||"calFitfunc_input_SDMA_Panel_MultiLot.jmp", invisible);
			sdma_linear_table = open(lytesCalUT:filePath||"calFitfunc_input_SDMA_Linear_Normal.jmp", invisible);
			sdma_linear_multi = open(lytesCalUT:filePath||"calFitfunc_input_SDMA_Linear_Normal_MultiLot.jmp", invisible);
		));

	sublotcharTC = ut test case("E_subLotcharFunc")
		<< setup(expr(
			include(lytesCalUT:toolPath);
			cwCorrsoffsetpred_input = open(lytesCalUT:filePath||"subLotcharFunc_cwCorrsoffsetpred_lytes_input.jmp",invisible);
			cwCorrsslopepred_input = open(lytesCalUT:filePath||"subLotcharFunc_cwCorrsslopepred_lytes_input.jmp",invisible);
			foilCorrsoffsetpred_input = open(lytesCalUT:filePath||"subLotcharFunc_foilCorrsoffsetpred_lytes_input.jmp",invisible);
			foilCorrsslopepred_input = open(lytesCalUT:filePath||"subLotcharFunc_foilCorrsslopepred_lytes_input.jmp",invisible);
		));

	barcodeparseTC = ut test case("F_calBarcodeParse")
		<< setup(expr(
			include(lytesCalUT:toolPath);
		));
	
	grubbsTC = ut test case("G_Grubbs_Outlier_Detection")
		<< setup(expr(
			include(lytesCalUT:toolPath);
			outliers = open(lytesCalUT:filePath||"Grubbs_Outliers.jmp", invisible);
			nooutliers = open(lytesCalUT:filePath||"Grubbs_Outliers_None.jmp", invisible);
		));

	subLottabprepTC = ut test case("H_subLottabprep_lytes only")
		<< setup(expr(
			include(lytesCalUT:toolPath);
			input_cal = open(lytesCalUT:filePath||"subLottabprep_lytes_dtCalout_input.jmp", invisible);
			input_lq = open(lytesCalUT:filePath||"subLottabprep_lytes_dtSub_input.jmp", invisible);
			expected_output = open(lytesCalUT:filePath||"subLottabprep_lytes_output.jmp", invisible);
		));
	
	prepLytesTC = ut test case("I_Prep_lytes")
		<< setup(expr(
			include(lytesCalUT:toolPath);
			input_cal_path = lytesCalUT:filePath||"prepCalData_Input.jmp";
			input_loop_path = lytesCalUT:filePath||"Lytes_Loop Qual_Input/";
			input_exp_path = lytesCalUT:filePath||"prepExpiration_lytes_input.xlsm";
			input_cal_data = open(lytesCalUT:filePath||"prepCalData_output.jmp", invisible);
			//expected outputs in the respective UT.
		));
	
	prepSDMATC = ut test case("J_Prep_SDMA")
		<< setup(expr(
			include(lytesCalUT:toolPath);
			input_cal_path = lytesCalUT:filePath||"SDMAPanelPrep_cal_input.jmp";
			input_loop_path = lytesCalUT:filePath||"SDMA_Loop Qual_Input/Loop Lots/";
			input_DXrelease =  lytesCalUT:filePath||"SDMALoopQualPrep_DXrelease_input.xlsm";
			input_exp_path = "{\!""||lytesCalUT:filePath||"prepExpiration_SDMA_1001_input.XLSX\!", \!""||lytesCalUT:filePath||"/prepExpiration_SDMA_1003_input.XLSX\!"}";
			input_patient_path = lytesCalUT:filePath||"SDMAPatientPrep_input.jmp";
			input_inst_path = lytesCalUT:filePath||"SDMAInstPrep_platform_input.jmp";
			//expected outputs in the respective UT.
	));


	/////////////////////////////////////////////////////////////
	//                                                         //
	//          UNIT TESTS                                     //
	//                                                         //
	/////////////////////////////////////////////////////////////

			/////////////////////////////////////////////////////////////
			//          Vars and supporting Functions                  //
			/////////////////////////////////////////////////////////////
	lytesCalUT:utGroup = "A";
	lytesCalUT:utGroupTest = 0;

	ut test(varCheckTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Starting Variables", 
		Expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			uName = Get Environment Variable("username");

			ut assert that(Expr(u), ut equal to(uName));
			ut assert that(Expr(addinID), ut equal to("com.idexx.RoswellQCTools_Sublot_calibration"));
			ut assert that(Expr(minJMPver), ut equal to("16.1"));

		));
	ut test(varCheckTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Starting assay Arrays", 
		Expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expectedMidPoint = Associative Array(
				{
					{"40", 115},
					{"41", 4.3},
					{"42", 153},
					{"CL", 115},
					{"K", 4.3},
					{"NA", 153}			
				}
			);
			// range lo, hi
			expectedRange = Associative Array(
				{
					{"40", {50, 160}},
					{"41", {0.8, 10}},
					{"42", {85, 180}},
					{"CL", {50, 160}},
					{"K", {0.8, 10}},
					{"NA", {85, 180}}		
				}
			);
			//cubic coeffs for corrected 3P
			expectedCorrectedCubic = Associative Array(
				{
					{"40", Associative Array(
							{
								{"int", 11.0422244319215},
								{"lin", 0.631429652798366},
								{"quad", 0.00384826612677856},
								{"cub", -0.0000126863381553078}		
							}
						)
					},
					{"41", Associative Array(
							{
								{"int", (0.491047025197684 + 0.01)},
								{"lin", 0.589025966029642},
								{"quad", 0.0928461121150412},
								{"cub", -0.00594812663885595}		
							}
						)
					},
					{"42", Associative Array(
							{
								{"int", 80.2669819780055},
								{"lin", -1.01470981530239},
								{"quad", 0.0162340428546581},
								{"cub", -0.0000421742221477125}	
							}
						)
					},
					{"CL", Associative Array(
							{
								{"int", 11.0422244319215},
								{"lin", 0.631429652798366},
								{"quad", 0.00384826612677856},
								{"cub", -0.0000126863381553078}		
							}
						)
					},
					{"K", Associative Array(
							{
								{"int", (0.491047025197684 + 0.01)},
								{"lin", 0.589025966029642},
								{"quad", 0.0928461121150412},
								{"cub", -0.00594812663885595}		
							}
						)
					},
					{"NA", Associative Array(
							{
								{"int", 80.2669819780055},
								{"lin", -1.01470981530239},
								{"quad", 0.0162340428546581},
								{"cub", -0.0000421742221477125}		
							}
						)
					}
				}
			);

			ut assert that(Expr(expectedMidPoint), ut equal to(assayMidPoint));
			ut assert that(Expr(expectedRange), ut equal to(assayRange));
			ut assert that(Expr(expectedCorrectedCubic), ut equal to(assayCorrectedCubic));
			
			currentKey = assayMidPoint << first;
			For(i=1,i<=nitems(assayMidPoint),i++,
				ut assert that(Expr(expectedMidPoint[currentKey]), ut equal to(assayMidPoint[currentKey]));
				currentKey = assayMidPoint << Next(currentKey);
			);
			currentKey = assayRange << first;
			For(i=1,i<=nitems(assayRange),i++,
				ut assert that(Expr(expectedRange[currentKey]), ut equal to(assayRange[currentKey]));
				currentKey = assayRange << Next(currentKey);
			);
			currentKey = assayCorrectedCubic << first;
			For(i=1,i<=nitems(assayCorrectedCubic),i++,
				ut assert that(Expr(expectedCorrectedCubic[currentKey]), ut equal to(assayCorrectedCubic[currentKey]));
				currentKey = assayCorrectedCubic << Next(currentKey);
			);

		));
	ut test(varCheckTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_assayTypes", 
		Expr(
			
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expected_assayTyp = Associative Array(
				{
					{"GLU",00},
					{"BUN",01},
					{"CA",03},
					{"URIC",05},
					{"TP",06},
					{"TRIG",07},
					{"CHOL",08},
					{"ALB",09},
					{"NH3",10},
					{"PHOS",12},
					{"TBIL",14},
					{"CREA",15},
					{"FRU",16},
					{"CRP",17},
					{"SDMA",18.04},
					{"BA",21},
					{"PROG",23},
					{"PHBR",25},
					{"TT4",28.30},
					{"MG",32},
					{"LAC",35},
					{"CL",40},
					{"K",41},
					{"NA",42},
					{"UPRO",54},
					{"ALTV",56},
					{"TCO2",57},
					{"LIPA",59},
					{"AMYL",60},
					{"ALT",62},
					{"LDH",63},
					{"CK",64},
					{"ALKP",65},
					{"GGT",67},
					{"UCRE",70},
					{"AST",73},
					{"WRS",90},
					{.,-999}
				}
			);
			
			actual_assayTyp = assayTypes();

			ut assert that(Expr(expected_assayTyp), ut equal to(actual_assayTyp));
			
			currentKey = actual_assayTyp << first;
			For(i=1,i<=nitems(actual_assayTyp),i++,
				ut assert that(Expr(expected_assayTyp[currentKey]), ut equal to(actual_assayTyp[currentKey]));
				currentKey = actual_assayTyp << Next(currentKey);
			);
		));



	lytesCalUT:utGroup = "B";
	lytesCalUT:utGroupTest = 0;

	ut test(quickFunctionsTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_JMP Version Check", 
		Expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			//function pulls the version being executed on
			ver = JMP Version();
			currWords = words(ver,".");
			backHalf = concatitems(currWords[2::nitems(currWords)],"");
			newNumVer = Num(currWords[1]||"."||backHalf);

			ut assert that(Expr(checkVersion(Char(newNumVer - 0.1))), ut equal to(1));
			ut assert that(Expr(checkVersion(Char(newNumVer - 1))), ut equal to(1));
			ut assert that(Expr(checkVersion(Char(newNumVer))), ut equal to(1));
			ut assert that(Expr(checkVersion(Char(newNumVer + 0.1))), ut equal to(0));
			ut assert that(Expr(checkVersion(Char(newNumVer + 1))), ut equal to(0));
		));

	ut test(quickFunctionsTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_JMP Version Fail Window",
		Expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
					
			closemodal = Function({timeout},
				s = Schedule(
					timeout,
					If(current window() << get window title == "Requires JMP 15.2",
						text = (current window() << xpath("//TextBox"));
						If( text[1] << get text == "This addin requires the used of JMP 15.2+",
							(current window() << xpath("//ButtonBox[text()='OK']")) << click;
							Print("Error Dialog Executed Correctly")
							,
							(current window() << xpath("//ButtonBox[text()='OK']")) << click;
							Print("Wrong text version, Error Dialog Executed")
						)
						,
						(current window() << xpath("//ButtonBox[text()='OK']")) << click;
						Print("Wrong title version, Error Dialog Executed")
					)
				)
			);
			//Failures for the above should be controled at the function level as these checks ensure function has the parameter used in both the title and the text box
			closemodal(2);
			wrongVer(15.2);
			log = GetLog(-1);
			ut assert that(Expr(log[1]), ut equal to("\!"Error Dialog Executed Correctly\!""));
			
			closemodal(2);
			wrongVer(17);
			log = GetLog(-1);
			ut assert that(Expr(log[1]), ut equal to("\!"Wrong title version, Error Dialog Executed\!""));
		));

	ut test(quickFunctionsTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Factor Finder",
		Expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			table1 = factorFinder(3);
			table2 = factorFinder(6);
			table3 = factorFinder(13);
			table4 = factorFinder(40.3);
			table5 = factorFinder(40);
			
			ut assert that(Expr(table1:"Factors"n << get as matrix), ut equal to([3]));
			ut assert that(Expr(table2:"Factors"n << get as matrix), ut equal to([2, 3, 6]));
			ut assert that(Expr(table3:"Factors"n << get as matrix), ut equal to([13]));
			ut assert that(Expr(table4:"Factors"n << get as matrix), ut equal to([40.3]));
			ut assert that(Expr(table5:"Factors"n << get as matrix), ut equal to([2, 4, 5, 8, 10, 20, 40]));
		)
	);

			/////////////////////////////////////////////////////////////
			//          Create JSON Object                             //
			/////////////////////////////////////////////////////////////
	lytesCalUT:utGroup = "C";
	lytesCalUT:utGroupTest = 0;

	ut test(jsonObjTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_full JSON Expr Match w/diff number of lots/foils",
		Expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expJSONexpr = include(filePath || "jsontestforOLOL_noChemType_jsonExpr.jsl");
			
			jsonExpr = buildJSONarray(table1,table2,table3);
			//show(jsonExpr);
			ut assert that(Expr(jsonExpr), ut equal to(expJSONexpr));
		)
	);
	ut test(jsonObjTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_full JSON Expr Match w/diff number of lots/foils",
		Expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expJSONexpr = include(filePath || "jsontestforOLOL_addRemoveCols_jsonExpr.jsl");
			
			jsonExpr = buildJSONarray(table4,table5,table6);
			//show(jsonExpr);
			ut assert that(Expr(jsonExpr), ut equal to(expJSONexpr));
		)
	);

			/////////////////////////////////////////////////////////////
			//          calFitFunc Function                            //
			/////////////////////////////////////////////////////////////
	lytesCalUT:utGroup = "D";
	lytesCalUT:utGroupTest = 0;

	ut test(calfitTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Lytes_3P_Master",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(tablename, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_Lytes_3P_Input.jmp", lytesCalUT:saveFile);
			
			expected_table = open(lytesCalUT:filePath||"calFitfunc_output_3P_lytes.jmp");
			lytesCalUT:saveTable(expected_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_lytes_3P_Expected.jmp", lytesCalUT:saveFile);
			
			actual_table = calFitfunc( tablename, "Cross Web", "AR", "Dose", "Slide Lot", "Chem Type", "Inst Type", "3P", "Master" );
			
			compare_tables = lytesCalUT:tableCompare(actual_table, expected_table);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"calFitfunc_lytes_actual.jmp", lytesCalUT:saveFile);
		
		)
	);

	ut test(calfitTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_SDMA_3P_Master_One Lot",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(sdma_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMA_3P_Input_OneLot.jmp", lytesCalUT:saveFile);
			
			expected_table = open(lytesCalUT:filePath||"calFitfunc_output_3P_SDMA_OneLot.jmp");
			lytesCalUT:saveTable(expected_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMA_3P_Expected.jmp", lytesCalUT:saveFile);
			actual_table = calFitfunc(sdma_table, "Cross Web", "Script AR", "Script Dose Val", "Slide Lot", "Chem Type", "Inst Type", "3P", "Master");

			compare_tables = lytesCalUT:tableCompare(actual_table, expected_table);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"calFitfunc_3P_SDMA_post.jmp", lytesCalUT:saveFile);
		
		)
	);

	ut test(calfitTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_SDMA_3P_Master_Multiple Lots",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(sdma_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMA_3P_Input_Multilot.jmp", lytesCalUT:saveFile);
			
			expected_table = open(lytesCalUT:filePath||"calFitfunc_output_3P_SDMA_MultiLot.jmp");
			
			lytesCalUT:saveTable(expected_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMA_3P_Expected.jmp", lytesCalUT:saveFile);
			
			actual_table = calFitfunc(sdma_table_multi_in, "Cross Web", "Script AR", "Script Dose Val", "Slide Lot", "Chem Type", "Inst Type", "3P", "Master");

			compare_tables = lytesCalUT:tableCompare(actual_table, expected_table);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"calFitfunc_3P_SDMA_post.jmp", lytesCalUT:saveFile);
		
		)
	);

	ut test(calfitTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_SDMA_Linear_Normal_One Lot",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(sdma_linear_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMA_Linear_Pre.jmp", lytesCalUT:saveFile);
			
			expected_table = open(lytesCalUT:filePath||"calFitfunc_output_Linear_Normal_SDMA.jmp");
			lytesCalUT:saveTable(expected_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMA_Linear_Expected.jmp", lytesCalUT:saveFile);

			actual_table = calFitfunc(sdma_linear_table, "Cross Web", "Target Dose", "Master Curve", "Slide Lot", "Chem Type", "Inst Type", "Linear", "Normal");

			compare_tables = lytesCalUT:tableCompare(actual_table, expected_table);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"calFitfunc_Linear_SDMA_post.jmp", lytesCalUT:saveFile);
		
		)
	);

	ut test(calfitTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_SDMA_Linear_Normal_Multiple Lots",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(sdma_linear_multi, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMA_Linear_Multilots_Pre.jmp", lytesCalUT:saveFile);
			
			expected_table = open(lytesCalUT:filePath||"calFitfunc_output_Linear_Normal_SDMA_multilots.jmp");
			lytesCalUT:saveTable(expected_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMA_Linear_Expected_MultiLots.jmp", lytesCalUT:saveFile);

			actual_table = calFitfunc(sdma_linear_multi, "Cross Web", "Target Dose", "Master Curve", "Slide Lot", "Chem Type", "Inst Type", "Linear", "Normal");

			compare_tables = lytesCalUT:tableCompare(actual_table, expected_table);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"calFitfunc_Linear_SDMA_MultiLots_post.jmp", lytesCalUT:saveFile);
		
		)
	);

			/////////////////////////////////////////////////////////////
			//              subLotcharFunc Function                    //
			/////////////////////////////////////////////////////////////
	lytesCalUT:utGroup = "E";
	lytesCalUT:utGroupTest = 0;

	ut test(sublotcharTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Lytes_cwCorrsoffsetpred",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(cwCorrsoffsetpred_input, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLotcharFunc_lytes_cwCorrsoffsetpred_input.jmp", lytesCalUT:saveFile);
			
			expected_table = open(lytesCalUT:filePath||"subLotcharFunc_cwCorrsoffsetpred_lytes_output.jmp");
			lytesCalUT:saveTable(expected_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLotcharFunc_lytes_cwCorrsoffsetpred_expected.jmp", lytesCalUT:saveFile);
			
			actual_table = subLotcharFunc( cwCorrsoffsetpred_input, "Cross Web", "Offset Calc_Cross Web", "Slide Lot", "Chem Type", 100, "Yes" );
			wait(0);
			
			compare_tables = lytesCalUT:tableCompare(actual_table, expected_table);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"subLotcharFunc_lytes_cwCorrsoffsetpred_actual.jmp", lytesCalUT:saveFile);
		
		)
	);

	ut test(sublotcharTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Lytes_cwCorrsslopepred",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(cwCorrsoffsetpred_input, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLotcharFunc_lytes_cwCorrsslopepred_input.jmp", lytesCalUT:saveFile);
			
			expected_table = open(lytesCalUT:filePath||"subLotcharFunc_cwCorrsslopepred_lytes_output.jmp");
			
			lytesCalUT:saveTable(expected_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLotcharFunc_lytes_cwCorrsslopepred_expected.jmp", lytesCalUT:saveFile);
			
			actual_table = subLotcharFunc( cwCorrsslopepred_input, "Cross Web", "Gain Calc_Cross Web", "Slide Lot", "Chem Type", 100, "Yes" );
			wait(0);
			
			compare_tables = lytesCalUT:tableCompare(actual_table, expected_table);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"subLotcharFunc_lytes_cwCorrsslopepred_actual.jmp", lytesCalUT:saveFile);
		
		)
	);

	ut test(sublotcharTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Lytes_foilCorrsoffsetpred",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(foilCorrsoffsetpred_input, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLotcharFunc_lytes_foilCorrsoffsetpred_input.jmp", lytesCalUT:saveFile);
			
			expected_table = open(lytesCalUT:filePath||"subLotcharFunc_foilCorrsoffsetpred_lytes_output.jmp");
			
			lytesCalUT:saveTable(expected_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLotcharFunc_lytes_foilCorrsoffsetpred_expected.jmp", lytesCalUT:saveFile);
			
			actual_table = subLotcharFunc( foilCorrsoffsetpred_input, "Foil", "Offset Calc_Foil", "Slide Lot", "Chem Type", 100, "Yes" );
			wait(0);
			
			compare_tables = lytesCalUT:tableCompare(actual_table, expected_table);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"subLotcharFunc_lytes_cwCorrsslopepred_actual.jmp", lytesCalUT:saveFile);
		
		)
	);

	ut test(sublotcharTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Lytes_foilCorrsslopepred",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(foilCorrsslopepred_input, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLotcharFunc_lytes_foilCorrsslopepred_input.jmp", lytesCalUT:saveFile);
			
			expected_table = open(lytesCalUT:filePath||"subLotcharFunc_foilCorrsslopepred_lytes_output.jmp");
			
			lytesCalUT:saveTable(expected_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLotcharFunc_lytes_foilCorrsslopepred_input_expected.jmp", lytesCalUT:saveFile);
			
			actual_table = subLotcharFunc( foilCorrsslopepred_input, "Foil", "Gain Calc_Foil", "Slide Lot", "Chem Type", 100, "Yes" );
			
			wait(0);
			
			compare_tables = lytesCalUT:tableCompare(actual_table, expected_table);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"subLotcharFunc_lytes_foilCorrsslopepred_actual.jmp", lytesCalUT:saveFile);
		
		)
	);

			/////////////////////////////////////////////////////////////
			//              calBarcodeParse Function                   //
			/////////////////////////////////////////////////////////////
	lytesCalUT:utGroup = "F";
	lytesCalUT:utGroupTest = 0;
	
	ut test(barcodeparseTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Barcode Cols Added",
		expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			parsing_table = New Table( "Barcode",
				Add Rows( 10 ),
				New Column( "Barcode",
					Numeric,
					Continuous,
					Set Selected,
					Set Values(
						{1001152204, 1001153904, 1001153804, 1001152104, 1001152040, 1000152040, 1000151941, 1001152141, 1002151942, 1001152042}
					)
				),
				Invisible
			);
			
			lytesCalUT:saveTable(parsing_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_calBarcodeParse_input.jmp", lytesCalUT:saveFile);
			
			parsed_table = calBarcodeParse(parsing_table, "Barcode");
			
			lytesCalUT:saveTable(parsed_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_calBarcodeParse_output.jmp", lytesCalUT:saveFile);
			
			col_list_parse = parsed_table << get column names(string);
			
			ut assert that(expr(col_list_parse), ut equal to ({"Barcode", "Slide Lot_BC", "Crossweb_BC", "Foil_BC", "Assay Code_BC"}));
		)
	);
	
	ut test(barcodeparseTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_One Set of Barcode Cols",
		expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			parsing_table = New Table( "Barcode",
				Add Rows( 10 ),
				New Column( "Barcode",
					Numeric,
					Continuous,
					Set Selected,
					Set Values(
						{1001152204, 1001153904, 1001153804, 1001152104, 1001152040, 1000152040, 1000151941, 1001152141, 1002151942, 1001152042}
					)
				),
				New Column("Slide Lot_BC", 
					Character, 
					Nominal, 
					formula(Substr( Char( :Barcode ), 1, 4 ))
				),
				New Column("Crossweb_BC", 
					Character, 
					Nominal, 
					formula(Substr( Char( :Barcode ), 7, 2 ))
				),
				New Column("Foil_BC", 
					Character, 
					Nominal, 
					formula(Substr( Char( :Barcode ), 5, 2 ))
				),
				New Column("Assay Code_BC", 
					Character, 
					Nominal, 
					formula(Substr( Char( :Barcode ), 9, 2 ))
				),
				Invisible
			);
			
			lytesCalUT:saveTable(parsing_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_calBarcodeParse_input.jmp", lytesCalUT:saveFile);
			
			parsed_table = calBarcodeParse(parsing_table, "Barcode");
			
			lytesCalUT:saveTable(parsed_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_calBarcodeParse_output.jmp", lytesCalUT:saveFile);
			
			col_list_parse = parsed_table << get column names(string);
			
			ut assert that(expr(col_list_parse), ut equal to ({"Barcode", "Slide Lot_BC", "Crossweb_BC", "Foil_BC", "Assay Code_BC"}));
		)
	);
	
	ut test(barcodeparseTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Barcode Values Correct",
		expr(
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			parsing_table = New Table( "Barcode",
				Add Rows( 10 ),
				New Column( "Barcode",
					Numeric,
					Continuous,
					Set Selected,
					Set Values(
						{1001152204, 1001153904, 1001153804, 1001152104, 1001152040, 1000152040, 1000151941, 1001152141, 1002151942, 1001152042}
					)
				),
				Invisible
			);
			
			lytesCalUT:saveTable(parsing_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_calBarcodeParse_input.jmp", lytesCalUT:saveFile);
			
			parsed_table = calBarcodeParse(parsing_table, "Barcode");
			
			lytesCalUT:saveTable(parsed_table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_calBarcodeParse_output.jmp", lytesCalUT:saveFile);
			
			//get the values for each column to compare in the assert
			barcode_list = parsed_table:"Barcode"n << get values;
			slidelot_list = parsed_table:"Slide Lot_BC"n << get values;
			crossweb_list = parsed_table:"Crossweb_BC"n << get values;
			foil_list = parsed_table:"Foil_BC"n << get values;
			assay_list = parsed_table:"Assay Code_BC"n << get values;
			
			ut assert that(expr(barcode_list), ut equal to ([1001152204, 1001153904, 1001153804, 1001152104, 1001152040, 1000152040, 1000151941, 1001152141, 1002151942, 1001152042]));
			ut assert that(expr(slidelot_list), ut equal to ({"1001", "1001", "1001", "1001", "1001", "1000", "1000", "1001", "1002", "1001"}));
			ut assert that(expr(crossweb_list), ut equal to ({"22", "39", "38", "21", "20", "20", "19", "21", "19", "20"}));
			ut assert that(expr(foil_list), ut equal to ({"15", "15", "15", "15", "15", "15", "15", "15", "15", "15"}));
			ut assert that(expr(assay_list), ut equal to ({"04", "04", "04", "04", "40", "40", "41", "41", "42", "42"}));
		)
	);
	
			/////////////////////////////////////////////////////////////
			//          Grubbs_Outlier_Detection Function              //
			/////////////////////////////////////////////////////////////
	lytesCalUT:utGroup = "G";
	lytesCalUT:utGroupTest = 0;	
	
	ut test(grubbsTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_Outliers", 
		expr(

			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(outliers, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_Grubbs_Outlier_Detection_input.jmp", lytesCalUT:saveFile);

			table = Grubbs_Outlier_Detection(outliers, "Value", 0.001);
			
			wait(3);
			
			lytesCalUT:saveTable(table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_Grubbs_Outlier_Detection_input.jmp", lytesCalUT:saveFile);
			
			row_grubbs = table << get rows where("Exclusion Rationale"n == "NDE - Grubb's");
			row_outliers = table << get rows where("Outlier"n == "Yes");
			number_grubbs = nitems(row_grubbs);
			number_outliers = nitems(row_outliers);
			
			ut assert that(expr(row_grubbs), ut equal to (row_outliers));
			ut assert that(expr(number_grubbs), ut equal to (number_outliers));
		)
	);
	
	ut test(grubbsTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_No Outliers", 
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(outliers, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_Grubbs_Outlier_Detection_input.jmp", lytesCalUT:saveFile);

			table = Grubbs_Outlier_Detection(nooutliers, "Value", 0.001);
			
			lytesCalUT:saveTable(table, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_Grubbs_Outlier_Detection_input.jmp", lytesCalUT:saveFile);
			
			row_grubbs = table << get rows where("Exclusion Rationale"n == "NDE - Grubb's");
			row_outliers = table << get rows where("Outlier"n == "Yes");
			number_grubbs = nitems(row_grubbs);
			number_outliers = nitems(row_outliers);
			
			ut assert that(expr(number_grubbs), ut equal to (number_outliers));

		)
	);

			/////////////////////////////////////////////////////////////
			//                 subLottabprep Function                  //
			/////////////////////////////////////////////////////////////
	lytesCalUT:utGroup = "H";
	lytesCalUT:utGroupTest = 0;	
	
	ut test(subLottabprepTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_dtSubop",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			lytesCalUT:saveTable(input_cal, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLottabprep_dtCalout_input.jmp", lytesCalUT:saveFile);
			lytesCalUT:saveTable(input_lq, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLottabprep_dtSub_input.jmp", lytesCalUT:saveFile);
			lytesCalUT:saveTable(expected_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLottabprep_expected.jmp", lytesCalUT:saveFile);
			
			//setting the variables for calCWlow, calCWhigh, and calFoil. Variables based on flow with the datasets input but could be different for other data tables.
			calCWlow = 6;
			calCWhigh = 21;
			calFoil = 15;
			
			actual_output = subLottabprep( input_lq, input_cal, calCWlow, calCWhigh, calFoil, "Cross Web", "Foil", "AR", "Dose", "Slide Lot", "Chem Type", "Inst Type", "3P" );
			wait(0);
			
			compare_tables = lytesCalUT:tableCompare(actual_output, expected_output);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_subLottabprep_actual.jmp", lytesCalUT:saveFile);
		)
	);

			/////////////////////////////////////////////////////////////
			//                 Lytes Prep Functions                    //
			/////////////////////////////////////////////////////////////
	lytesCalUT:utGroup = "I";
	lytesCalUT:utGroupTest = 0;	
	
	ut test(prepLytesTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_prepCalData",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expected_output = open(lytesCalUT:filePath||"prepCalData_output.jmp", invisible);
			
			lytesCalUT:saveTable(expected_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_prepCalData_lytes_expected.jmp", lytesCalUT:saveFile);
			
			actual_output = prepCalData("LYTES", input_cal_path);
			
			compare_tables = lytesCalUT:tableCompare(actual_output, expected_output);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_prepCalData_lytes_actual.jmp", lytesCalUT:saveFile);
		)
	);
	
	ut test(prepLytesTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_preLoopData",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expected_output = open(lytesCalUT:filePath||"prepLoopData_lytes_output.jmp", invisible);
			
			lytesCalUT:saveTable(expected_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_prepLoopData_lytes_expected.jmp", lytesCalUT:saveFile);
			
			actual_output = prepLoopData("LYTES", input_loop_path, input_cal_data);
			
			compare_tables = lytesCalUT:tableCompare(actual_output, expected_output);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_prepLoopData_lytes_actual.jmp", lytesCalUT:saveFile);
		)
	);
	
	ut test(prepLytesTC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_prepExpiration",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expected_output = open(lytesCalUT:filePath||"prepExpiration_lytes_output.jmp", invisible);
			
			lytesCalUT:saveTable(expected_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_prepExpiration_lytes_expected.jmp", lytesCalUT:saveFile);
			
			actual_output = prepExpiration("LYTES", input_exp_path);
			
			compare_tables = lytesCalUT:tableCompare(actual_output, expected_output);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_prepExpiration_lytes_actual.jmp", lytesCalUT:saveFile);
		)
	);

			/////////////////////////////////////////////////////////////
			//                 SDMA Prep Functions                     //
			/////////////////////////////////////////////////////////////
	lytesCalUT:utGroup = "J";
	lytesCalUT:utGroupTest = 0;	
	
	ut test(prepSDMATC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_SDMAPanelPrep",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expected_output = open(lytesCalUT:filePath||"SDMAPanelPrep_cal_output.jmp", invisible);
			
			lytesCalUT:saveTable(expected_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMAPanelPrep_expected.jmp", lytesCalUT:saveFile);
			
			actual_output = SDMAPanelPrep(input_cal_path);
			
			compare_tables = lytesCalUT:tableCompare(actual_output, expected_output);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMAPanelPrep_actual.jmp", lytesCalUT:saveFile);
		)
	);
	
	ut test(prepSDMATC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_SDMALoopQualPrep",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expected_output = open(lytesCalUT:filePath||"SDMALoopQualPrep_output.jmp", invisible);
			cal_table = open(lytesCalUT:filePath||"SDMAPanelPrep_cal_output.jmp", invisible);
			
			lytesCalUT:saveTable(expected_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMALoopQualPrep_expected.jmp", lytesCalUT:saveFile);
			
			actual_output = SDMALoopQualPrep(input_loop_path, cal_table, input_DXrelease);
			
			compare_tables = lytesCalUT:tableCompare(actual_output, expected_output);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMALoopQualPrep_actual.jmp", lytesCalUT:saveFile);
		)
	);

	ut test(prepSDMATC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_prepExpiration_SDMA",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expected_output = open(lytesCalUT:filePath||"prepExpiration_SDMA_output.jmp", invisible);
			
			lytesCalUT:saveTable(expected_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_prepExpiration_SDMA_expected.jmp", lytesCalUT:saveFile);
			
			actual_output = prepExpiration("SDMA", input_exp_path);
			
			compare_tables = lytesCalUT:tableCompare(actual_output, expected_output);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_prepExpiration_SDMA_actual.jmp", lytesCalUT:saveFile);
		)
	);

	ut test(prepSDMATC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_SDMAInstPrep",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expected_output = open(lytesCalUT:filePath||"SDMAInstPrep_platform_output.jmp", invisible);
			
			lytesCalUT:saveTable(expected_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMAInstPrep_expected.jmp", lytesCalUT:saveFile);
			
			actual_output = SDMAInstPrep(input_inst_path);
			
			compare_tables = lytesCalUT:tableCompare(actual_output, expected_output);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMAInstPrep_actual.jmp", lytesCalUT:saveFile);
		)
	);
	
	ut test(prepSDMATC, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1)||"_SDMAPatientPrep",
		expr(
		
			lytesCalUT:utGroupTest = lytesCalUT:utGroupTest + 1;
			
			expected_output = open(lytesCalUT:filePath||"SDMAPatientPrep_output.jmp", invisible);
			
			lytesCalUT:saveTable(expected_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMAPatientPrep_expected.jmp", lytesCalUT:saveFile);
			
			actual_output = SDMAPatientPrep(input_patient_path);
			
			compare_tables = lytesCalUT:tableCompare(actual_output, expected_output);
			
			//the below may work better than the above through diff JMP versions
			ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
			ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
			ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
			ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
			lytesCalUT:saveTable(actual_output, lytesCalUT:savePath, lytesCalUT:utGroup||Char(lytesCalUT:utGroupTest+1),"_SDMAPatientPrep_actual.jmp", lytesCalUT:saveFile);
		)
	);

);


	/////////////////////////////////////////////////////////////
	//          Saving Report and deleteing Namespace          //
	/////////////////////////////////////////////////////////////
here:saveDeleteNameSpace = Function({namespace},
	Match(namespace:saveFile,
		0, namespace << delete Namespace(Force(1));
		,
		1,
		ut global reporter:save report(namespace:savePath||namespace:reportName);
		namespace << delete Namespace(Force(1));
	);
);

////////////////////////////////////////
//                                    //
//              Main                  //
//                                    //
////////////////////////////////////////

If( Length( Include File List() ) == 1,

	lytesCalUT:varFunct();
	lytesCalUT:unitTests();
	here:saveDeleteNameSpace(lytesCalUT);
	,
	Print( "Sublot Calibration Unit Tests included from another source" );

);