//////OLOL Loop Qualification jslHamcrest Unit Tests//////
t1=today();
loopQualUT = New Namespace("LoopQualificationUnitTest");
loopQualUT:saveFile = 0;
loopQualUT:savePath = "C:\Users\nclark\Desktop/";
loopQualUT:reportName = "00_swt-T6-0016233-00_v1.0x_UnitTestReport.txt";

Match(
	Get Environment Variable("USERNAME"),
		"nclark",
		loopQualUT:toolPath = "/D:/JSL Development/Official JMP Addin Working/RoswellQC.CatalystLoopQualification_swt-T0-0017075-00/Catalyst_LoopQualification.jsl";
		loopQualUT:filePath = "/D:/JSL Development/Official JMP Addin Working/UnitTesting/LoopQualification_Catalyst swt-T0-0017075-00_UT/Files/";
		,
		"sdarling",
		loopQualUT:toolPath = "/C:/Users/sdarling/OneDrive - IDEXX/Sages JSL Working Folders/Roswell QC Tools/RoswellQC.CatalystLoopQualification_swt-T0-0017075-00/Catalyst_LoopQualification.jsl";
		loopQualUT:filePath = "/C:/Users/sdarling/OneDrive - IDEXX/Sages JSL Working Folders/Unit Tests/Nate Repo UT/LoopQualification_Catalyst swt-T0-0017075-00_UT/Files/";
		
);

Match(loopQualUT:saveFile,
	1, ut global reporter = New Object("ut collecting reporter")
);
//use in setup / teardown or UT Tests

loopQualUT:saveTable = Function({tableName,savePath,filePrefix,fileSuffix,testingBOOL = 0,journalSave = 0},{default Local},
	If( testingBOOL == 1,
		If(journalSave == 0,
			baseName = tableName << get name;
			fileName = filePrefix || "_" || baseName || "_" || fileSuffix;
			tableName << SaveAs(savePath||fileName);
			tableName << Set Name(baseName);
			,
			baseName = tableName << get window title;
			Substituteinto(baseName,":","");
			fileName = filePrefix || "_" || baseName || "_" || fileSuffix;
			//show(savePath,fileName);
			tableName << Save Journal(savePath||fileName||".jrn")
		)
		,
		Return(0)
	);
	Return(1);
);

//High level note that how we test table compare varies between JMP 15 and 16
//Unit tests could be updated to test differently based on version being tested...
loopQualUT:tableCompare = Function({actual, expected},{default local},
	result = actual << Compare Data Tables(
		Compare with( expected ),
		Compare Table Properties,
		Compare Column Attributes and Properties,
		Compare Data,
		Show Difference Summary,
		Show Difference Plot
	);
	
	r = result << report;
	Return(r,result)
);

wait(3);		
/////////////////////////////////////////////////////////////
//                                                         //
//          TEST CASES                                     //
//                                                         //
/////////////////////////////////////////////////////////////

varCheckTC = ut test case("A_Variable Checks")
	<<Setup(Expr(
		Include(loopQualUT:toolPath);
	));

quickFunctionsTC = ut test case("B_Support Function Tests")
	<<Setup(Expr(
		Include(loopQualUT:toolPath);
		table1 = Open(loopQualUT:filePath||"HideProgCurveColumns.jmp",invisible);
		table2 = Open(loopQualUT:filePath||"LoopCheckPass.jmp",invisible);
		table3 = Open(loopQualUT:filePath||"LoopCheckFail1.jmp",invisible);
		table4 = Open(loopQualUT:filePath||"LoopCheckFail1.jmp",invisible);
	));

fullMontyTC = ut test case("C_Full Monty Testing")
	<<Setup(Expr(
		Include(loopQualUT:toolPath);
		filePath = loopQualUT:filePath;
		table1 = Open(loopQualUT:filePath||"Loop CL 9-10 passpass.jmp",invisible);
		table7 = open(loopQualUT:filePath||"stitching_QSDMA_start_passpass.jmp",invisible);
		table8 = open(loopQualUT:filePath||"stitching_NA_start_passpass.jmp",invisible);
		//table6 = Open("D:\JSL Development\Official JMP Addin Working\UnitTesting\Calibration_LYTES swt-T0-0016988-00_UT\Files\basicTest_foils_addRemoveCols.jmp",invisible);
	));
	
linAdderTC = ut test case("D_Linear Fit Adder")
	<< Setup(Expr(
		Include(loopQualUT:toolPath);
		table1 = Open(loopQualUT:filePath||"Lin Fit Unit Test Table.jmp",invisible);
	));

productReqsTC = ut test case("E_Product Requirement Function")
	<< Setup(Expr(
		Include(loopQualUT:toolPath);
		table1 = Open(loopQualUT:filePath||"ProdReq_NA.jmp",invisible);
		table2 = Open(loopQualUT:filePath||"ProdReq_K.jmp",invisible);
		table3 = Open(loopQualUT:filePath||"ProdReq_CL.jmp",invisible);
	));

prep4offlineTC = ut test case("F_Prep for Offline Algorithm Function")
	<< Setup(Expr(
		Include(loopQualUT:toolPath);
		table1 = Open(loopQualUT:filePath||"offlinePrep_CL.jmp",invisible);
		table2 = Open(loopQualUT:filePath||"offlinePrep_NA.jmp",invisible);
		table3 = Open(loopQualUT:filePath||"offlinePrep_K.jmp",invisible);
	));

barcodeparseTC = ut test case("G_Parse Barcode")
	<< setup(expr(
		include(loopQualUT:toolPath);
	));

filenameparseTC = ut test case("H_Parse FileName")
	<< setup(expr(
		include(loopQualUT:toolPath);
	));

reportmodalTC = ut test case("i_Dose Report Modal Window")
	<< setup(expr(
		include(loopQualUT:toolPath);
		dr_Cl_PassPass = open(loopQualUT:filePath||"4104409_CL_Loop Qualification Summary Report_PassPass910.jmp", invisible);
		dr_Cl_PassFail = open(loopQualUT:filePath||"4104409_CL_Loop Qualification Summary Report_PassFail910.jmp", invisible);
		dr_Cl_FailPass = open(loopQualUT:filePath||"4104409_CL_Loop Qualification Summary Report_FailPass910.jmp", invisible);
		dr_Cl_FailFail = open(loopQualUT:filePath||"4104409_CL_Loop Qualification Summary Report_FailFail910.jmp", invisible);
		dr_Na_PassPass = open(loopQualUT:filePath||"4101207_NA_Loop Qualification Summary Report_PassPass.jmp", invisible);
		dr_Na_PassFail = open(loopQualUT:filePath||"4101207_NA_Loop Qualification Summary Report_PassFail.jmp", invisible);
		dr_Na_FailPass = open(loopQualUT:filePath||"4101207_NA_Loop Qualification Summary Report_FailPass.jmp", invisible);
		dr_Na_FailFail = open(loopQualUT:filePath||"4101207_NA_Loop Qualification Summary Report_FailFail.jmp", invisible);
		dr_K_PassPass = open(loopQualUT:filePath||"4101406_K_Loop Qualification Summary Report_PassPass.jmp", invisible);
		dr_K_PassFail = open(loopQualUT:filePath||"4101406_K_Loop Qualification Summary Report_PassFail.jmp", invisible);
		dr_K_FailPass = open(loopQualUT:filePath||"4101406_K_Loop Qualification Summary Report_FailPass.jmp", invisible);
		dr_K_FailFail = open(loopQualUT:filePath||"4101406_K_Loop Qualification Summary Report_FailFail.jmp", invisible);
/*		dr_SDMA_PassPass = open("C:\Users\sdarling\IDEXX\R&D Assay Analytics - General\Project Work\QSDMA\Loop Qual WI In Process\Loop Qual Dose SD Report_Passing.jmp", invisible);
		dr_SDMA_PassFail = open("C:\Users\sdarling\IDEXX\R&D Assay Analytics - General\Project Work\QSDMA\Loop Qual WI In Process\Loop Qual Dose SD Report_Failing.jmp", invisible);
		dr_SDMA_FailPass = open("C:\Users\sdarling\IDEXX\R&D Assay Analytics - General\Project Work\QSDMA\Loop Qual WI In Process\Loop Qual Dose SD Report_Failing.jmp", invisible);
		dr_SDMA_FailFail = open("C:\Users\sdarling\IDEXX\R&D Assay Analytics - General\Project Work\QSDMA\Loop Qual WI In Process\Loop Qual Dose SD Report_Failing.jmp", invisible); */
		dr_maintable_lytes = open(loopQualUT:filePath||"Loop=4101207, Chem Type=NA_PassPass.jmp", invisible);
		dr_Errorsummary_lytes = open(loopQualUT:filePath||"4101207_NA_Sublot Corrected SDs by Foil and Fluid_PassPass.jmp", invisible);
		dr_foilErrorCount_lytes = open(loopQualUT:filePath||"4101207_NA_NDE Count by foil_PassPass.jmp", invisible);
	));

subLotBlockTC = ut test case("J_Sublot Blocker Function")
	<< setup(expr(
		Include(loopQualUT:toolPath);
		table1 = Open(loopQualUT:filePath||"sublotBlocker_base.jmp",invisible);
		table2 = Open(loopQualUT:filePath||"sublotBlocker_base2.jmp",invisible);
		table3 = Open(loopQualUT:filePath||"sublotBlocker_base3.jmp",invisible);
		table4 = Open(loopQualUT:filePath||"sublotBlocker_base4.jmp",invisible);
	));

modaloutcomeUT = ut test case("K_Modal Outcome")
	<< setup(expr(
		Include(loopQualUT:toolPath);
		dosereport = open(loopQualUT:filePath||"4101207_NA_Loop Qualification Summary Report_PassPass.jmp", invisible);
	));
	
grubbsTC = ut test case("L_Grubb's")
	<< setup(expr(
		Include(loopQualUT:toolPath);
		outliers = open(loopQualUT:filePath||"Grubbs_Outliers.jmp", invisible);
		nooutliers = open(loopQualUT:filePath||"Grubbs_Outliers_None.jmp", invisible);
	));

masterTargetTC = ut test case("M_master Target")
	<< setup(expr(
		Include(loopQualUT:toolPath);
		table1 = open(loopQualUT:filePath||"masterTarget_manual.jmp", invisible);
		table2 = open(loopQualUT:filePath||"masterTarget_original.jmp", invisible);
	));

loopreportTC = ut test case("N_total Loop Report")
	<< setup(expr(
		Include(loopQualUT:toolPath);
		table1 = open(loopQualUT:filePath||"totalreport_NA_start.jmp", invisible);
		table2 = open(loopQualUT:filePath||"totalreport_NA_summary.jmp", invisible);
		table3 = open(loopQualUT:filePath||"totalreport_NA_errorsummary.jmp", invisible);
		table4 = open(loopQualUT:filePath||"totalreport_NA_foilerror.jmp", invisible);
		table5 = open(loopQualUT:filePath||"totalreport_NA_finish.jmp", invisible);
		table6 = open(loopQualUT:filePath||"totalreport_CL_start.jmp",invisible);
		table7 = open(loopQualUT:filePath||"totalreport_CL_summary.jmp",invisible);
		table8 = open(loopQualUT:filePath||"totalreport_CL_errorsummary.jmp",invisible);
		table9 = open(loopQualUT:filePath||"totalreport_CL_foilerror.jmp",invisible);
		table10 = open(loopQualUT:filePath||"totalreport_CL_unchosen.jmp",invisible);
		table12 = open(loopQualUT:filePath||"totalreport_QSDMA_start.jmp", invisible);
		table13 = open(loopQualUT:filePath||"totalreport_QSDMA_summary.jmp", invisible);
		table14 = open(loopQualUT:filePath||"totalreport_QSDMA_errorsummary.jmp", invisible);
		table15 = open(loopQualUT:filePath||"totalreport_QSDMA_foilerror.jmp", invisible);
		//table16 = open(loopQualUT:filePath||"totalreport_QSDMA_finish.jmp", invisible);
	));



/////////////////////////////////////////////////////////////
//                                                         //
//          UNIT TESTS                                     //
//                                                         //
/////////////////////////////////////////////////////////////

		/////////////////////////////////////////////////////////////
		//          Variables                                      //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "A";
loopQualUT:utGroupTest = 0;

ut test(varCheckTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Starting Variables", 
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		uName = Get Environment Variable("username");
		expectedPath = Substitute(loopQualUT:toolPath,Word(nitems(Words(loopQualUT:toolPath,"/")),loopQualUT:toolPath,"/"),"");

		ut assert that(Expr(u), ut equal to(uName));
		ut assert that(Expr(addinID), ut equal to("com.idexx.RoswellQCTools_LoopQualification"));
		ut assert that(Expr(minJMPver), ut equal to("15.2"));
		ut assert that(Expr(betaLimitwk), ut equal to(4));
		ut assert that(Expr(offAlgParamMatch), ut equal to({
				"Assay","IN_ASSAY",
				"Dilution Parts","IN_DILUTION",
				"False Light","IN_FALSE_LIGHT",
				"Gain","IN_GAIN",
				"Offset","IN_OFFSET",
				"NumWL","IN_WAVELENGTH_COUNT",
				"CenterWL1","IN_WAVELENGTH1",
				"CenterWL2","IN_WAVELENGTH2",
				"DryStart","IN_DRY_START",
				"DryEnd","IN_DRY_END"
			})
		);
		ut assert that(Expr(offAlgTimeseriesMatch), ut equal to({"median read time",
				"ReadFlag",
				"RD",
				"RD2"
			})
		);
		ut assert that(Expr(path), ut equal to(expectedPath));

	)
);

		/////////////////////////////////////////////////////////////
		//          Supporting Functions                           //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "B";
loopQualUT:utGroupTest = 0;

ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_JMP Version Check", 
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		//function pulls the version being executed on
		ver = JMP Version();
		currWords = words(ver,".");
		backHalf = concatitems(currWords[2::nitems(currWords)],"");
		newNumVer = Num(currWords[1]||"."||backHalf);

		ut assert that(Expr(checkVersion(Char(newNumVer - 0.1))), ut equal to(1));
		ut assert that(Expr(checkVersion(Char(newNumVer - 1))), ut equal to(1));
		ut assert that(Expr(checkVersion(Char(newNumVer))), ut equal to(1));
		ut assert that(Expr(checkVersion(Char(newNumVer + 0.1))), ut equal to(0));
		ut assert that(Expr(checkVersion(Char(newNumVer + 1))), ut equal to(0));
	)
);

ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_JMP Version Fail Window",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
				
		closemodal = Function({timeout},
			s = Schedule(
				timeout,
				If(current window() << get window title == "Requires JMP 15.2",
					text = (current window() << xpath("//TextBox"));
					If( text[1] << get text == "This addin requires the used of JMP 15.2+",
						(current window() << xpath("//ButtonBox[text()='OK']")) << click;
						Print("Error Dialog Executed Correctly")
						,
						(current window() << xpath("//ButtonBox[text()='OK']")) << click;
						Print("Wrong text version, Error Dialog Executed")
					)
					,
					(current window() << xpath("//ButtonBox[text()='OK']")) << click;
					Print("Wrong title version, Error Dialog Executed")
				)
			)
		);
		//Failures for the above should be controled at the function level as these checks ensure function has the parameter used in both the title and the text box
		closemodal(2);
		wrongVer(15.2);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Error Dialog Executed Correctly\!""));
		
		closemodal(2);
		wrongVer(17);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Wrong title version, Error Dialog Executed\!""));
	)
);

ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Beta Test Check",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		buildDate1 = Today();
		buildDate2 = Today() - In Weeks(0.51);
		buildDate3 = Today() - In Weeks(0.49);
		
		expDate1 = buildDate1 + In Weeks(0.5);
		expDate2 = buildDate2 + In Weeks(0.5);
		expDate3 = buildDate3 + In Weeks(0.5);
		
		ut assert that(Expr(betaTestCheck(0.5,"test",buildDate1)[1]), ut equal to(1));
		ut assert that(Expr(betaTestCheck(0.5,"test",buildDate2)[1]), ut equal to(0));
		ut assert that(Expr(betaTestCheck(0.5,"test",buildDate3)[1]), ut equal to(1));
		ut assert that(Expr(betaTestCheck(0.5,"test",buildDate1)[2]), ut equal to(expDate1));
		ut assert that(Expr(betaTestCheck(0.5,"test",buildDate2)[2]), ut equal to(expDate2));
		ut assert that(Expr(betaTestCheck(0.5,"test",buildDate3)[2]), ut equal to(expDate3));

	)
);

ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Beta Test Fail Window",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
				
		closemodal = Function({timeout,longDate},
			s = Schedule(
				timeout,
				If(current window() << get window title == "Beta Version Expired",
					text = (current window() << xpath("//TextBox"));
					If( text[1] << get text == "Beta expired on "||longDate,
						If( text[2] << get text == "Please contact author for new release",
							(current window() << xpath("//ButtonBox[text()='OK']")) << click;
							Print("Error Dialog Executed Correctly")
							,
							(current window() << xpath("//ButtonBox[text()='OK']")) << click;
							Print("Wrong text2, Error Dialog Executed")
						)
						,
						(current window() << xpath("//ButtonBox[text()='OK']")) << click;
						Print("Wrong text1, Error Dialog Executed")
					)
					,
					(current window() << xpath("//ButtonBox[text()='OK']")) << click;
					Print("Wrong title version, Error Dialog Executed")
				)
			)
		);
		//Failures for the above should be controled at the function level as these checks ensure function has the parameter used in both the title and the text box
		expirationDate = Today() - In Weeks(0.51);
		longDate = MDYHMS(expirationDate);
		closemodal(2,longDate);
		
		betaFailWindow(expirationDate);
		
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Error Dialog Executed Correctly\!""));
		
	)
);

ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Chemistry Information", 
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		chemInfo = chemistry_information();
		
		ut assert that(Expr(chemInfo[40]["Chem Type"]), ut equal to("CL"));
		ut assert that(Expr(chemInfo[40]["Gain SD"]), ut equal to(0));
		ut assert that(Expr(chemInfo[40]["Offset SD"]), ut equal to(0));
		ut assert that(Expr(chemInfo[40]["Outlier Threshold - Loop"]), ut equal to(22));
		ut assert that(Expr(chemInfo[40]["Outlier Threshold - Foil"]), ut equal to(2));
		ut assert that(Expr(chemInfo[40]["H22"]), ut equal to(89));
		ut assert that(Expr(chemInfo[40]["H44"]), ut equal to(138));
		ut assert that(Expr(chemInfo[40]["Alpha"]), ut equal to("0.01"));
		ut assert that(Expr(chemInfo[40]["Dose Range"]), ut equal to([50 160]));
		ut assert that(Expr(chemInfo[40]["Dose SD"]), ut equal to([1.25 4]));
		
		ut assert that(Expr(chemInfo[41]["Chem Type"]), ut equal to("K"));
		ut assert that(Expr(chemInfo[41]["Gain SD"]), ut equal to(0));
		ut assert that(Expr(chemInfo[41]["Offset SD"]), ut equal to(0));
		ut assert that(Expr(chemInfo[41]["Outlier Threshold - Loop"]), ut equal to(22));
		ut assert that(Expr(chemInfo[41]["Outlier Threshold - Foil"]), ut equal to(2));
		ut assert that(Expr(chemInfo[41]["H22"]), ut equal to(3));
		ut assert that(Expr(chemInfo[41]["H44"]), ut equal to(7));
		ut assert that(Expr(chemInfo[41]["Alpha"]), ut equal to("0.01"));
		ut assert that(Expr(chemInfo[41]["Dose Range"]), ut equal to([0.8 3 5.9 10]));
		ut assert that(Expr(chemInfo[41]["Dose SD"]), ut equal to([0.13 0.13 0.1475 0.25]));
		
		ut assert that(Expr(chemInfo[42]["Chem Type"]), ut equal to("NA"));
		ut assert that(Expr(chemInfo[42]["Gain SD"]), ut equal to(0));
		ut assert that(Expr(chemInfo[42]["Offset SD"]), ut equal to(0));
		ut assert that(Expr(chemInfo[42]["Outlier Threshold - Loop"]), ut equal to(22));
		ut assert that(Expr(chemInfo[42]["Outlier Threshold - Foil"]), ut equal to(2));
		ut assert that(Expr(chemInfo[42]["H22"]), ut equal to(125));
		ut assert that(Expr(chemInfo[42]["H44"]), ut equal to(167));
		ut assert that(Expr(chemInfo[42]["Alpha"]), ut equal to("0.01"));
		ut assert that(Expr(chemInfo[42]["Dose Range"]), ut equal to([85 180]));
		ut assert that(Expr(chemInfo[42]["Dose SD"]), ut equal to([2 2]));
		
		ut assert that(Expr(chemInfo[4]["Chem Type"]), ut equal to("SDMA"));
		ut assert that(Expr(chemInfo[4]["Gain SD"]), ut equal to(0.021));
		ut assert that(Expr(chemInfo[4]["Offset SD"]), ut equal to(10));
		ut assert that(Expr(chemInfo[4]["Outlier Threshold - Loop"]), ut equal to(10));
		ut assert that(Expr(chemInfo[4]["Outlier Threshold - Foil"]), ut equal to(100));
		ut assert that(Expr(chemInfo[4]["Alpha"]), ut equal to("0.01"));
		ut assert that(Expr(chemInfo[4]["Dose Range"]), ut equal to([0 5 15 18 25 50 100]));
		ut assert that(Expr(chemInfo[4]["Dose SD"]), ut equal to([3 1.5 1.5 1.7 2.25 5 10]));		
		
	)
);

ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Assay Codes", 
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		assayCodes = assayTypes();
		
		ut assert that(Expr(assayCodes["GLU"]), ut equal to(0));
		ut assert that(Expr(assayCodes["BUN"]), ut equal to(1));
		ut assert that(Expr(assayCodes["CA"]), ut equal to(3));
		ut assert that(Expr(assayCodes["URIC"]), ut equal to(5));
		ut assert that(Expr(assayCodes["TP"]), ut equal to(6));
		ut assert that(Expr(assayCodes["TRIG"]), ut equal to(7));
		ut assert that(Expr(assayCodes["CHOL"]), ut equal to(8));
		ut assert that(Expr(assayCodes["ALB"]), ut equal to(9));
		ut assert that(Expr(assayCodes["NH3"]), ut equal to(10));
		ut assert that(Expr(assayCodes["PHOS"]), ut equal to(12));
		ut assert that(Expr(assayCodes["TBIL"]), ut equal to(14));
		ut assert that(Expr(assayCodes["CREA"]), ut equal to(15));
		ut assert that(Expr(assayCodes["FRU"]), ut equal to(16));
		ut assert that(Expr(assayCodes["CRP"]), ut equal to(17));
		ut assert that(Expr(assayCodes["SDMA"]), ut equal to(18.04));
		ut assert that(Expr(assayCodes["BA"]), ut equal to(21));
		ut assert that(Expr(assayCodes["PROG"]), ut equal to(23));
		ut assert that(Expr(assayCodes["PHBR"]), ut equal to(25));
		ut assert that(Expr(assayCodes["TT4"]), ut equal to(28.30));
		ut assert that(Expr(assayCodes["MG"]), ut equal to(32));
		ut assert that(Expr(assayCodes["LAC"]), ut equal to(35));
		ut assert that(Expr(assayCodes["CL"]), ut equal to(40));
		ut assert that(Expr(assayCodes["K"]), ut equal to(41));
		ut assert that(Expr(assayCodes["NA"]), ut equal to(42));
		ut assert that(Expr(assayCodes["UPRO"]), ut equal to(54));
		ut assert that(Expr(assayCodes["ALTV"]), ut equal to(56));
		ut assert that(Expr(assayCodes["TCO2"]), ut equal to(57));
		ut assert that(Expr(assayCodes["LIPA"]), ut equal to(59));
		ut assert that(Expr(assayCodes["AMYL"]), ut equal to(60));
		ut assert that(Expr(assayCodes["ALT"]), ut equal to(62));
		ut assert that(Expr(assayCodes["LDH"]), ut equal to(63));
		ut assert that(Expr(assayCodes["CK"]), ut equal to(64));
		ut assert that(Expr(assayCodes["ALKP"]), ut equal to(65));
		ut assert that(Expr(assayCodes["GGT"]), ut equal to(67));
		ut assert that(Expr(assayCodes["UCRE"]), ut equal to(70));
		ut assert that(Expr(assayCodes["AST"]), ut equal to(73));
		ut assert that(Expr(assayCodes["WRS"]), ut equal to(90));
		ut assert that(Expr(assayCodes[.]), ut equal to(-999));
		
	)
);
		
ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Hide Prog Curve Columns", 
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		ut assert that(Expr(table1 << get hidden columns), ut equal to({}));
		ut assert that(Expr(table1 << get column group("ProgCurveCols")), ut empty());
		output = hideProgCurveColumns(table1);
		
		ut assert that(Expr(table1 << get hidden columns), ut equal to({
				:"24"n,	:"25"n,	:"26"n,	:"27"n,	:"28"n,	:"29"n,	:"30"n,	:"31"n,	:"32"n,	:"33"n,	:"34"n,
				:"35"n,	:"36"n,	:"37"n,	:"38"n,	:"39"n,	:"40"n,	:"41"n,	:"42"n,	:"43"n,	:"44"n,	:"45"n,
				:"46"n,	:"47"n,	:"48"n,	:"49"n,	:"50"n,	:"51"n,	:"52"n,	:"53"n,	:"54"n,	:"55"n,	:"56"n,
				:"57"n,	:"58"n,	:"59"n,	:"60"n,	:"61"n,	:"62"n,	:"63"n,	:"64"n,	:"65"n
			})
		);
		ut assert that(Expr(table1 << get column group("ProgCurveCols")), ut equal to({
				:"24"n,	:"25"n,	:"26"n,	:"27"n,	:"28"n,	:"29"n,	:"30"n,	:"31"n,	:"32"n,	:"33"n,	:"34"n,
				:"35"n,	:"36"n,	:"37"n,	:"38"n,	:"39"n,	:"40"n,	:"41"n,	:"42"n,	:"43"n,	:"44"n,	:"45"n,
				:"46"n,	:"47"n,	:"48"n,	:"49"n,	:"50"n,	:"51"n,	:"52"n,	:"53"n,	:"54"n,	:"55"n,	:"56"n,
				:"57"n,	:"58"n,	:"59"n,	:"60"n,	:"61"n,	:"62"n,	:"63"n,	:"64"n,	:"65"n
			})
		);
		
	)
);

ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Loop lot Check", 
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		ut assert that(Expr(fileVsBCRloopLotCheck(table2)), ut equal to(1));
		ut assert that(Expr(fileVsBCRloopLotCheck(table3)), ut equal to(0));
		ut assert that(Expr(fileVsBCRloopLotCheck(table4)), ut equal to(0));
	)
);

ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Loop Lot Match Fail Window",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
				
		closemodal = Function({timeout},
			s = Schedule(
				timeout,
				If(current window() << get window title == "Loop Lot Mismatch",
					text = (current window() << xpath("//TextBox"));
					If( text[1] << get text == "Loop Lot coded in filename does not match barcode for one or more files",
						If( text[2] << get text == "Please fix discrepancies and proceed",
							If( text[4] << get text == "Last 6 digits of filename Loop Lot must match barcode 1st 6 digits",
								(current window() << xpath("//ButtonBox[text()='OK']")) << click;
								Print("Error Dialog Executed Correctly")
								,
								(current window() << xpath("//ButtonBox[text()='OK']")) << click;
								Print("Wrong text4, Error Dialog Executed")
							)
							,
							(current window() << xpath("//ButtonBox[text()='OK']")) << click;
							Print("Wrong text2, Error Dialog Executed")
						)
						,
						(current window() << xpath("//ButtonBox[text()='OK']")) << click;
						Print("Wrong text1, Error Dialog Executed")
					)
					,
					(current window() << xpath("//ButtonBox[text()='OK']")) << click;
					Print("Wrong title version, Error Dialog Executed")
				)
			)
		);
		//Failures for the above should be controled at the function level as these checks ensure function has the parameter used in both the title and the text box
		closemodal(2);
		
		loopNumNotMatchBCR();
		
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Error Dialog Executed Correctly\!""));
		
	)
);

ut test(quickFunctionsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_User Canceled",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
				
		closemodal = Function({timeout},
			s = Schedule(
				timeout,
				If(current window() << get window title == "User Canceled",
					text = (current window() << xpath("//TextBox"));
					If( text[1] << get text == "User Canceled at final status window",
						If( text[2] << get text == "Please start over",
							(current window() << xpath("//ButtonBox[text()='OK']")) << click;
							Print("Error Dialog Executed Correctly")
							,
							(current window() << xpath("//ButtonBox[text()='OK']")) << click;
							Print("Wrong text2, Error Dialog Executed")
						)
						,
						(current window() << xpath("//ButtonBox[text()='OK']")) << click;
						Print("Wrong text1, Error Dialog Executed")
					)
					,
					(current window() << xpath("//ButtonBox[text()='OK']")) << click;
					Print("Wrong title version, Error Dialog Executed")
				)
			)
		);
		//Failures for the above should be controled at the function level as these checks ensure function has the parameter used in both the title and the text box
		closemodal(2);
		
		userCanceled();
		
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Error Dialog Executed Correctly\!""));
		
	)
);


		/////////////////////////////////////////////////////////////
		//                  Full Monty Testing                     //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "C";
loopQualUT:utGroupTest = 0;

ut test(fullMontyTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_full CL Loop 9-10 Pass",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		table2 = Open(loopQualUT:filePath||"Loop CL 9-10 passpass_expectedMain.jmp",invisible);
		table3 = Open(loopQualUT:filePath||"Loop CL 9-10 passpass_exectedSummary.jmp",invisible);
		table4 = Open(loopQualUT:filePath||"Loop CL 9-10 passpass_expectedSDs.jmp",invisible);
		table5 = Open(loopQualUT:filePath||"Loop CL 9-10 passpass_expectedNDE.jmp",invisible);
		table6 = Open(loopQualUT:filePath||"Loop CL 9-10 passpass_expectedUnChosen.jmp",invisible);
		
		closemodal = Function({timeout},
			s = Schedule(
				timeout,
				Op_Ack << set text("SMD");
				(current window() << xpath("//ButtonBox[text()='OK']")) << click;
			)
		);
		closemodal(40);
		
		output = stitchingFunct(table1);
		
		compMain = loopQualUT:tableCompare(output[1],table2);
		compSumm = loopQualUT:tableCompare(output[2],table3);
		compNDE = loopQualUT:tableCompare(output[3],table4);
		compSD = loopQualUT:tableCompare(output[4],table5);
		compUn = loopQualUT:tableCompare(output[5],table6);
		
		tableName = table1 << get name;
		unchosenName = "unchosen9-10-11_"|| tableName;
		ut assert that(Expr(output[1] << get name), ut equal to(table1 << get name));
		ut assert that(Expr(output[2] << get name), ut equal to("4140412_CL_Loop Qualification Summary Report"));
		ut assert that(Expr(output[3] << get name), ut equal to("4140412_CL_Sublot Corrected SDs by Foil and Fluid"));
		ut assert that(Expr(output[4] << get name), ut equal to("4140412_CL_NDE Count by foil"));
		ut assert that(Expr(output[5] << get name), ut equal to(unchosenName));
				
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//ut assert that(Expr(compSumm[2] << Are Data Different), ut equal to(0));
		//checks each column except for the last one, which should be date and very specific to when the unit tests run
		For(i=1,i<=( ncol(output[2]) - 1 ),i++,
			ut assert that(Expr(Column(output[2],i) << get as matrix), ut equal to(Column(table3,i) << get as matrix))
		);
		ut assert that(Expr(compSumm[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSumm[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		ut assert that(Expr(compNDE[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compNDE[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compNDE[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		ut assert that(Expr(compSD[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compSD[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSD[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSD[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSD[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		ut assert that(Expr(compUn[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compUn[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compUn[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compUn[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compUn[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
	)
);

ut test(fullMontyTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_full NA Pass",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		//open tables
		table2 = Open(loopQualUT:filePath||"stitching_NA_finish_passpass.jmp",invisible);
		table3 = Open(loopQualUT:filePath||"stitching_NA_summary_passpass.jmp",invisible);
		table4 = Open(loopQualUT:filePath||"stitching_NA_errorsummary_passpass.jmp",invisible);
		table5 = Open(loopQualUT:filePath||"stitching_NA_foilerror_passpass.jmp",invisible);
		
		closemodal = Function({timeout},
			s = Schedule(
				timeout,
				Op_Ack << set text("YAS");
				(current window() << xpath("//ButtonBox[text()='OK']")) << click;
			)
		);
		closemodal(30);
		
		output = stitchingFunct(table8);
		
		compMain = loopQualUT:tableCompare(output[1],table2);
		compSumm = loopQualUT:tableCompare(output[2],table3);
		compNDE = loopQualUT:tableCompare(output[3],table4);
		compSD = loopQualUT:tableCompare(output[4],table5);
		
		tableName = table8 << get name;
		ut assert that(Expr(output[1] << get name), ut equal to(table8 << get name));
		ut assert that(Expr(output[2] << get name), ut equal to("4147114_NA_Loop Qualification Summary Report"));
		ut assert that(Expr(output[3] << get name), ut equal to("4147114_NA_Sublot Corrected SDs by Foil and Fluid"));
		ut assert that(Expr(output[4] << get name), ut equal to("4147114_NA_NDE Count by foil"));
				
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//ut assert that(Expr(compSumm[2] << Are Data Different), ut equal to(0));
//checks each column except for the last one, which should be date and very specific to when the unit tests run
		For(i=1,i<=( ncol(output[2]) - 1 ),i++,
			ut assert that(Expr(Column(output[2],i) << get as matrix), ut equal to(Column(table3,i) << get as matrix))
		);
		ut assert that(Expr(compSumm[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSumm[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		ut assert that(Expr(compNDE[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compNDE[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compNDE[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		ut assert that(Expr(compSD[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compSD[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSD[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSD[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSD[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
	)
);

ut test(fullMontyTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_full QSDMA Pass",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		//open tables
		table2 = Open(loopQualUT:filePath||"stitching_QSDMA_finish_passpass.jmp",invisible);
		table3 = Open(loopQualUT:filePath||"stitching_QSDMA_summary_passpass.jmp",invisible);
		table4 = Open(loopQualUT:filePath||"stitching_QSDMA_errorsummary_passpass.jmp",invisible);
		table5 = Open(loopQualUT:filePath||"stitching_QSDMA_foilerror_passpass.jmp",invisible);
		
		closemodal = Function({timeout},
			s = Schedule(
				timeout,
				Op_Ack << set text("YAS");
				(current window() << xpath("//ButtonBox[text()='OK']")) << click;
			)
		);
		closemodal(10);
		
		output = stitchingFunct(table7);
		
		compMain = loopQualUT:tableCompare(output[1],table2);
		compSumm = loopQualUT:tableCompare(output[2],table3);
		compNDE = loopQualUT:tableCompare(output[3],table4);
		compSD = loopQualUT:tableCompare(output[4],table5);
		
		tableName = table7 << get name;
		ut assert that(Expr(output[1] << get name), ut equal to(table7 << get name));
		ut assert that(Expr(output[2] << get name), ut equal to("4149201_SDMA_Loop Qualification Summary Report"));
		ut assert that(Expr(output[3] << get name), ut equal to("4149201_SDMA_Sublot Corrected SDs by Foil and Fluid"));
		ut assert that(Expr(output[4] << get name), ut equal to("4149201_SDMA_NDE Count by foil"));
				
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//ut assert that(Expr(compSumm[2] << Are Data Different), ut equal to(0));
		//checks each column except for the last one, which should be date and very specific to when the unit tests run
		For(i=1,i<=( ncol(output[2]) - 1 ),i++,
			ut assert that(Expr(Column(output[2],i) << get as matrix), ut equal to(Column(table3,i) << get as matrix))
		);
		ut assert that(Expr(compSumm[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSumm[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		ut assert that(Expr(compNDE[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compNDE[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compNDE[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		ut assert that(Expr(compSD[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compSD[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSD[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSD[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSD[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
			
	)
);

ut test(fullMontyTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_full CL Cancel 0",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closemodal = Function({timeout},
			s = Schedule(
				timeout,
				//Op_Ack << set text("YAS");
				(current window() << xpath("//ButtonBox[text()='Cancel']")) << click;
			)
		);
		closemodal(40);
		
		closemodal2 = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				wait(1);
				If(current window() << get window title == "User Canceled",
					//Current Window() << close window;
					(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
					If(current window() << get window title == "User Canceled",
						Print("2nd Modal not close correctly")
						,
						print("Cleanup Modal Closes")
					)
					,
					Print("incorrect window current")
				);
			);
		);
		
		closemodal2(45);
		
		output = stitchingFunct(table1);
		ut assert that(Expr(output), ut equal to(0));
	)
);

ut test(fullMontyTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_full NA Cancel 0",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closemodal = Function({timeout},
			s = Schedule(
				timeout,
				//Op_Ack << set text("YAS");
				(current window() << xpath("//ButtonBox[text()='Cancel']")) << click;
			)
		);
		closemodal(30);
		
		closemodal2 = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				wait(1);
				If(current window() << get window title == "User Canceled",
					//Current Window() << close window;
					(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
					If(current window() << get window title == "User Canceled",
						Print("2nd Modal not close correctly")
						,
						print("Cleanup Modal Closes")
					)
					,
					Print("incorrect window current")
				);
			);
		);
		
		closemodal2(35);
		
		output = stitchingFunct(table8);
		ut assert that(Expr(output), ut equal to(0));
	)
);

ut test(fullMontyTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_full QSDMA Cancel 0",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closemodal = Function({timeout},
			s = Schedule(
				timeout,
				//Op_Ack << set text("YAS");
				(current window() << xpath("//ButtonBox[text()='Cancel']")) << click;
			)
		);
		closemodal(10);
		
		closemodal2 = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				wait(1);
				If(current window() << get window title == "User Canceled",
					//Current Window() << close window;
					(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
					If(current window() << get window title == "User Canceled",
						Print("2nd Modal not close correctly")
						,
						print("Cleanup Modal Closes")
					)
					,
					Print("incorrect window current")
				);
			);
		);
		
		closemodal2(12);
		
		output = stitchingFunct(table7);
		ut assert that(Expr(output), ut equal to(0));
	)
);


		/////////////////////////////////////////////////////////////
		//          linAdder Function                              //
		/////////////////////////////////////////////////////////////

loopQualUT:utGroup = "D";
loopQualUT:utGroupTest = 0;

ut test(linAdderTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_linear Adder Function table test",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		dtExpected = Open(loopQualUT:filePath||"Lin Fit Unit Test Table_Expected Output.jmp");
		actual_table = linearFitadder( table1, "Measured Dose", "SubLot", "True Dose", "Slide Lot", "Chem Type", 0.9, 1.1 );

		compare_tables = loopQualUT:tableCompare(actual_table, dtExpected);
		
		//the below may work better than the above through diff JMP versions
		ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
	)
);

		/////////////////////////////////////////////////////////////
		//          Product Requirments Function                   //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "E";
loopQualUT:utGroupTest = 0;

ut test(productReqsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Sodium-Potassium-Chloride",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		productReqsFunc(table1,"Dose","Chem Type","Replicates",0.001);
		productReqsFunc(table2,"Dose","Chem Type","Replicates",0.001);
		productReqsFunc(table3,"Dose","Chem Type","Replicates",0.001);
		
		ut assert that(Expr(table1:"Requirement"n << get as matrix), ut equal to([2, 2]));
		ut assert that(Expr(table1:"Req Upper CI"n << get as matrix), ut equal to([2.8121889491637, 2.8121889491637]));
		
		ut assert that(Expr(table2:"Requirement"n << get as matrix), ut equal to([0.13, 0.175]));
		ut assert that(Expr(Round(table2:"Req Upper CI"n << get as matrix,6)), ut equal to([0.172697, 0.232476]));
		
		ut assert that(Expr(Round(table3:"Requirement"n << get as matrix,3)), ut equal to([2.225, 3.450]));
		ut assert that(Expr(Round(table3:"Req Upper CI"n << get as matrix,6)), ut equal to([2.962915, 5.050302]));
		
	)
);

		/////////////////////////////////////////////////////////////
		//          Prep For Offline Alg Function                  //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "F";
loopQualUT:utGroupTest = 0;

ut test(prep4offlineTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Chloride",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		colList = table1 << get column names(string);
		scalarLocale = contains(colList,"Scalar");
		falseLightLocale = scalarLocale + 1;
		
		expectedUnique = {};
		For Each Row(table1,
			Insertinto(expectedUnique,:"Date_Time"n || ", " || Char( :"Slide Position"n ))
		);
		expectedIonPts = {"24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55"};
		
		medianTimeArray = ["CatDx" => [0 => -118.9706261, 1 => -103.0747569, 2 => -87.77946186, 3 => -71.88359404, 4 => -56.58830619, 5 => -40.69242692, 6 => -25.39705682, 7 => -9.501245975, 8 => 5.7979798317, 9 =>21.689908981, 10 => 36.98516798, 11 => 52.881079912, 12 => 68.176320076, 13 => 84.072241068, 14 =>99.367466927, 15 => 115.26339507, 16 => 130.55861902, 17 => 146.45455194, 18 => 161.74977303, 19 =>177.64570713, 20 => 192.94093108, 21 => 208.83686805, 22 => 224.13210201, 23 => 240.02821589, 24 =>255.32346797, 25 => 271.21942091, 26 => 286.51464915, 27 => 302.4103601, 28 => 317.70584607, 29 =>333.60173893, 30 => 348.89699411, 31 => 364.79299116], "CatOne" => [0 => -116.111394,1 => -100.961624,2 => -85.236598,3 => -70.086634,4 => -54.361603,5 => -39.211621,6 => -23.486595,7 => -8.336611,8 => 7.388367,9 => 22.538327,10 => 38.263401,11 => 53.413388,12 => 69.138426,13 => 84.288387,14 => 100.013426,15 => 115.163387,16 => 130.888424,17 => 146.038389,18 => 161.763427,19 => 176.91337,20 => 192.638455,21 => 207.78841,22 => 223.513412,23 => 238.663401,24 => 254.388427,25 => 269.538468,26 => 285.263447,27 => 300.413383,28 => 316.138511,29 => 331.288389,30 => 347.013415,31 => 362.163539]];
		
		output = prep4offline(table1,path);
		
		ut assert that(Expr(table1:"uniqueCol"n << get as matrix), ut equal to(expectedUnique));
		ut assert that(Expr(Column(table1,scalarLocale) << get name), ut equal to("Scalar_orig"));
		ut assert that(Expr(Column(table1,falseLightLocale) << get name), ut equal to("FalseLight_orig"));
		ut assert that(Expr(output[1]:"Scalar"n << get as matrix), ut every item(0.95496958494186));
		ut assert that(Expr(output[1]:"False Light"n << get as matrix), ut every item(4661));
		ut assert that(Expr(output[2][1] << Get Name), ut equal to("Dry 9-10"));
		ut assert that(Expr(output[2][2] << Get Name), ut equal to("Dry 9-10-11"));
		ut assert that(Expr(output[2][3] << Get Name), ut equal to("Dry 10-11"));
		
		ut assert that(Expr(output[2][1]:"DryStart"n << get as matrix), ut every item(9));
		ut assert that(Expr(output[2][1]:"DryEnd"n << get as matrix), ut every item(10));
		ut assert that(Expr(output[2][2]:"DryStart"n << get as matrix), ut every item(9));
		ut assert that(Expr(output[2][2]:"DryEnd"n << get as matrix), ut every item(11));
		ut assert that(Expr(output[2][3]:"DryStart"n << get as matrix), ut every item(10));
		ut assert that(Expr(output[2][3]:"DryEnd"n << get as matrix), ut every item(11));
		
		ut assert that(Expr(output[2][1]:"Dilution Parts"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"Offset"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"NumWL"n << get as matrix), ut every item(1));
		ut assert that(Expr(output[2][1]:"CenterWL1"n << get as matrix), ut every item(470));
		ut assert that(Expr(output[2][1]:"CenterWL2"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"ReadFlag"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"RD2"n << get as matrix), ut every item(0));

		Summarize(output[2][1], readPts = by(:"ion Read Point"n));		
		ut assert that(Expr(readPts), ut equal to(expectedIonPts));

		For Each Row(output[2][1],
			ut assert that(Expr(:"Catalyst Read Point"n), ut equal to(:"ion Read Point"n - 24))
		);
		For Each Row(output[2][1],
			instType = Match( Substr( :"InstrumentSerial"n, 1, 4 ), "CTDX", "CatDx", "CAT1", "CatOne" );
			ut assert that(Expr(:"Inst Type"n), ut equal to(instType))
		);
		For Each Row(output[2][1],
			ut assert that(Expr(:"Gain"n), ut equal to( 1/:"Scalar"n))
		);
		For Each Row(output[2][1],
			ut assert that(Expr(:"median read time"n), ut equal to( medianTimeArray[:"Inst Type"n][:"Catalyst Read Point"n] ))
		);
		
	)
);

ut test(prep4offlineTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Sodium",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		colList = table2 << get column names(string);
		scalarLocale = contains(colList,"Scalar");
		falseLightLocale = scalarLocale + 1;
		
		expectedUnique = {};
		For Each Row(table2,
			Insertinto(expectedUnique,:"Date_Time"n || ", " || Char( :"Slide Position"n ))
		);
		expectedIonPts = {"24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55"};
		
		medianTimeArray = ["CatDx" => [0 => -118.9706261, 1 => -103.0747569, 2 => -87.77946186, 3 => -71.88359404, 4 => -56.58830619, 5 => -40.69242692, 6 => -25.39705682, 7 => -9.501245975, 8 => 5.7979798317, 9 =>21.689908981, 10 => 36.98516798, 11 => 52.881079912, 12 => 68.176320076, 13 => 84.072241068, 14 =>99.367466927, 15 => 115.26339507, 16 => 130.55861902, 17 => 146.45455194, 18 => 161.74977303, 19 =>177.64570713, 20 => 192.94093108, 21 => 208.83686805, 22 => 224.13210201, 23 => 240.02821589, 24 =>255.32346797, 25 => 271.21942091, 26 => 286.51464915, 27 => 302.4103601, 28 => 317.70584607, 29 =>333.60173893, 30 => 348.89699411, 31 => 364.79299116], "CatOne" => [0 => -116.111394,1 => -100.961624,2 => -85.236598,3 => -70.086634,4 => -54.361603,5 => -39.211621,6 => -23.486595,7 => -8.336611,8 => 7.388367,9 => 22.538327,10 => 38.263401,11 => 53.413388,12 => 69.138426,13 => 84.288387,14 => 100.013426,15 => 115.163387,16 => 130.888424,17 => 146.038389,18 => 161.763427,19 => 176.91337,20 => 192.638455,21 => 207.78841,22 => 223.513412,23 => 238.663401,24 => 254.388427,25 => 269.538468,26 => 285.263447,27 => 300.413383,28 => 316.138511,29 => 331.288389,30 => 347.013415,31 => 362.163539]];
		
		output = prep4offline(table2,path);
		
		ut assert that(Expr(table2:"uniqueCol"n << get as matrix), ut equal to(expectedUnique));
		ut assert that(Expr(Column(table2,scalarLocale) << get name), ut equal to("Scalar_orig"));
		ut assert that(Expr(Column(table2,falseLightLocale) << get name), ut equal to("FalseLight_orig"));
		ut assert that(Expr(output[1]:"Scalar"n << get as matrix), ut every item(0.97156351804733));
		ut assert that(Expr(output[1]:"False Light"n << get as matrix), ut every item(3862));
		ut assert that(Expr(output[2][1] << Get Name), ut equal to("Dry 6-7"));
		
		ut assert that(Expr(output[2][1]:"DryStart"n << get as matrix), ut every item(6));
		ut assert that(Expr(output[2][1]:"DryEnd"n << get as matrix), ut every item(7));
		
		ut assert that(Expr(output[2][1]:"Dilution Parts"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"Offset"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"NumWL"n << get as matrix), ut every item(1));
		ut assert that(Expr(output[2][1]:"CenterWL1"n << get as matrix), ut every item(470));
		ut assert that(Expr(output[2][1]:"CenterWL2"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"ReadFlag"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"RD2"n << get as matrix), ut every item(0));

		Summarize(output[2][1], readPts = by(:"ion Read Point"n));		
		ut assert that(Expr(readPts), ut equal to(expectedIonPts));

		For Each Row(output[2][1],
			ut assert that(Expr(:"Catalyst Read Point"n), ut equal to(:"ion Read Point"n - 24))
		);
		For Each Row(output[2][1],
			instType = Match( Substr( :"InstrumentSerial"n, 1, 4 ), "CTDX", "CatDx", "CAT1", "CatOne" );
			ut assert that(Expr(:"Inst Type"n), ut equal to(instType))
		);
		For Each Row(output[2][1],
			ut assert that(Expr(:"Gain"n), ut equal to( 1/:"Scalar"n))
		);
		For Each Row(output[2][1],
			ut assert that(Expr(:"median read time"n), ut equal to( medianTimeArray[:"Inst Type"n][:"Catalyst Read Point"n] ))
		);
		
	)
);

ut test(prep4offlineTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Potassium",
	Expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		colList = table3 << get column names(string);
		scalarLocale = contains(colList,"Scalar");
		falseLightLocale = scalarLocale + 1;
		
		expectedUnique = {};
		For Each Row(table3,
			Insertinto(expectedUnique,:"Date_Time"n || ", " || Char( :"Slide Position"n ))
		);
		expectedIonPts = {"24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55"};
		
		medianTimeArray = ["CatDx" => [0 => -118.9706261, 1 => -103.0747569, 2 => -87.77946186, 3 => -71.88359404, 4 => -56.58830619, 5 => -40.69242692, 6 => -25.39705682, 7 => -9.501245975, 8 => 5.7979798317, 9 =>21.689908981, 10 => 36.98516798, 11 => 52.881079912, 12 => 68.176320076, 13 => 84.072241068, 14 =>99.367466927, 15 => 115.26339507, 16 => 130.55861902, 17 => 146.45455194, 18 => 161.74977303, 19 =>177.64570713, 20 => 192.94093108, 21 => 208.83686805, 22 => 224.13210201, 23 => 240.02821589, 24 =>255.32346797, 25 => 271.21942091, 26 => 286.51464915, 27 => 302.4103601, 28 => 317.70584607, 29 =>333.60173893, 30 => 348.89699411, 31 => 364.79299116], "CatOne" => [0 => -116.111394,1 => -100.961624,2 => -85.236598,3 => -70.086634,4 => -54.361603,5 => -39.211621,6 => -23.486595,7 => -8.336611,8 => 7.388367,9 => 22.538327,10 => 38.263401,11 => 53.413388,12 => 69.138426,13 => 84.288387,14 => 100.013426,15 => 115.163387,16 => 130.888424,17 => 146.038389,18 => 161.763427,19 => 176.91337,20 => 192.638455,21 => 207.78841,22 => 223.513412,23 => 238.663401,24 => 254.388427,25 => 269.538468,26 => 285.263447,27 => 300.413383,28 => 316.138511,29 => 331.288389,30 => 347.013415,31 => 362.163539]];
		
		output = prep4offline(table3,path);
		
		ut assert that(Expr(table3:"uniqueCol"n << get as matrix), ut equal to(expectedUnique));
		ut assert that(Expr(Column(table3,scalarLocale) << get name), ut equal to("Scalar_orig"));
		ut assert that(Expr(Column(table3,falseLightLocale) << get name), ut equal to("FalseLight_orig"));
		ut assert that(Expr(output[1]:"Scalar"n << get as matrix), ut every item(0.97153460979462));
		ut assert that(Expr(output[1]:"False Light"n << get as matrix), ut every item(3862));
		ut assert that(Expr(output[2][1] << Get Name), ut equal to("Dry 6-7"));
		
		ut assert that(Expr(output[2][1]:"DryStart"n << get as matrix), ut every item(6));
		ut assert that(Expr(output[2][1]:"DryEnd"n << get as matrix), ut every item(7));
		
		ut assert that(Expr(output[2][1]:"Dilution Parts"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"Offset"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"NumWL"n << get as matrix), ut every item(1));
		ut assert that(Expr(output[2][1]:"CenterWL1"n << get as matrix), ut every item(470));
		ut assert that(Expr(output[2][1]:"CenterWL2"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"ReadFlag"n << get as matrix), ut every item(0));
		ut assert that(Expr(output[2][1]:"RD2"n << get as matrix), ut every item(0));

		Summarize(output[2][1], readPts = by(:"ion Read Point"n));		
		ut assert that(Expr(readPts), ut equal to(expectedIonPts));

		For Each Row(output[2][1],
			ut assert that(Expr(:"Catalyst Read Point"n), ut equal to(:"ion Read Point"n - 24))
		);
		For Each Row(output[2][1],
			instType = Match( Substr( :"InstrumentSerial"n, 1, 4 ), "CTDX", "CatDx", "CAT1", "CatOne" );
			ut assert that(Expr(:"Inst Type"n), ut equal to(instType))
		);
		For Each Row(output[2][1],
			ut assert that(Expr(:"Gain"n), ut equal to( 1/:"Scalar"n))
		);
		For Each Row(output[2][1],
			ut assert that(Expr(:"median read time"n), ut equal to( medianTimeArray[:"Inst Type"n][:"Catalyst Read Point"n] ))
		);
		
	)
);

		/////////////////////////////////////////////////////////////
		//                   Barcode_Parse                         //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "G";
loopQualUT:utGroupTest = 0;

ut test(barcodeparseTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Loop Lot_LQ Sublot_LQ and Foil_LQ added", 
	expr(
		
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;

		//Checking that Loop Lot_LQ, Sublot_LQ, and Foil_LQ columns are added.
		parsing_table = New Table( "Barcode",
		Add Rows( 4 ),
		New Column( "Barcode",
			Numeric,
			"Continuous",
			Format( "Best", 12 ),
			Set Values( [1332043708, 1332042927, 1332043708, 1332042119] )
		),
		Invisible
		);
			
		loopQualUT:saveTable(parsing_table, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1),"_Barcode_Parse_Pre.jmp", loopQualUT:saveFile);
		
		parsed_table = Barcode_Parse(parsing_table, "Barcode");
		//show(parsed_table);
		col_list_parse = parsed_table << get column names(string);
		//show(col_list_parse);		
		ut assert that(expr(col_list_parse), ut equal to ({"Barcode", "Loop Lot_LQ", "Crossweb_LQ", "Foil_LQ"}));
		loopQualUT:saveTable(parsing_table, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1),"_Barcode_Parse_Post.jmp", loopQualUT:saveFile);




		//Checking that if Loop Lot_LQ, Sublot_LQ, and Foil_LQ columns already exist, they are not added again.
		parsing_table_all_cols = New Table( "Barcode",
		Add Rows( 4 ),
		New Column( "Barcode",
			Numeric,
			"Continuous",
			Format( "Best", 12 ),
			Set Values( [1332043708, 1332042927, 1332043708, 1332042119] )
		),
		New Column( "Loop Lot_LQ",
			Character,
			"Nominal",
			Formula( Substr( Char( :Barcode ), 1, 6 ) )
		),
		New Column( "Crossweb_LQ",
			Character,
			"Nominal",
			Formula( Substr( Char( :Barcode ), 7, 2 ) )
		),
		New Column( "Foil_LQ",
			Character,
			"Nominal",
			Formula( Substr( Char( :Barcode ), 9, 2 ) )
		),
		Invisible
		);
			
		
		loopQualUT:saveTable(parsing_table_all_cols, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1),"_Barcode_Already_Parsed_Pre.jmp", loopQualUT:saveFile);
			
		all_cols_parsed_table = Barcode_Parse(parsing_table_all_cols, "Barcode");;
		//show(all_cols_parsed_table);
		all_cols_there_parse = all_cols_parsed_table << get column names(string);
		//show(all_cols_there_parse);
		ut assert that(expr(all_cols_there_parse), ut equal to ({"Barcode", "Loop Lot_LQ", "Crossweb_LQ", "Foil_LQ"}));
			
		loopQualUT:saveTable(parsing_table_all_cols, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1),"_Barcode_Already_Parsed_Post.jmp", loopQualUT:saveFile);	
	));

ut test(barcodeparseTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Barcode Parse Correct Values", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;

		parsing_table = New Table( "Barcode",
		Add Rows( 4 ),
		New Column( "Barcode",
			Numeric,
			"Continuous",
			Format( "Best", 12 ),
			Set Values( [1332043708, 1332042927, 1332043708, 1332042119] )
		),
		Invisible
		);
			
		loopQualUT:saveTable(parsing_table, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Barcode_Values_Correct_pre.jmp", loopQualUT:saveFile);
				
		parsed_table = Barcode_Parse(parsing_table, "Barcode");
		loop_list = parsed_table:"Loop Lot_LQ"n << get values;
		crossweb_list = parsed_table:Crossweb_LQ << get values;
		foillot_list = parsed_table:Foil_LQ << get values;
		ut assert that(expr(loop_list), ut equal to ({"133204", "133204", "133204", "133204"}));
		ut assert that(expr(crossweb_list), ut equal to ({"37", "29", "37", "21"}));
		ut assert that(expr(foillot_list), ut equal to ({"08", "27", "08", "19"}));	
			
		loopQualUT:saveTable(parsing_table, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Barcode_Values_Correct_post.jmp", loopQualUT:saveFile);
	
	));


		/////////////////////////////////////////////////////////////
		//                filename_parse_func                      //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "H";
loopQualUT:utGroupTest = 0;

ut test(filenameparseTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Loop Lot Filename, Chem Type, Buffer, Run Order, Assay, and Dose Columns added", expr(
		
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;

		//Checking that Loop Lot_Filename, Chem Type, Assay, Buffer, Run Order, Dose columns are added to the table.
		parsing_table = New Table( "FileName",
		Add Rows( 4 ),
		New Column( "FileName",
			Character,
			"Nominal",
			Set Selected,
			Set Values(
				{"4140412_Cl_H22_1.csv", "4140412_Cl_H22_2.csv", "4140412_Cl_H44_3.csv",
				"4140412_Cl_H44_4.csv"}
			)
		),
		Invisible
		);
			
		loopQualUT:saveTable(parsing_table, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1),"_Filename_Parse_Pre.jmp", loopQualUT:saveFile);
		
		parsed_table = filename_parse_func(parsing_table, "FileName");
		//show(parsed_table);
		col_list_parse = parsed_table << get column names(string);
		//show(col_list_parse);		
		ut assert that(expr(col_list_parse), ut equal to ({"FileName", "Loop Lot_Filename", "Chem Type", "Assay", "Buffer", "Run Order", "Dose"}));
		loopQualUT:saveTable(parsing_table, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest),"_Filename_Parse_Post.jmp", loopQualUT:saveFile);




		//Checking that if Loop Lot_LQ, Sublot_LQ, and Foil_LQ columns already exist, they are not added again.
		parsing_table_all_cols = New Table( "FileName",
		Add Rows( 4 ),
		New Column( "FileName",
			Character,
			"Nominal",
			Set Selected,
			Set Values(
				{"4140412_Cl_H22_1.csv", "4140412_Cl_H22_2.csv", "4140412_Cl_H44_3.csv",
				"4140412_Cl_H44_4.csv"}
			)
		),
		New Column("Loop Lot_Filename", 
			Character, 
			Nominal, 
			formula(Word( 1, parse_filenamecol, "_" ));
		),
		New Column("Chem Type", 
			Character, 
			Nominal, 
			formula(Uppercase(Word( 2, parse_filenamecol, "_" )));
		),
		New Column("Buffer", 
			Character, 
			Nominal, 
			formula(Uppercase(Word( 3, parse_filenamecol, "_" )));
		),
		New Column("Run Order", 
			Character, 
			Nominal, 
			formula(Right( Word( 1, parse_filenamecol, "." ), 1 ));
		)
		///Invisible
		);
			
		
		loopQualUT:saveTable(parsing_table_all_cols, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1),"_Filename_Already_Parsed_Pre.jmp", loopQualUT:saveFile);
			
		all_cols_parsed_table = filename_parse_func(parsing_table_all_cols, "FileName");
		//show(all_cols_parsed_table);
		all_cols_there_parse = all_cols_parsed_table << get column names(string);
		//show(all_cols_there_parse);
		ut assert that(expr(all_cols_there_parse), ut equal to ({"FileName", "Loop Lot_Filename", "Chem Type", "Buffer", "Run Order", "Assay", "Dose"}));
			
		loopQualUT:saveTable(parsing_table_all_cols, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest),"_Filename_Already_Parsed_Post.jmp", loopQualUT:saveFile);	
	));

ut test(filenameparseTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_FileName Parse Correct Values", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;

		parsing_table_Cl = New Table( "FileName",
		Add Rows( 4 ),
		New Column( "FileName",
			Character,
			"Nominal",
			Set Selected,
			Set Values(
				{"4140412_Cl_H22_1.csv", "4140412_Cl_H22_2.csv", "4140412_Cl_H44_3.csv",
				"4140412_Cl_H44_4.csv"}
			)
		),
		//Invisible
		);

		loopQualUT:saveTable(parsing_table_Cl, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "FileName_Parse_Correct_Cl_pre.jmp", loopQualUT:saveFile);

		parsed_table_Cl = filename_parse_func(parsing_table_Cl, "FileName");
		loop_list_Cl = parsed_table_Cl:"Loop Lot_Filename"n << get values;
		chemtype_list_Cl = parsed_table_Cl:"Chem Type"n << get values;
		assay_list_Cl = parsed_table_Cl:"Assay"n << get values;
		buffer_list_Cl = parsed_table_Cl:"Buffer"n << get values;
		runorder_list_Cl = parsed_table_Cl:"Run Order"n << get values;
		dose_list_Cl = parsed_table_Cl:"Dose"n << get values;

		ut assert that(expr(loop_list_Cl), ut equal to ({"4140412", "4140412", "4140412", "4140412"}));
		ut assert that(expr(chemtype_list_Cl), ut equal to ({"CL", "CL", "CL", "CL"}));
		ut assert that(expr(assay_list_Cl), ut equal to ([40, 40, 40, 40]));
		ut assert that(expr(buffer_list_Cl), ut equal to ({"H22", "H22", "H44", "H44"}));
		ut assert that(expr(runorder_list_Cl), ut equal to ({"1", "2", "3", "4"}));
		ut assert that(expr(dose_list_Cl), ut equal to ([89, 89, 138, 138]));

		loopQualUT:saveTable(parsed_table_Cl, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "FileName_Parse_Correct_Cl_post.jmp", loopQualUT:saveFile);


		
		parsing_table_Na = New Table( "FileName",
		Add Rows( 4 ),
		New Column( "FileName",
			Character,
			"Nominal",
			Set Selected,
			Set Values(
				{"4140411_NA_H22_1.csv", "4140411_NA_H22_2.csv", "4140411_NA_H44_3.csv",
				"4140411_NA_H44_4.csv"}
			)
		),
		Invisible
		);
		
		loopQualUT:saveTable(parsing_table_Na, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "FileName_Parse_Correct_Na_pre.jmp", loopQualUT:saveFile);
		
		parsed_table_Na = filename_parse_func(parsing_table_Na, "FileName");
		loop_list_Na = parsed_table_Na:"Loop Lot_Filename"n << get values;
		chemtype_list_Na = parsed_table_Na:"Chem Type"n << get values;
		assay_list_Na = parsed_table_Na:"Assay"n << get values;
		buffer_list_Na = parsed_table_Na:"Buffer"n << get values;
		runorder_list_Na = parsed_table_Na:"Run Order"n << get values;
		dose_list_Na = parsed_table_Na:"Dose"n << get values;

		ut assert that(expr(loop_list_Na), ut equal to ({"4140411", "4140411", "4140411", "4140411"}));
		ut assert that(expr(chemtype_list_Na), ut equal to ({"NA", "NA", "NA", "NA"}));
		ut assert that(expr(assay_list_Na), ut equal to ([42, 42, 42, 42]));
		ut assert that(expr(buffer_list_Na), ut equal to ({"H22", "H22", "H44", "H44"}));
		ut assert that(expr(runorder_list_Na), ut equal to ({"1", "2", "3", "4"}));
		ut assert that(expr(dose_list_Na), ut equal to ([125, 125, 167, 167]));
		
		loopQualUT:saveTable(parsed_table_Na, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "FileName_Parse_Correct_Na_post.jmp", loopQualUT:saveFile);		


		
		parsing_table_K = New Table( "FileName",
		Add Rows( 4 ),
		New Column( "FileName",
			Character,
			"Nominal",
			Set Selected,
			Set Values(
				{"4140413_K_H22_1.csv", "4140413_K_H22_2.csv", "4140413_K_H44_3.csv",
				"4140413_K_H44_4.csv"}
			)
		),
		Invisible
		);
			
		loopQualUT:saveTable(parsing_table_K, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "FileName_Parse_Correct_K_pre.jmp", loopQualUT:saveFile);	
		
		parsed_table_K = filename_parse_func(parsing_table_K, "FileName");
		loop_list_K = parsed_table_K:"Loop Lot_Filename"n << get values;
		chemtype_list_K = parsed_table_K:"Chem Type"n << get values;
		assay_list_K = parsed_table_K:"Assay"n << get values;
		buffer_list_K = parsed_table_K:"Buffer"n << get values;
		runorder_list_K = parsed_table_K:"Run Order"n << get values;
		dose_list_K = parsed_table_K:"Dose"n << get values;

		ut assert that(expr(loop_list_K), ut equal to ({"4140413", "4140413", "4140413", "4140413"}));
		ut assert that(expr(chemtype_list_K), ut equal to ({"K", "K", "K", "K"}));
		ut assert that(expr(assay_list_K), ut equal to ([41, 41, 41, 41]));
		ut assert that(expr(buffer_list_K), ut equal to ({"H22", "H22", "H44", "H44"}));
		ut assert that(expr(runorder_list_K), ut equal to ({"1", "2", "3", "4"}));
		ut assert that(expr(dose_list_K), ut equal to ([3, 3, 7, 7]));
			
		loopQualUT:saveTable(parsed_table_K, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "FileName_Parse_Correct_K_post.jmp", loopQualUT:saveFile);	
	));


		/////////////////////////////////////////////////////////////
		//                    LoopQualModal                        //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "i";
loopQualUT:utGroupTest = 0;

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Cl_Window Title Correct", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = current window() << get window title;
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_PassPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		
		ut assert that(Expr(text), ut equal to("CL Loop Qualification Pass/Fail Status"));
		
		//save tables for all 3 configurations.
		loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Pass_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		
	));
	
ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Na_Window Title Correct", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = current window() << get window title;
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Na_PassPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		
		ut assert that(Expr(text), ut equal to("NA Loop Qualification Pass/Fail Status"));
		
		//save tables for all 3 configurations.
		loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_DR_ReportModal_Pass_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_K_Window Title Correct", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = current window() << get window title;
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_K_PassPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		
		ut assert that(Expr(text), ut equal to("K Loop Qualification Pass/Fail Status"));
		
		//save tables for all 3 configurations.
		loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "K_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_K_PassPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "K_DR_ReportModal_Pass_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "K_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "K_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Cl_Window Wording Correct", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[1] << get text;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_PassPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"CL Loop Qualification Pass/Fail Status: \!""));
	
		
		loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal__Pass_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Na_Window Wording Correct", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[1] << get text;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Na_PassPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"NA Loop Qualification Pass/Fail Status: \!""));
	
		loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Na_PassPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_DR_ReportModal__Pass_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_K_Window Wording Correct", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[1] << get text;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_K_PassPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"K Loop Qualification Pass/Fail Status: \!""));
		
		loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "K_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_K_PassPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "K_DR_ReportModal__Pass_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "K_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "K_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Window Pass Wording", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		//Both Fluids Passing in Dose Report
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[2] << get text;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_PassFail, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Pass\!""));
	
		//H22 Passing and H44 Failing in Dose Report.
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[2] << get text;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_FailPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Pass\!""));
		
		//H22 Failing and H44 Passing in Dose Report.
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[2] << get text;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_PassPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Pass\!""));		
		
		//save tables for all 3 configurations. No need to save the other tables in the modal.
		//loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal__Pass_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_FailPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Fail_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassFail, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Pass_Fail_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		
		
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Window Pass Word Color", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		//Both Fluids Passing in Dose Report
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[2] << get color;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_PassFail, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("4"));
	
		//H22 Passing and H44 Failing in Dose Report.
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[2] << get color;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_FailPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("4"));
		
		//H22 Failing and H44 Passing in Dose Report.
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[2] << get color;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_PassPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("4"));		
		
		//save tables for all 3 configurations. No Need to save the other tables passed into the function.
		//loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal__Pass_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_FailPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Fail_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassFail, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Pass_Fail_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		
		
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Window Fail Wording", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		//Both Fluids Fail in Dose Report.
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[2] << get text;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_FailFail, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Fail\!""));	
		
		//save tables for all 3 configurations. No need to save the other tables passed into the function.
		//loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_FailFail, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Fail_Fail_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);

	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Window Fail Word Color", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		//Both Fluids Failing in Dose Report.
		closeModal = Function( {timeout}, {default local},
			s=Schedule(
				timeout,
				Op_Ack << set text("YAS");
				Wait(1);
				text = (current window() << xpath("//TextBox"));
				//show(text[2] << get text);
				status = text[2] << get color;
				print(status);
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
			);
		);
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_FailFail, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("3"));
	
		//save tables for all 3 configurations. No need to save the other tables passed through the function.
		//loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_FailFail, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Fail_Fail_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Window Stays Open on OK Without Initials", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closemodal = Function( {timeout}, {default local},
			s = Schedule(
				timeout, 					
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
				//Show(current window() << get window title);
				If(current window() << get window title == "CL Loop Qualification Pass/Fail Status",
					Print("Modal Stays Open Without Content");
					Op_Ack << set text("YAS");
					(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
					,
					Print("Modal Closes Unexpectedly");
				);
			);	
		);	
		
		closemodal(2);
		
		LoopQualModal(dr_maintable_lytes, dr_Cl_PassPass, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Modal Stays Open Without Content\!""));
		
		loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassPass, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_DR_ReportModal_Pass_Pass_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Na_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Window Closes with Initials", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		closemodal = Function( {timeout}, {default local},
			s = Schedule(
				timeout, 
				Op_ack << set text("YAS");
				Wait(1);		
				(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
				//Show(current window() << get window title);
				If(current window() << get window title == "CL Loop Qualification Pass/Fail Status",
					Print("Modal Stays Open Unexpectedly");
					current window () << close window;
					,
					Print("Modal Closes with Initials")
				);
			)
		);	
		
		closemodal(2);
		
		modalOutput = LoopQualModal(dr_maintable_lytes, dr_Cl_PassFail, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-1);
		ut assert that(Expr(log[1]), ut equal to("\!"Modal Closes with Initials\!""));
		ut assert that(Expr(modalOutput["Op_ack"]), ut equal to("YAS"));
		
		loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassFail, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Pass_Fail_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
	));

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_2 Windows Close with Closing Button", expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;	
			
		closemodal = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				//Show(current window() << get window title);
				Current Window() << close window;
				If(current window() << get window title == "CL Loop Qualification Pass/Fail Status",
					Print("Modal Window Still Open");
					,
					//Show(current window() << get window title);
					Print("Modal Closes with Close Button")
				);
			);
		);

		closemodal(2);
		
		closemodal2 = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				Wait(1);	
				If(current window() << get window title == "User Canceled",
					Current Window() << close window;
					//(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
					If(current window() << get window title == "User Canceled",
						Print("2nd Modal not close correctly")
						,
						print("Cleanup Modal Closes")
					)
					,
					Print("incorrect window current")
				);
			);
		);
		
		closemodal2(10);
		modalOutput = LoopQualModal(dr_maintable_lytes, dr_Cl_PassFail, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-2);
		log2 = GetLog(-1);
		//show(log);
		//show(log2);
		ut assert that(Expr(log[1]), ut equal to("\!"Modal Closes with Close Button\!""));
		ut assert that(Expr(log2[1]), ut equal to("\!"Cleanup Modal Closes\!""));
		ut assert that(Expr(modalOutput), ut equal to(0));
	

		//Not saving the other tables.
		//loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassFail, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Pass_Fail_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);

	));	

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_1 Modal with Close, 1 with OK Button", expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;	
			
		closemodal = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				//Show(current window() << get window title);
				Current Window() << close window;
				If(current window() << get window title == "CL Loop Qualification Pass/Fail Status",
					Print("Modal Window Still Open");
					,
					Print("Modal Closes with Close Button")
				);
			);
		);

		closemodal(2);
		
		closemodal2 = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				wait(1);
				If(current window() << get window title == "User Canceled",
					//Current Window() << close window;
					(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
					If(current window() << get window title == "User Canceled",
						Print("2nd Modal not close correctly")
						,
						print("Cleanup Modal Closes")
					)
					,
					Print("incorrect window current")
				);
			);
		);
		
		closemodal2(10);
		modalOutput = LoopQualModal(dr_maintable_lytes, dr_Cl_PassFail, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-2);
		log2 = GetLog(-1);
		//show(log);
		//show(log2);
		ut assert that(Expr(log[1]), ut equal to("\!"Modal Closes with Close Button\!""));
		ut assert that(Expr(log2[1]), ut equal to("\!"Cleanup Modal Closes\!""));
		ut assert that(Expr(modalOutput), ut equal to(0));
	

		//Not saving the other tables for input.
		//loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassFail, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Pass_Fail_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);

	));	

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_1 Modal with Cancel, 1 with Close Button", expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;	
			
		closemodal = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				//Show(current window() << get window title);
				(Current Window() << xpath( "//ButtonBox[text()='Cancel']" )) << click;
				If(current window() << get window title == "CL Loop Qualification Pass/Fail Status",
					Print("Modal Window Still Open");
					,
					Print("Modal Closes with Close Button")
				);
			);
		);

		closemodal(2);
		
		closemodal2 = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				wait(1);
				If(current window() << get window title == "User Canceled",
					Current Window() << close window;
					//(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
					If(current window() << get window title == "User Canceled",
						Print("2nd Modal not close correctly")
						,
						print("Cleanup Modal Closes")
					)
					,
					Print("incorrect window current")
				);
			);
		);
		
		closemodal2(6);
		modalOutput = LoopQualModal(dr_maintable_lytes, dr_Cl_PassFail, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-2);
		log2 = GetLog(-1);
		//show(log);
		//show(log2);
		ut assert that(Expr(log[1]), ut equal to("\!"Modal Closes with Close Button\!""));
		ut assert that(Expr(log2[1]), ut equal to("\!"Cleanup Modal Closes\!""));
		ut assert that(Expr(modalOutput), ut equal to(0));
	

		//Not saving the other tables for input.	
		//loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassFail, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Pass_Fail_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);

	));	

ut test(reportmodalTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_1 Modal with Cancel, 1 with OK Button", expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;	
			
		closemodal = Function( {timeout}, {default local},
			s = Schedule(
				timeout,
				//Show(current window() << get window title);
				(Current Window() << xpath( "//ButtonBox[text()='Cancel']" )) << click;
				If(current window() << get window title == "CL Loop Qualification Pass/Fail Status",
					Print("Modal Window Still Open");
					,
					Print("Modal Closes with Close Button")
				);
			);
		);

		closemodal(2);
		
		closemodal2 = Function( {timeout}, {default local},
			s = Schedule(
				timeout,	
				Wait(1);
				If(current window() << get window title == "User Canceled",
					//Current Window() << close window;
					(Current Window() << xpath( "//ButtonBox[text()='OK']" )) << click;
					If(current window() << get window title == "User Canceled",
						Print("2nd Modal not close correctly")
						,
						print("Cleanup Modal Closes")
					)
					,
					Print("incorrect window current")
				);
			);
		);
		
		closemodal2(10);
		modalOutput = LoopQualModal(dr_maintable_lytes, dr_Cl_PassFail, dr_Errorsummary_lytes, dr_foilErrorCount_lytes);
		log = GetLog(-2);
		log2 = GetLog(-1);
		//show(log);
		//show(log2);
		ut assert that(Expr(log[1]), ut equal to("\!"Modal Closes with Close Button\!""));
		ut assert that(Expr(log2[1]), ut equal to("\!"Cleanup Modal Closes\!""));
		ut assert that(Expr(modalOutput), ut equal to(0));
	

		//Not saving the other tables for input.	
		//loopQualUT:saveTable(dr_maintable_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_MT_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(dr_Cl_PassFail, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_DR_ReportModal_Pass_Fail_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_Errorsummary_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_ES_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);
		//loopQualUT:saveTable(dr_foilErrorCount_lytes, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1), "Cl_FEC_ReportModal_Pre_Post.jmp", loopQualUT:saveFile);

	));	

		/////////////////////////////////////////////////////////////
		//                Sublot Blocking Function                 //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "J";
loopQualUT:utGroupTest = 0;

ut test(subLotBlockTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Relative-Median-CWCorrection",
	expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		output = subLot2DblockerFunc( table1, "DR Mean 9-10 offline_ar", "Crossweb_LQ", "Foil_LQ", "Dose", "Loop Lot_LQ", "Chem Type", "Exclusion Rationale", "Relative", "Median", "CW Correction" );
		expected = Open(loopQualUT:filePath||"sublotBlocker_base_Rel-Median-CW Corr_expected.jmp",invisible);
		
		compMain = loopQualUT:tableCompare(output,expected);
		
		tableName = table1 << get name;

		ut assert that(Expr(output << get name), ut equal to(tableName));
		ut assert that(Expr(Column(output,ncol(output)) << get name), ut equal to("CW Correction"));
				
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
	)
);

ut test(subLotBlockTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Absolute-Median-FoilCorrection",
	expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		output = subLot2DblockerFunc( table2, "CW Corrected AR_by Median", "Foil_LQ", "Master AR Target", "Dose", "Loop Lot_LQ", "Chem Type", "Exclusion Rationale", "Absolute", "Median", "Foil Correction" );
		expected = Open(loopQualUT:filePath||"sublotBlocker_base2_Absolute-Median-F Corr_expected.jmp",invisible);
		
		compMain = loopQualUT:tableCompare(output,expected);
		
		tableName = table2 << get name;

		ut assert that(Expr(output << get name), ut equal to(tableName));
		ut assert that(Expr(Column(output,ncol(output)) << get name), ut equal to("Foil Correction"));
				
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
	)
);

ut test(subLotBlockTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Relative-Mean-CWCorrection",
	expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		output = subLot2DblockerFunc( table3, "DR Mean 9-10 offline_ar", "Crossweb_LQ", "Foil_LQ", "Dose", "Loop Lot_LQ", "Chem Type", "Exclusion Rationale", "Relative", "Mean", "CW Correction" );
		expected = Open(loopQualUT:filePath||"sublotBlocker_base3_Rel-Mean-CW Corr_expected.jmp",invisible);
		
		compMain = loopQualUT:tableCompare(output,expected);
		
		tableName = table3 << get name;

		ut assert that(Expr(output << get name), ut equal to(tableName));
		ut assert that(Expr(Column(output,ncol(output)) << get name), ut equal to("CW Correction"));
				
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
	)
);

ut test(subLotBlockTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Absolute-Mean-FoilCorrection",
	expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		output = subLot2DblockerFunc( table4, "CW Corrected AR", "Foil_LQ", "Master AR Target", "Dose", "Loop Lot_LQ", "Chem Type", "Exclusion Rationale", "Absolute", "Mean", "Foil Correction" );
		expected = Open(loopQualUT:filePath||"sublotBlocker_base4-Absolute-Mean-F Corr_expected.jmp",invisible);
		
		compMain = loopQualUT:tableCompare(output,expected);
		
		tableName = table4 << get name;

		ut assert that(Expr(output << get name), ut equal to(tableName));
		ut assert that(Expr(Column(output,ncol(output)) << get name), ut equal to("Foil Correction"));
				
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
	)
);


		/////////////////////////////////////////////////////////////
		//                      ModalOutcome                       //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "K";
loopQualUT:utGroupTest = 0;

ut test(modaloutcomeUT, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Operator Signature", expr(
		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;	

		modalresults1 = {Op_Ack = "YAS"};
		DRM = ModalOutcome(modalresults1, dosereport);
		
		OpAckcol = DRM:"Operator Initials"n << get as matrix;
		//show(OpAckcol);
		//two rows for Op_Ack as there's two fluids in the table.
		ut assert that(expr(OpAckcol), ut equal to ({"YAS", "YAS"}));
		loopQualUT:saveTable(DRM, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest), "_Pre_and_Post.jmp", loopQualUT:saveFile);
	));

ut test(modaloutcomeUT, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Date and Time", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;

		modalresults1 = {Op_Ack = "YAS"};
		DRM = ModalOutcome(modalresults1, dosereport);
		//show(modalresults1);
		//show(DRM);

		OpAckcoltd = DRM:"Operator Acknowledgement Date and Time"n << get as matrix;
		//show(OpAckcoltd);

		ut assert that(expr(OpAckcoltd[1]), ut close to (today(), 2));
		ut assert that(expr(OpAckcoltd[2]), ut close to (today(), 2));
		loopQualUT:saveTable(DRM, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest), "_Pre_and_Post.jmp", loopQualUT:saveFile);
	));


		/////////////////////////////////////////////////////////////
		//               Grubbs_Outlier_Detection                  //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "L";
loopQualUT:utGroupTest = 0;

ut test(grubbsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Outliers", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;

		table = Grubbs_Outlier_Detection(outliers, "Value", 0.001);
		
		wait(3);
		row_grubbs = table << get rows where("Exclusion Rationale"n == "NDE - Grubb's");
		row_outliers = table << get rows where("Outlier"n == "Yes");
		number_grubbs = nitems(row_grubbs);
		number_outliers = nitems(row_outliers);
		
		ut assert that(expr(row_grubbs), ut equal to (row_outliers));
		ut assert that(expr(number_grubbs), ut equal to (number_outliers));

		loopQualUT:saveTable(outliers, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest), "_Pre.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(table, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest), "_Post.jmp", loopQualUT:saveFile);
	));

ut test(grubbsTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_No Outliers", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;

		table = Grubbs_Outlier_Detection(nooutliers, "Value", 0.001);
		
		row_grubbs = table << get rows where("Exclusion Rationale"n == "NDE - Grubb's");
		row_outliers = table << get rows where("Outlier"n == "Yes");
		number_grubbs = nitems(row_grubbs);
		number_outliers = nitems(row_outliers);
		
		ut assert that(expr(number_grubbs), ut equal to (number_outliers));

		loopQualUT:saveTable(nooutliers, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest), "_Pre.jmp", loopQualUT:saveFile);
		loopQualUT:saveTable(table, loopQualUT:savePath, loopQualUT:utGroup||Char(loopQualUT:utGroupTest), "_Post.jmp", loopQualUT:saveFile);
	));


		/////////////////////////////////////////////////////////////
		//                     masterTarget                        //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "M";
loopQualUT:utGroupTest = 0;

ut test(masterTargetTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Master AR Target", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		actual = masterTarget(table2, "DR Mean 6-7 offline_ar", "Dose", "Exclusion Rationale");
		
		compare_tables = loopQualUT:tableCompare(actual, table1);
		
		//the below may work better than the above through diff JMP versions
		ut assert that(Expr(compare_tables[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compare_tables[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compare_tables[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compare_tables[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compare_tables[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
	));


		/////////////////////////////////////////////////////////////
		//                   totalLoopReport_2                     //
		/////////////////////////////////////////////////////////////
loopQualUT:utGroup = "N";
loopQualUT:utGroupTest = 0;

ut test(loopreportTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_NA total loop report", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		actual = totalLoopReport_2(table1, "DR Mean 6-7 offline_ar", "Crossweb_LQ", "Foil_LQ", "Dose", "Loop Lot_LQ", "Chem Type");

		compMain = loopQualUT:tableCompare(actual[1],table1);
		compSumm = loopQualUT:tableCompare(actual[2],table2);
		compNDE = loopQualUT:tableCompare(actual[3],table3);
		compSD = loopQualUT:tableCompare(actual[4],table4);

		//compare Main tables
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//compare summary tables
		ut assert that(Expr(compSumm[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compSumm[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSumm[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//compare NDE tables
		ut assert that(Expr(compNDE[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compNDE[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compNDE[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//compare SD tables
		ut assert that(Expr(compSD[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compSD[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSD[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSD[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSD[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
	));


ut test(loopreportTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_Cl total loop report", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		actual = totalLoopReport_2(table6, "DR Mean 9-10-11 offline_ar", "Crossweb_LQ", "Foil_LQ", "Dose", "Loop Lot_LQ", "Chem Type");
		show(actual);

		compMain = loopQualUT:tableCompare(actual[1],table6);
		compSumm = loopQualUT:tableCompare(actual[2],table7);
		compNDE = loopQualUT:tableCompare(actual[3],table8);
		compSD = loopQualUT:tableCompare(actual[4],table9);

		//compare Main tables
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//compare summary tables
		ut assert that(Expr(compSumm[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compSumm[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSumm[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//compare NDE tables
		ut assert that(Expr(compNDE[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compNDE[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compNDE[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//compare SD tables
		ut assert that(Expr(compSD[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compSD[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSD[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSD[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSD[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
	));


ut test(loopreportTC, loopQualUT:utGroup||Char(loopQualUT:utGroupTest+1)||"_QSDMA total loop report", expr(

		loopQualUT:utGroupTest = loopQualUT:utGroupTest + 1;
		
		actual = totalLoopReport_2(table12, "Corrected AR", "Crossweb_LQ", "Foil_LQ", "Panel Dose", "Loop Lot_LQ", "Chem Type");

		compMain = loopQualUT:tableCompare(actual[1],table12);
		compSumm = loopQualUT:tableCompare(actual[2],table13);
		compNDE = loopQualUT:tableCompare(actual[3],table14);
		compSD = loopQualUT:tableCompare(actual[4],table15);

		//compare Main tables
		ut assert that(Expr(compMain[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compMain[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compMain[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compMain[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compMain[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//compare summary tables
		ut assert that(Expr(compSumm[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compSumm[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSumm[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSumm[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//compare NDE tables
		ut assert that(Expr(compNDE[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compNDE[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compNDE[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compNDE[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
		
		//compare SD tables
		ut assert that(Expr(compSD[2] << Are Data Different), ut equal to(0));
		ut assert that(Expr(compSD[2] << Get columns properties differences), ut empty());
		ut assert that(Expr(compSD[2] << Get columns attributes differences), ut empty());
		ut assert that(Expr(compSD[2] << Get unmatched columns list), ut empty());
		ut assert that(Expr(compSD[2] << Get Columns List( "Mismatched Data Type" )), ut empty());
	));


/////////////////////////////////////////////////////////////
//                                                         //
//          Finishing Off                                  //
//                                                         //
/////////////////////////////////////////////////////////////

Match(loopQualUT:saveFile,
	0, loopQualUT << delete
	,
	1,
	ut global reporter:save report(loopQualUT:savePath||loopQualUT:reportName);
	loopQualUT << delete;
);
show((today() - t1)/60);