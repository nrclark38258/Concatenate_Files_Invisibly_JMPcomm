//Author(s)
//SDarling, NClark, ZHelm
//IDEXX Laboratories, Inc.
//Westbrook, ME 04092
//Tool Calculates Loop Qual Results for Lytes.

//------------------Revision History for both script and Help File--
//	2.0.1  SDarling 060222
//		-> created a subset of the starting table to do analysis in stitching. This is the table analysis happens on. The original remains open upon cleanup.
//	1.0.13 NClark 020322
//		-> Added code to remove old loop qual addin (before assays combined)
//	1.0.12 SDarling 011322
//		-> moved masterTargetfunction to tested area
//		-> moved totalLoopReport_2 to tested area
//		-> moved stitchingFunct to tested area
//	1.0.11 NClark 121721
//		-> small edits to masterTarget fuction for smooth performance
//	1.0.10 SDarling 121721
//		-> updated mastertarget function to create a mean per fluid level and update using that table.
//	1.0.9 NClark 121721
//		-> updated stitching function to fix bug where AR column name not updated for NA or K (dry reads 6-7)
//		-> created master target function to calculate the master target without NDEs as super large NDEs could skew target
//		-> updated totalLoopReport_2 to incorporate master target function where old formula existed
//	1.0.8 NClark 121521
//		-> updated runofflinealg function to be dynamic for columns from the offline algorithm and renaming them based on how they come in from the offline algorithm
//		-> modified stitching function for new names of AR columns coming from offline algorithm
//	1.0.7 SDarling 121521
//		-> updated Grubbs_Outlier_Detection to include ^tablename^ in the parsing of ycol
//		-> moved Grubbs_Outlier_Detection to the tested section
//		-> moved modaloutcome to the tested section
//	1.0.6 NClark 121421
//		-> updated loopqualmodal to return 0 rather than stop() if user closes/cancels pass/fail dialog
//		-> updated stitching to handle that return of 0 to not call modaloutcome and return 0
//		-> updated beta limit to be 4 weeks
//	1.0.5 SDarling 121321
//		-> Added try statement to stitching function to incorporate QSDMA workflow.
//		-> Added 2 try statements for summary tables in totalLoopReport_2 as Lytes includes "Buffer" column by QSDMA does not.
//		-> Added an if statement in totalLoopReport_2 to accomodate lytes loop lot column name vs SDMA loop lot column name.
//	1.0.4 NClark 121021
//		-> moved functions around from unit testing
//	1.0.3 NClark, SDarling 120921
//		-> Moved functions around to track testing
//		-> added Path parameter to prep4offline and runofflinealg
//		-> passed path into above in stitchingfunction
//		-> updated prep4offline to use path input as opposed to getting default directory path
//		-> updated filenameparse for stronger filename variable (replaced tablename:parse... with Colulmn(tablename, colname))
//		-> pass path variable into run_offline_algorithm in helpers file
//		-> updated LoopQualModal to have dynamic max x and y axis values per assay.
//		-> moved Barcode_Parse and filename_parse_func to the tested section.
//		-> changed throw() to stop() in LoopQualModal function.
//		-> updated stitch to return unchosen table
//	1.0.2 NClark, SDarling 120821
//		-> updated prep function to create columns for correct scalar and false light for file (mutliple scalar/fl values in table although only one assay represented)
//		-> updated stitching function shifted hidden colums to end to make for a cleaner table
//		-> updated stitching function added fail/fail fail/fail to options to default to 9-10 dry reads when picking 'best' dry read option for CL
//		-> fiber lot and buffer lot removed from filename_parse_func.
//		-> Loop Lot_Filename, ChemType, Buffer, and Pouch Number formulas adjusted accordingly in function filename_parse_func.
//		-> Pouch Number column name changed to Run Order in function filename_parse_func.
//		-> updated totalLoopReport_2 and names of tables now contain Loop lot_chem name in title (except for the main starting table)
//		-> updated stitchingFunc for CL the unchosen dry read method maintains its table and is named as such for troublshooting
//		-> fixed a mis-association with NDEs and the foil the occurred in by updating how a split function worked in totalLoopReport_2
//		-> updated totalLoopReport_2 to not make summaries with, or move, buffer or fiber lot columns as those will no longer be part of the table
//	1.0.1 NClark 120721
//		-> moved functions around which had unit tests created
//		-> added to loop qual modal function a catch to close all tables if 'cancel' hit and throw script
//		-> updated modaloutcome function to reflect changes in loop qual modal function
//		-> updated calling of the above functions in stitching function
//		-> moved 'potentially archive' functions to archive_Functions.jsl file
//  1.0.0 SDarling, ZHelm, NClark 120321
//		-> 1st Release
//
//------------------------------------------------------------------

Names Default To Here( 1 );

//-----------Variable Declarations (above Main for easy access)--

	If(HostIs("MAC"),
		u = Get Environment Variable("USER");
		,
		u = Get Environment Variable("USERNAME");
	);
	addinID = "com.idexx.RoswellQCTools_LoopQualification";
	//addinLib = "com.idexx.assayDevLibraries2";
	//updateIDs = {"com.idexx.assayDevLibraries2","com.idexx.RoswellQCTools_LoopQualification"};
	betaLimitwk = 4; // with this timeline, not much time for beta testing
	minJMPver = "15.2";					

	//columm matching for offline algorithm to work
	offAlgParamMatch = {
		"Assay","IN_ASSAY",
		"Dilution Parts","IN_DILUTION",
		"False Light","IN_FALSE_LIGHT",
		"Gain","IN_GAIN",
		"Offset","IN_OFFSET",
		"NumWL","IN_WAVELENGTH_COUNT",
		"CenterWL1","IN_WAVELENGTH1",
		"CenterWL2","IN_WAVELENGTH2",
		"DryStart","IN_DRY_START",
		"DryEnd","IN_DRY_END"
	};
	offAlgTimeseriesMatch  = {"median read time",
		"ReadFlag",
		"RD",
		"RD2"
	};

	path = ConvertFilePath(GetDefaultDirectory());

//-----------/Variable Declarations-----------------------


include(path||"offlineAlgorithm\nrc_offline_alg_helpers.jsl");
include(path||"Utilities\utilities.jsl");

////////////////////////////////////////
//                                    //
//            Functions               //
//                                    //
////////////////////////////////////////

	/////////////////////////////////////////
	//       Support functions             //
	/////////////////////////////////////////
//TESTED FUNCTIONS
checkVersion = Function( {minVer},
	{default local},
	currVer = JMP Version();
	currWords = words(currVer,".");
	minWords = words(minVer,".");
	minBackHalf = If(nitems(minWords)==1,"0",concatitems(minWords[2::nitems(minWords)],""));
	backHalf = If(nitems(currWords)==1,"0",concatitems(currWords[2::nitems(currWords)],""));
	newNumVer = Num(currWords[1]||"."||backHalf);
	newMinVer = Num(minWords[1]||"."||minBackHalf);
	
	If(newNumVer >= newMinVer, Return(1),Return(0));
);

wrongVer = Function( {maxVer},
	{Default Local},
	New Window( "Requires JMP " || Char( maxVer ),
		<<Modal,
		Text Box( "This addin requires the used of JMP " || Char( maxVer ) || "+" ),
		Button Box( "OK" )
	)
);

betaTestCheck = Function({betaTimeWk,state = "",buildDate=0},{default local},
	//state and buildDate parameters only used for testing purposes
	If(state != "" & buildDate != 0, //assumes beta inacted and builddate number will be used
		If(IsMissing(Num(buildDate)),Today(),Num(buildDate));//defaults to build date of today if improper builddate used
		if(
			Today() > (buildDate + InWeeks(betaTimeWk)), passBeta = 0, passBeta = 1
		);
		expDate = buildDate + InWeeks(betaTimeWk);
		,
		//Will pass if Beta in date OR if addin not in Beta (TEST) phases
		path = ConvertFilePath(GetDefaultDirectory());
		//customMetadata_aa = Include( "D:\JSL Development\Official JMP Addin Working\Loop Qual swt-xxx-yyy\customMetadata.jsl" );
		customMetadata_aa = Include( path||"customMetadata.jsl" );
		state = customMetadata_aa["state"];
		buildDate = customMetadata_aa["buildDate"];
		If(
			state == "TEST",
			if(
				Today() > (buildDate + InWeeks(betaTimeWk)), passBeta = 0, passBeta = 1
			);
			expDate = buildDate + InWeeks(betaTimeWk);
			,
			passBeta = 1;
			expDate = buildDate + InWeeks(betaTimeWk);
		);
	);
	Return(passBeta,expDate)
);

betaFailWindow = Function({expirationDate},{default local},
	longDate = MDYHMS(expirationDate);
	New Window( "Beta Version Expired",
		<< Modal,
		Text Box( "Beta expired on "||longDate, 
			<< Set Font Style( "bold" ), 
			<< Set Font Size( 12 ) 
		),
		Text Box( "Please contact author for new release", 
			<< Set Font Size( 12 ) 
		),
		Text Box( "" ), 
		Button Box( "OK" ),
	);
);

chemistry_information = Function({}, {default local},
	chem_info = associative array(
		{
			{40,associative array(
					{
						{"Chem Type", "CL"}, 
						{"Gain SD", 0},
						{"Offset SD", 0},
						{"Outlier Threshold - Loop", 22},
						{"Outlier Threshold - Foil", 2},
						{"H22", 89},
						{"H44", 138},
						{"Alpha", "0.01"},
						{"Dose Range", [50 160]},
						{"Dose SD", [1.25 4]}
					}	
				)
			}, 
			{41, associative array(
					{
						{"Chem Type", "K"}, 
						{"Gain SD", 0},
						{"Offset SD", 0},
						{"Outlier Threshold - Loop", 22},
						{"Outlier Threshold - Foil", 2},
						{"H22", 3},
						{"H44", 7},
						{"Alpha", "0.01"},
						{"Dose Range", [0.8 3 5.9 10]},
						{"Dose SD", [0.13 0.13 0.1475 0.25]}
					}	
				)
			},
			{42, associative array(
					{
						{"Chem Type", "NA"}, 
						{"Gain SD", 0},
						{"Offset SD", 0},
						{"Outlier Threshold - Loop", 22},
						{"Outlier Threshold - Foil", 2},
						{"H22", 125},
						{"H44", 167},
						{"Alpha", "0.01"},
						{"Dose Range", [85 180]},
						{"Dose SD", [2 2]}
					}	
				)
			},
			{4, associative array(
					{
						{"Chem Type", "SDMA"}, 
						{"Gain SD", 0.021},
						{"Offset SD", 10},
						{"Outlier Threshold - Loop", 10},
						{"Outlier Threshold - Foil", 100},
						{"Alpha", "0.01"},
						{"Dose Range", [0 5 15 18 25 50 100]},
						{"Dose SD", [3 1.5 1.5 1.7 2.25 5 10]}
					}	
				)
			}
		}
	);
	Return(chem_info);
);

assayTypes = Function({},{default local},
	assayTyp = Associative Array(
		{
			{"GLU",00},
			{"BUN",01},
			{"CA",03},
			{"URIC",05},
			{"TP",06},
			{"TRIG",07},
			{"CHOL",08},
			{"ALB",09},
			{"NH3",10},
			{"PHOS",12},
			{"TBIL",14},
			{"CREA",15},
			{"FRU",16},
			{"CRP",17},
			{"SDMA",18.04},
			{"BA",21},
			{"PROG",23},
			{"PHBR",25},
			{"TT4",28.30},
			{"MG",32},
			{"LAC",35},
			{"CL",40},
			{"K",41},
			{"NA",42},
			{"UPRO",54},
			{"ALTV",56},
			{"TCO2",57},
			{"LIPA",59},
			{"AMYL",60},
			{"ALT",62},
			{"LDH",63},
			{"CK",64},
			{"ALKP",65},
			{"GGT",67},
			{"UCRE",70},
			{"AST",73},
			{"WRS",90},
			{.,-999}
		}
	);
	Return(assayTyp)
);

hideProgCurveColumns = Function({mainTable},{default local},
	colList = {
		:"24"n,
		:"25"n,
		:"26"n,
		:"27"n,
		:"28"n,
		:"29"n,
		:"30"n,
		:"31"n,
		:"32"n,
		:"33"n,
		:"34"n,
		:"35"n,
		:"36"n,
		:"37"n,
		:"38"n,
		:"39"n,
		:"40"n,
		:"41"n,
		:"42"n,
		:"43"n,
		:"44"n,
		:"45"n,
		:"46"n,
		:"47"n,
		:"48"n,
		:"49"n,
		:"50"n,
		:"51"n,
		:"52"n,
		:"53"n,
		:"54"n,
		:"55"n,
		:"56"n,
		:"57"n,
		:"58"n,
		:"59"n,
		:"60"n,
		:"61"n,
		:"62"n,
		:"63"n,
		:"64"n,
		:"65"n
	};
	
	For(i=1,i<=nitems(colList),i++,
		Column(mainTable,colList[i]) << hide(1);
	);
	mainTable << group columns("ProgCurveCols", colList);
	mainTable << move column group(To last, "ProgCurveCols");

	Return(mainTable);
);

fileVsBCRloopLotCheck = Function({mainTable}, {default local},
	temp = mainTable << new column("loop match", numeric, continuous,
		Formula(
			If(Right(:"Loop Lot_Filename"n,6) == :"Loop Lot_LQ"n, "Yes", "No")
		)
	);
	temp << delete formula;
	loopMatch = Associative Array( temp << get as matrix ) << get keys;
	mainTable << delete column(temp);
	
	If(nitems(loopMatch) == 2 | loopMatch[1] == "No",
		Return(0)
		,
		Return(1)
	);
);

loopNumNotMatchBCR = Function({},{default local},
	New Window( "Loop Lot Mismatch",
		<< Modal,
		Text Box( "Loop Lot coded in filename does not match barcode for one or more files", 
			<< Set Font Style( "bold" ), 
			<< Set Font Size( 12 ),
			<< Set Wrap (1000)
		),
		Text Box( "Please fix discrepancies and proceed",
			<< Set Font Style( "bold" ),
			<< Set Font Size( 10 ),
		),
		Text Box( "" ),
		Text Box( 
			"Last 6 digits of filename Loop Lot must match barcode 1st 6 digits",
			<< Font Color("red"),
			<<setfontstyle( "bold" ),
			<<setfontsize( 10 ),
			<< Set Wrap(1000)
		),
		Text Box( "" ), 
		Button Box( "OK" ),
	);
);

userCanceled = Function({},{default local},
	New Window( "User Canceled",
		<< Modal,
		Text Box( "User Canceled at final status window", 
			<< Set Font Style( "bold" ), 
			<< Set Font Size( 12 ),
			<< Set Wrap (1000)
		),
		Text Box( "Please start over",
			<< Set Font Style( "bold" ),
			<< Set Font Size( 10 ),
		),
		Text Box( "" ),
		Button Box( "OK" ),
	);
);

//parse the barcode to get loop lot number, foil number, and sublot number.
Barcode_Parse = Function({tablename, barcodecol}, {default local},
	//tablename = current data table();
	//barcodecol = "Barcode";
	parse_barcodecol = Parse( Eval Insert( ":\!"^barcodecol^\!"n" ) );
	//show(parse_barcodecol);
	
	collist = tablename << get column names(string);
	//show(collist);
	
	if(!contains(collist, "Loop Lot_LQ"),
		tablename << New Column("Loop Lot_LQ", Character, Nominal, formula( Substr( Char( :Barcode ), 1, 6 )));
	);

	if(!contains(collist, "Crossweb_LQ"),
		tablename << New Column("Crossweb_LQ", Character, Nominal, formula( Substr( Char( :Barcode ), 7, 2 )));
	);

		
	if(!contains(collist, "Foil_LQ"),
		tablename << New Column("Foil_LQ", Character, Nominal, formula( Substr( Char( :Barcode ), 9, 2 ) ));
	);	
	
	tablename:"Loop Lot_LQ"n << delete property(Formula);
	tablename:"Crossweb_LQ"n << delete property(Formula);
	tablename:"Foil_LQ"n << delete property(Formula);
	
	return(tablename);	
);

//filename parse for lytes. filename requires loop lot number_chem type_fiber lot_buffer_buffer lot_pouch number
filename_parse_func = Function({tablename, filenamecol}, {default local},
	//tablename = current data table();
	//filenamecol = "File Name";
	
	//setting variables
	parse_filenamecol = Parse( Eval Insert( ":\!"^filenamecol^\!"n" ) );
	colNamefilename = Eval Insert( ":\!"^filenamecol^\!"n" );
	
	
	collist = tablename << get column names(string);
	//show(collist);
	
	//add filename parsed columns if they do not already exist.
	if(!contains(collist, "Loop Lot_Filename"),
		tablename << New Column("Loop Lot_Filename", 
			Character, 
			Nominal, 
			formula(Word( 1, parse_filenamecol, "_" ));
		);
	);

	if(!contains(collist, "Chem Type"),
		tablename << New Column("Chem Type", 
			Character, 
			Nominal, 
			formula(Uppercase(Word( 2, parse_filenamecol, "_" )));
		);
	);
	
	//variables to get Assay Number
	//filename = tablename:parse_filenamecol[1];
	filename = Column(tablename, filenamecol)[1];
	assayTypeToCode = assayTypes();
	chemTypeFromFileName = Uppercase(Word(2,filename,"_"));
	
	//variables to get Dose based on Assay Number
	chem_info = chemistry_information();
	
	if(!contains(collist, "Assay"),
		tablename << New Column("Assay", Numeric, Nominal, 
			<< set each value (assayTypeToCode[chemTypeFromFileName]);
		);
	);	


	if(!contains(collist, "Buffer"),
		tablename << New Column("Buffer", 
			Character, 
			Nominal, 
			formula(Uppercase(Word( 3, parse_filenamecol, "_" )));
		);
	);

	
	if(!contains(collist, "Run Order"),
		tablename << New Column("Run Order", 
			Character, 
			Nominal, 
			formula(Right( Word( 1, parse_filenamecol, "." ), 1 ));
		);
	);
	
	if(!contains(collist, "Dose"),
		tablename << New Column("Dose", 
			Numeric, 
			Continuous, 
			formula(
				Match( assayTypeToCode[chemTypeFromFileName],
					40, Match( "Buffer"n, "H22", chem_info[40]["H22"], "H44", chem_info[40]["H44"] ),
					41, Match( "Buffer"n, "H22", chem_info[41]["H22"], "H44", chem_info[41]["H44"] ),
					42, Match( "Buffer"n, "H22", chem_info[42]["H22"], "H44", chem_info[42]["H44"] )
				);
			);
		);
	);
	
	//delete formulas for the columns added.
	tablename:"Loop Lot_Filename"n << delete property(Formula);
	tablename:"Chem Type"n << delete property(Formula);
	tablename:"Assay"n << delete property(Formula);
	tablename:"Buffer"n << delete property(Formula);
	tablename:"Run Order"n << delete property(Formula);
	tablename:"Dose"n << delete property(Formula);

	return(tablename);

);

//Outlier detection uses Grubbs criteria.
Grubbs_Outlier_Detection = Function({tablename, yCol, alpha}, {default local},
	//variable names for troubleshooting inside function.
	//tablename = current data table();
	//yCol = "Corrected AR";
	//alpha = 0.001;
	//dosecol = "Panel Dose";

	//parse the input variables.
	parse_yCol = Parse( Eval Insert( "^tablename^:\!"^yCol^\!"n" ) );
	//show(parse_yCol);

	//create exclusion column. Do not add if one exists.
	collist = tablename << get column names(string);
	//show(collistsubfoil);

	//add exclusion rationale column.
	if(!contains(collist, "Exclusion Rationale"),
		tablename << New Column("Exclusion Rationale", Character, Nominal);
	);
	
	g = 1;
	g0 = 0;
	i=0;
	While(g > g0 &  i < 10,
		//create distribution of AR.
		dist = tablename << Distribution(
			Y(parse_yCol),
			Normal Quantile Plot(1),
			Fit Distribution( Normal( Goodness of Fit(1) ) )
		);
		distr = dist << Report;

		y_values = parse_yCol << Get As Matrix;
		exRows = tablename << Get Excluded Rows();
		y_values[exRows] = [];
		n = N Row(y_values);

		//tquantile and g/g0 calcs.
		t0Sqr =  t Quantile( 1 - alpha/(2*n), n-2 )^2;
		g = Maximum( Abs( y_values - Mean( y_values ) ) ) / Std Dev( y_values );
		g0 = ((n-1)/Sqrt(n)) * Sqrt( t0Sqr / (n - 2 + t0Sqr) );
	
		distr<<close window();
		//show(t0Sqr);
		//show(g);
		//show(g0);
		//show(i);
		if(
			g>g0,
			//print("true");
			Summarize(tablename, maxvalue=Max(parse_yCol));
			Summarize(tablename, minvalue=Min(parse_yCol));
			Summarize(tablename, meanvalue=Mean(parse_yCol));
			//show(maxvalue, minvalue, meanvalue);
			
			if((maxvalue-meanvalue)>(meanvalue-minvalue),
				print("max value greater");
				tablename << select where(parse_yCol==maxvalue) << hide(1) << exclude(1);
				row = tablename << get rows where(Selected());
				//show(row);
				For(i=1, i<=nrow(row),i++,
					tablename:Name("Exclusion Rationale")[row[i]] = tablename:Name("Exclusion Rationale")[row[i]] ||"NDE - Grubb's";
					show(i);
				);
				,
				print("min value greater");
				tablename << select where(parse_yCol==minvalue) << hide(1) << exclude(1);
				row = tablename << get rows where(Selected());
				//show(row);
				For(i=1, i<=nrow(row),i++,
					tablename:Name("Exclusion Rationale")[row[i]] = tablename:Name("Exclusion Rationale")[row[i]] ||"NDE - Grubb's";
					//show(i);
				);
			);
		);
		
		i++;
		//g=1;
		//g0=1;
	);
	Return(tablename);
);

masterTarget = Function({tableName,arColumn,fluidColumn,exclusionColumn},{default local},
	/*
	tableName = currentdatatable();
	arColumn = "DR Mean 6-7 offline_ar";
	fluidColumn = "Dose";
	exclusionColumn = "Exclusion Rationale";
	*/
	nameFluid = Eval Insert( ":\!"^fluidColumn^\!"n" );
	
	subDt = tableName << Subset(
		All rows,
		columns( EvalList({arColumn,fluidColumn,exclusionColumn}) ),
		private
	);
	subDt << selectwhere( !IsMissing(AsColumn(exclusionColumn)) ) << delete rows;
	
	sumDt = subDt << Summary(
		Group(fluidColumn),
		Mean(arColumn),
		Freq("None"),
		Weight("None"),
		private
	);
	
	newCol = "Mean("||arColumn||")";
	sumDt << Delete Columns("N Rows");

	sumDt:"newCol"n << Set Name("Master AR Target");
	
	tableName << Update(
		With(sumDt),
		Match Columns(
			Parse(nameFluid) = Parse(nameFluid)
		)
	);
	Close(subDt,nosave);
	Close(sumDt,nosave);
	
	Return(tableName)
);

///// UNtested Support Functions below
	//checks for those columns. update for LYTEs.
ColCheck = Function({tablename}, {default local},
	dt = tablename;
	//dt = current data table();
	starting_col_list = dt << get column names(string);
	needed_columns = {"Loop Lot", "Crossweb_LQ", "Corrected AR", "Panel Lot", "Panel Dose", "Instrument ID"};
	missing_cols = {};

	For(i=1,i<=nitems(needed_columns),i++,
		if(
			Contains(starting_col_list,needed_columns[i]) > 0, Empty()
			,
			insertInto(missing_cols,needed_columns[i]);
			Col_missing_Funct();
			Return(0),
		);
	);
	Return(dt);
);

	//Needs updating related to the columns needed.
Col_missing_Funct = Function({},
	New Window( "Necessary Columns Not Present",
		<< Modal,
		Text Box( "One or more necessary columns for analysis are not present.", 
			<< Set Font Style( "bold" ), 
			<< Set Font Size( 12 ) 
		),
		Text Box( "Check for the following columns in the table - Case matters!",
			<< Set Font Style( "bold" ),
			<< Set Font Size( 10 ),
		),
		Text Box( 
			ConcatItems({"Loop Lot", "Crossweb_LQ", "Corrected AR", "Panel Lot", "Panel Dose", "Instrument ID"},", "), << Font Color("red"), <<setfontstyle( "bold" ), <<setfontsize( 10 )
		),
		Text Box( "" ), 
		Button Box( "OK" ),
	);
);

	//checks for necessary column types. update for LYTEs.
Col_type_Funct = Function({},
	New Window( "Columns Are Not The Correct Data Type or Modeling Type",
		<< Modal,
		<< Return Result,
		Text Box( "One or more columns are not the correct data type or modeling type for analysis.", 
			<< Set Font Style( "bold" ), 
			<< Set Font Size( 12 ) 
		),
		Text Box( "Check for the following column data types and modeling types in the table:",
			<< Set Font Style( "bold" ),
			<< Set Font Size( 10 ),
		),
		Text Box( 
			"   Loop Lot: Numeric, Continuous
			Sub Lot_LQ: Character, Nominal
			Corrected AR: Numeric, Continuous
			Panel Lot: Character, Nominal
			Panel Dose: Numeric, Continuous
			Instrument ID: Character, Nominal", 
			<< Font Color("red"), 
			<< Set Font Style( "bold" ), 
			<< Set Font Size( 10 ),
		),
		Text Box( "" ), 
		Button Box( "OK" ),
	);
);



////////// End Support Functions ////////////
    


    /////////////////////////////////////////
	//       Main Functions                //
	/////////////////////////////////////////

// TESTED Main Functions
linearFitadder = Function( {table, respCol, posCol, fluidCol, slideLotvar, chemTypecol, lowmSpec, highmSpec},
	{default Local}, 
	
	/*table = the loop qual data table
	posCol = the sub lot positions are going to correct around
	respCol = intended to be AR
	fluidCol = to cover in the event we have multiple fluid levels in the data this identifies unique fluids
	slideLotvar = the slide lot that excludes the sublot field
	cont = the type of sublot pattern we are correcting for*/
	
	parseColNamesublot = Parse( Eval Insert( ":name(\!"^posCol^\!" )" ) );
	parseColNamedose = Parse( Eval Insert( ":name(\!"^fluidCol^\!" )" ) );
	parseColNameresponse = Parse( Eval Insert( ":name(\!"^respCol^\!" )" ) );
	parseColNamecoating = Parse( Eval Insert( ":name(\!"^slideLotvar^\!" )" ) );
	parseColNameresponsemean = Parse( Eval Insert( ":name(\!"Mean(\!^respCol^\!)\!" )" ) );
	parseColNamechem = Parse( Eval Insert( ":name(\!"^chemTypecol^\!" )" ) );
	
	colNamechem = Eval Insert( ":name(\!"^chemTypecol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	colNamesublot = Eval Insert( ":name(\!"^posCol^\!" )" );
	colNameresponse = Eval Insert( ":name(\!"^respCol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	
	table << New Column( "Sub Lot Condition N",
		Numeric,
		Continous,
		Set Formula( Col Number( parseColNameresponse, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "sumYi",
		Numeric,
		Continuous,
		Set Formula( Col Sum( parseColNameresponse, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "sumXi",
		Numeric,
		Continuous,
		Set Formula( Col Sum( parseColNamedose, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "sumXi*Yi",
		Numeric,
		Continuous,
		Set Formula( Col Sum( parseColNamedose * parseColNameresponse, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "sumXi2",
		Numeric,
		Continuous,
		Set Formula( Col Sum( parseColNamedose ^ 2, parseColNamesublot, parseColNamecoating, parseColNamechem ) )
	);
	table << New Column( "tempa", Numeric, Continuous, Set Formula( :sumXi / :Sub Lot Condition N ) );
	table << New Column( "coeffb", Numeric, Continuous, Set Formula( -1 * :tempa / (-1 * :tempa * :sumXi + :sumXi2) ) );
	table << New Column( "coeffa", Numeric, Continuous, Set Formula( (1 - :coeffb * :sumXi) / :Sub Lot Condition N ) );
	table << New Column( "coeffd", Numeric, Continuous, Set Formula( 1 / (-1 * :tempa * :sumXi + :sumXi2) ) );
	table << New Column( "coeffc", Numeric, Continuous, Set Formula( -1 * (:coeffd * :sumXi) / :Sub Lot Condition N ) );
	table << New Column( "Offset Calc", Numeric, Continuous, Set Formula( :coeffa * :sumYi + :coeffb * :Name( "sumXi*Yi" ) ) );
	table << New Column( "Gain Calc", Numeric, Continuous, Set Formula( :coeffc * :sumYi + :coeffd * :Name( "sumXi*Yi" ) ) );
	table << New Column( "Gain Check", Numeric, Nominal, Set Formula( If( lowmSpec <= :Gain Calc <= highmSpec, 0, 1 ) ) );
	
	Column( table, "Gain Calc" ) << Set Name( "Gain Calc_" || posCol );
	Column( table, "Offset Calc" ) << Set Name( "Offset Calc_" || posCol );
	Column( table, "Gain Check" ) << Set Name( "Gain Check_" || posCol );
	
	Column( table, "Gain Calc_" || posCol ) << Delete Formula;
	Column( table, "Offset Calc_" || posCol ) << Delete Formula;
	Column( table, "Gain Check_" || posCol ) << Delete Formula;
	
	table << Delete Columns( "Sub Lot Condition N", "sumYi", "sumXi", "sumXi*Yi", "sumXi2", "tempa", "coeffb", "coeffa", "coeffd", "coeffc" );

	Return(table)
);

	//produces the product requirement with the incorporated n for the test
productReqsFunc = Function( {table, doseCol, assayCol, nCol, alphaVal},
	{default local}, 
	
	parseColNamedose = Parse( Eval Insert( ":name(\!"^doseCol^\!" )" ) );
	parseColNameassay = Parse( Eval Insert( ":name(\!"^assayCol^\!" )" ) );
	parseColNameN = Parse( Eval Insert( ":name(\!"^nCol^\!" )" ) );
	
	table << New Column( "Requirement",
		Numeric,
		Continuous,
		Set Formula(
			Match( parseColNameassay,
				"NA", Interpolate( parseColNamedose, [85 180], [2 2] ),
				"K", Interpolate( parseColNamedose, [0.8 3 5.9 10], [0.13 0.13 0.1475 0.25] ),
				"CL", Interpolate( parseColNamedose, [50 160], [1.25 4] ),
				"SDMA", Interpolate( parseColNamedose, [0 5 15 18 25 50 100], [3 1.5 1.5 1.7 2.25 5 10] ), 
				Empty()
			)
		)
	);
	
	table << New Column( "Req Upper CI",
		Numeric,
		Continuous,
		Set Formula( :Requirement / Sqrt( (parseColNameN - 1) / ChiSquare Quantile( 1 - alphaVal / 2, parseColNameN - 1 ) ) )
	);
	
	Column( table, "Requirement" ) << Delete Formula;
	//Column( table, "Req Upper CI" ) << Delete Formula;
	Return(table)
);

prep4offline = Function({mainTable,mainPath}, {default local},
	/*
	mainTable = currentdatatable();
	*/
	dt = mainTable;

	temp = dt << New Column("uniqueCol",Character,
		Formula(
			:"Date_Time"n || ", " || Char( :"Slide Position"n )
		)
	);
	temp << delete formula;

	array = Associative Array(dt:"Slide Type"n);
	dtSum = dt<< Summary(
		Group( :"Slide Type"n, :"Scalar"n, :"False Light"n ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 ),
		private
	);
	dt:"Scalar"n << set name("Scalar_orig");
	dt:"False Light"n << set name("FalseLight_orig");

	array[0] = {};
	array[1] = {};
	array[2] = {};
	For Each Row(dtSum,
		insertinto(array[:"Slide Type"n], :"Scalar"n);
		insertinto(array[:"Slide Type"n], :"False Light"n);
	);
	dtSum << close window;

	slideTypeChoice = Match(dt:"Assay"n[1],
		40,2,
		41,1,
		42,0
	);

	dt << New Column("Scalar", Numeric, Continuous,
		<< Set Each Value(array[slideTypeChoice][1])
	);
	dt << New Column("False Light", Numeric, Continuous,
		<< Set Each Value(array[slideTypeChoice][2])
	);

	dtStack = dt << Stack(
		columns(
			:"24"n,
			:"25"n,
			:"26"n,
			:"27"n,
			:"28"n,
			:"29"n,
			:"30"n,
			:"31"n,
			:"32"n,
			:"33"n,
			:"34"n,
			:"35"n,
			:"36"n,
			:"37"n,
			:"38"n,
			:"39"n,
			:"40"n,
			:"41"n,
			:"42"n,
			:"43"n,
			:"44"n,
			:"45"n,
			:"46"n,
			:"47"n,
			:"48"n,
			:"49"n,
			:"50"n,
			:"51"n,
			:"52"n,
			:"53"n,
			:"54"n,
			:"55"n,
			:"56"n,
			:"57"n,
			:"58"n,
			:"59"n,
			:"60"n,
			:"61"n,
			:"62"n,
			:"63"n,
			:"64"n,
			:"65"n
		),
		Source Label Column( "ion Read Point" ),
		Stacked Data Column( "RD" ),
		private
	);
	dtStack << clear row states;
	dtStack:"ion Read Point"n << data type(numeric);
	dtStack:"ion Read Point"n << modeling type(continuous);

	temp = dtStack << New Column("Catalyst Read Point", Numeric, Continuous,
		Formula(:"ion Read Point"n - 24)
	);
	temp << delete formula;
	temp = dtStack << New Column("Inst Type", Character,
		Formula(
			Match( Substr( :"InstrumentSerial"n, 1, 4 ), "CTDX", "CatDx", "CAT1", "CatOne" )
		)
	);
	temp << delete formula;
	temp = dtStack << New Column("Gain",numeric,continuous,
		Formula(1/:"Scalar"n)
	);
	temp << delete formula;
	dtStack << New Column("Dilution Parts",Numeric,continuous,<<set each value(0));
	dtStack << New Column("Offset",Numeric,continuous,<<set each value(0));
	dtStack << New Column("NumWL",Numeric,continuous,<<set each value(1));
	dtStack << New Column("CenterWL1",Numeric,continuous,<<set each value(470));
	dtStack << New Column("CenterWL2",Numeric,continuous,<<set each value(0));
	dtStack << New Column("ReadFlag",Numeric,continuous,<<set each value(0));
	dtStack << New Column("RD2",Numeric,continuous,<<set each value(0));

	//path = ConvertFilePath(GetDefaultDirectory());
	canonTimes = Open(mainPath || "offlineAlgorithm/Lytes Canonical and median read times by instrument type.jmp",private);
	dtStack << Update(
		With( canonTimes ),
		Match Columns(
			:"InstType"n = :"Inst Type"n,
			:"Catalyst Read Point"n = :"Lytes Read Point"n
		),
		Add Columns from Update Table( :"median read time"n )
	);
	close(canonTimes,nosave);
	dtStack << selectwhere(IsMissing(:"median read time"n)) << delete rows;

	tblList4Offline = {};
	If(dtStack:"Assay"n[1] == 40,
		dtStack1 = dtStack << Subset(
			Copy formula( 0 ),
			All rows,
			Selected columns only( 0 ),
			private
		);
		dtStack2 = dtStack << Subset(
			Copy formula( 0 ),
			All rows,
			Selected columns only( 0 ),
			private
		);
		dtStack << New Column("DryStart",Numeric,continuous,<<set each value(9));
		dtStack << New Column("DryEnd",Numeric,continuous,<<set each value(10));
		dtStack << set name("Dry 9-10");
		dtStack1 << New Column("DryStart",Numeric,continuous,<<set each value(9));
		dtStack1 << New Column("DryEnd",Numeric,continuous,<<set each value(11));
		dtStack1 << set name("Dry 9-10-11");
		dtStack2 << New Column("DryStart",Numeric,continuous,<<set each value(10));
		dtStack2 << New Column("DryEnd",Numeric,continuous,<<set each value(11));
		dtStack2 << set name("Dry 10-11");
		insertinto(tblList4Offline,dtStack);
		insertinto(tblList4Offline,dtStack1);
		insertinto(tblList4Offline,dtStack2);
		,
		dtStack:"Assay"n[1] == 41 | dtStack:"Assay"n[1] == 42,
		dtStack << New Column("DryStart",Numeric,continuous,<<set each value(6));
		dtStack << New Column("DryEnd",Numeric,continuous,<<set each value(7));
		dtStack << set name("Dry 6-7");
		insertinto(tblList4Offline,dtStack)
	);
	Return(mainTable,tblList4Offline)
);

	//creates the loop qual modal
LoopQualModal = Function({mainTable,dosereporttable,loopErrorSummaryTable,loopFoilErrorCountTable}, {default local},
	//dosereporttable = current data table();
	
	//gathering and setting variables.
	Status_in_table = dosereporttable:"Pass/Fail Status"n << get as matrix;
	Status = If(dosereporttable:"Pass/Fail Status"n[1] == "Pass" & dosereporttable:"Pass/Fail Status"n[2] == "Pass",
		"Green",
		If(dosereporttable:"Pass/Fail Status"n[1] == "Pass" | dosereporttable:"Pass/Fail Status"n[2] == "Pass",
			"Green",
		"Red"
		);
	);
	Status_Word = If(dosereporttable:"Pass/Fail Status"n[1] == "Pass" & dosereporttable:"Pass/Fail Status"n[2] == "Pass",
		"Pass",
		If(dosereporttable:"Pass/Fail Status"n[1] == "Pass" | dosereporttable:"Pass/Fail Status"n[2] == "Pass",
			"Pass",
		"Fail"
		);
	);
	chemistry = dosereporttable:"Chem Type"n[1];
	AS = dosereporttable:"Gain Calc_Loop Lot_LQ"n << get as matrix;
	ARSD = dosereporttable:"Total ARSD"n << get as matrix;
	LQ_spec = dosereporttable:"Req Upper CI"n << get as matrix;
	//may need an if statement to deal with one fluid vs 2.
	if(chemistry == "SDMA",
		Fluid_Type = dosereporttable:"Panel Dose"n << get as matrix,
		Fluid_Type = dosereporttable:"Buffer"n << get as matrix	
	);
	//setting x axis min/maxs and y axis min/maxs
	x_min = 0;
	y_min = 0;
	if(chemistry == "NA",
		x_max = Max(ARSD) * 5;
		y_max = Max(abs(AS)) * 3,
		if(chemistry == "K",
			x_max = Max(ARSD) * 6;
			y_max = Max(abs(AS)) * 4,
			if(chemistry == "CL",
				x_max = Max(ARSD) * 5;
				y_max = Max(abs(AS)) * 5,
				if(
					chemistry == "SDMA",
					x_max = Max(ARSD) * 3;
					y_max = Max(abs(AS)) * 3;
				)
			)
		)
	);
	
	Acknowledge = New Window( chemistry || " Loop Qualification Pass/Fail Status",
		<< modal,
		<< Return Result,
		<< On Validate(OP_Ack << get text !=""),
		Show Menu(0),
		Show Toolbars(0),
		Border Box(Top(60),Bottom(60),Left(60),Right(60),
			V List Box(
				Align (Center),
				H List Box(
					Spacer Box(Size(0,0)),
					Text Box(  
						chemistry || " Loop Qualification Pass/Fail Status: ",
						<< Set Font Style("Bold"),
						<< Set Font Size(16),
						<< Set Wrap(700),
					)
				)
				,
				Text Box(
					Status_Word,
					<< Set Font Style("Bold"),
					<< Set Font Size(20),
					<< Font Color(Status),
				)
				,
				TextBox(
					"",
					<< Set Font Style("Bold"),
					<< Set Font Size(20),
				)
				,
				H List Box(
					Graph Box(
						Title ( char(Fluid_Type[1]) ),
						Frame Size( 500, 300 ),
						X Scale( x_min, x_max ),
						Y Scale( y_min, y_max ),
						XName("Total ARSD"),
						YName("Average Slope"),
						Marker(
							Marker State(0),
							{ARSD[1], abs(AS[1])}
						);
						Y Function( x / LQ_spec[1], x );
						x1 = Index( 0, 10000, 1 )`;
						y1 = x1 / LQ_spec[1];
						y2 = Repeat( -10, N Row( x1 ) );
						xmat = x1 |/ Matrix( Reverse( As List( x1 ) ) );
						ymat = y1 |/ Matrix( Reverse( As List( y2 ) ) );
						Fill Color( "Red" );
						Transparency( 0.5 );
						Polygon( xmat, ymat );
					),
					Graph Box(
						Title( char(Fluid_Type[2]) ),
						Frame Size( 500, 300 ),
						X Scale( x_min, x_max ),
						Y Scale( y_min, y_max ),
						XName("Total ARSD"),
						YName("Average Slope"),
						Marker(
							Marker State(0),
							{ARSD[2], abs(AS[2])}
						);
						Y Function( x / LQ_spec[2], x );
						x1 = Index( 0, 10000, 1 )`;
						y1 = x1 / LQ_spec[2];
						y2 = Repeat( -10, N Row( x1 ) );
						xmat = x1 |/ Matrix( Reverse( As List( x1 ) ) );
						ymat = y1 |/ Matrix( Reverse( As List( y2 ) ) );
						Fill Color( "Red" );
						Transparency( 0.5 );
						Polygon( xmat, ymat );
					)
				)
				,
				If(chemistry == "CL",
					TextBox(
					"CL's average slope is shown as absolute for visual representation",
					<< Set Font Size(10),
					<< Set Wrap(700)
					)
				)
				,
				LineUp Box(NCol(2), Spacing(30,20),
					Text Box("Operators Initials:",
					<< Set Wrap(220),
					<< Set Font Size(12)),
					Op_Ack = Text Edit Box("", << set width(100))
				)
				,
				HListBox(
					Button Box("OK")
					,
					Button Box("Cancel"),
				)
			)
		)
	);
	If(Acknowledge["Button"] == -1,
		mainTable << close window;
		dosereporttable << close window;
		loopErrorSummaryTable << close window;
		loopFoilErrorCountTable << close window;
		userCanceled();
		Return(0)
		,
		Return(Acknowledge);
	);
);

	//records the outcome of the modal graph and appends a script and signatures.
ModalOutcome = Function({modalresults, dosereporttable}, {default local},
	//show(modalresults);
	//show(modalresults["Op_Ack"]);
	//show(modalresults["Button"]);
	
	dosereporttable << New Column("Operator Initials", Character, Set Each Value(modalresults["Op_Ack"]) );
	dosereporttable << New Column("Operator Acknowledgement Date and Time", Format("m/d/y h:m:s"), Set Each Value(Today()));

	Return(dosereporttable);
);

subLot2DblockerFunc = Function( {table, respCol, posCol, blockCol, fluidCol, slideLotvar, chemTypecol, excludeCol, blockType, mathType, outputCol},
	{default Local}, 
	
	/*table = the loop qual data table
	posCol = the sub lot x positions are going to correct around
	blockCol = a value that the data needs to be blocked for to measure the posCol more accurately
	respCol = intended to be AR
	fluidCol = to cover in the event we have multiple fluid levels in the data this identifies unique fluids
	slideLotvar = the slide lot that excludes the sublot field
	cont = the type of sublot pattern we are correcting for*/
	
	parseColNamesublotx = Parse( Eval Insert( ":name(\!"^posCol^\!" )" ) );
	parseColNameblocker = Parse( Eval Insert( ":name(\!"^blockCol^\!" )" ) );
	parseColNamedose = Parse( Eval Insert( ":name(\!"^fluidCol^\!" )" ) );
	parseColNameresponse = Parse( Eval Insert( ":name(\!"^respCol^\!" )" ) );
	parseColNamecoating = Parse( Eval Insert( ":name(\!"^slideLotvar^\!" )" ) );
	parseColNameresponsemean = Parse( Eval Insert( ":name(\!"Mean(\!^respCol^\!)\!" )" ) );
	parseColNamechem = Parse( Eval Insert( ":name(\!"^chemTypecol^\!" )" ) );
	parseColNameexcl = Parse( Eval Insert( ":name(\!"^excludeCol^\!" )" ) );
	
	colNamechem = Eval Insert( ":name(\!"^chemTypecol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	colNamesublotx = Eval Insert( ":name(\!"^posCol^\!" )" );
	colNameblocker = Eval Insert( ":name(\!"^blockCol^\!" )" );
	colNameresponse = Eval Insert( ":name(\!"^respCol^\!" )" );
	colNamecoating = Eval Insert( ":name(\!"^slideLotvar^\!" )" );
	
	If(
		mathType == "Mean",
			If(
				blockType == "Relative",
					table << New Column( Char( outputCol ),
						Numeric,
						Continuous,
						Set Formula(
							Col Mean(
								parseColNameresponse - Col Mean(
									parseColNameresponse,
									parseColNameblocker,
									parseColNamedose,
									parseColNamechem,
									parseColNameexcl
								),
								parseColNamesublotx,
								parseColNamedose,
								parseColNamechem,
								parseColNameexcl
							)
						)
					);
					Column( table, Char( outputCol ) ) << Delete Formula;, 
	
				blockType == "Absolute",
					table << New Column( Char( outputCol ),
						Numeric,
						Continuous,
						Set Formula(
							Col Mean(
								parseColNameresponse - parseColNameblocker,
								parseColNamesublotx,
								parseColNamedose,
								parseColNamechem,
								parseColNameexcl
							)
						)
					);
					Column( table, Char( outputCol ) ) << Delete Formula;,
				Throw()
			),
		mathType == "Median",
			If(
				blockType == "Relative",
					table << New Column( Char( outputCol ),
						Numeric,
						Continuous,
						Set Formula(
							Col Median(
								parseColNameresponse - Col Median(
									parseColNameresponse,
									parseColNameblocker,
									parseColNamedose,
									parseColNamechem,
									parseColNameexcl
								),
								parseColNamesublotx,
								parseColNamedose,
								parseColNamechem,
								parseColNameexcl
							)
						)
					);
					Column( table, Char( outputCol ) ) << Delete Formula;, 
	
				blockType == "Absolute",
					table << New Column( Char( outputCol ),
						Numeric,
						Continuous,
						Set Formula(
							Col Median(
								parseColNameresponse - parseColNameblocker,
								parseColNamesublotx,
								parseColNamedose,
								parseColNamechem,
								parseColNameexcl
							)
						)
					);
					Column( table, Char( outputCol ) ) << Delete Formula;,
				Throw()
			)
	);
	Return(table)
);

totalLoopReport_2 = Function( {tablename, arColumn, crosswebColumn, foilColumn, fluidColumn, slideLotColumn, chemColumn }, {default local},
	/*
	tablename=dt1;
	tablename = currentdatatable();
	arColumn="DR Mean 9-10-11 offline_ar";
	crosswebColumn="Crossweb_LQ";
	foilColumn="Foil_LQ";
	fluidColumn="Dose";
	slideLotColumn="Loop Lot_LQ";
	chemColumn="Chem Type";
	*/
	//variable shortening
	dt = tablename;
	arCol = arColumn;
	cwCol = crosswebColumn;
	foilCol = foilColumn;
	fluidCol = fluidColumn;
	slCol = slideLotColumn;
	chemCol = chemColumn;

	// creating name and parseName versions of columns
	nameAR = Eval Insert( ":\!"^arCol^\!"n" );
	nameCW = Eval Insert( ":\!"^cwCol^\!"n" );
	nameFoil = Eval Insert( ":\!"^foilCol^\!"n" );
	nameFluid = Eval Insert( ":\!"^fluidCol^\!"n" );
	nameSL = Eval Insert( ":\!"^slCol^\!"n" );
	nameChem = Eval Insert( ":\!"^chemCol^\!"n" );

	parseNameAR = Parse(Eval Insert( "^dt^:\!"^arCol^\!"n" ) );
	parseNameCW = Parse(Eval Insert( "^dt^:\!"^cwCol^\!"n" ) );
	parseNameFoil = Parse(Eval Insert( "^dt^:\!"^foilCol^\!"n" ) );
	parseNameFluid = Parse(Eval Insert( "^dt^:\!"^fluidCol^\!"n" ) );
	parseNameSL = Parse(Eval Insert( "^dt^:\!"^slCol^\!"n" ) );
	parseNameChem = Parse(Eval Insert( "^dt^:\!"^chemCol^\!"n" ) );
	
	//gathers loop lot and Chem name for use later in table naming
	//loopLot = dt:"Loop Lot_LQ"n[1];
	chemName = dt:"Chem Type"n[1];
	If(chemName == "SDMA",
		loopLot = dt:"Loop Lot"n[1];
		,
		loopLot = dt:"Loop Lot_Filename"n[1]
	);
	show(loopLot);
	//the ar algorithm will create ARs and the column will be have the dry reads used
	//CL will need to pick a 'best' set while NA and K will just use what they always have
	dryReadSet = If(arCol == "AR", "not applicable"
		,
		Word(3,arCol)
	);
	dt << New Column( "Dry Reads Used", Character,
		<< Set Each Value(dryReadSet)
	);
	temp = dt << New Column( "Dose Blocked AR", Numeric, Continuous,
		Set Formula( parseNameAR - Col Median( parseNameAR, parseNameFluid ) )
	);
	temp << delete formula;

	dt = Grubbs_Outlier_Detection( dt, "Dose Blocked AR", 0.001 );

	dt = subLot2DblockerFunc( dt, arCol, cwCol, foilCol, fluidCol, slCol, chemCol, "Exclusion Rationale", "Relative", "Median", "CW Correction" );

	temp = dt << New Column( "CW Corrected AR_by Median", Numeric, Continuous, Set Formula( parseNameAR - :"CW Correction"n ) );
	temp << Delete Formula;

	dt = masterTarget(dt,arCol,fluidCol,"Exclusion Rationale");

	dt = subLot2DblockerFunc( dt, "CW Corrected AR_by Median", foilCol, "Master AR Target", fluidCol, slCol, chemCol, "Exclusion Rationale", "Absolute", "Median","Foil Correction" );

	temp = dt << New Column( "Sub Lot Corrected AR_by Median", Numeric, Continuous,
		Formula( :"CW Corrected AR_by Median"n - :"Foil Correction"n ) 
	);
	temp << delete formula;

	temp = dt << New Column( "Dose Blocked AR2",
		Numeric,
		Continuous,
		Set Formula( :"Sub Lot Corrected AR_by Median"n - Col Median( :"Sub Lot Corrected AR_by Median"n, parseNameFluid ) )
	);
	temp << delete formula;

	dt = Grubbs_Outlier_Detection( dt, "Dose Blocked AR2", 0.001 );//didn't seem to put anything in the exclusion column

	dt << Delete Columns(
		"Dose Blocked AR2", "Dose Blocked AR", "Sub Lot Corrected AR_by Median", "CW Corrected AR_by Median", "Foil Correction", "CW Correction"
	);

	dt = subLot2DblockerFunc( dt, arCol, cwCol, foilCol, fluidCol, slCol, chemCol, "Exclusion Rationale", "Relative", "Mean", "CW Correction" );

	temp = dt << New Column( "CW Corrected AR", Numeric, Continuous, 
		Set Formula( parseNameAR - :"CW Correction"n ) 
	);
	temp << delete formula;

	dt = subLot2DblockerFunc( dt, "CW Corrected AR", foilCol, "Master AR Target", fluidCol, slCol, chemCol, "Exclusion Rationale", "Absolute", "Mean", "Foil Correction" );

	temp = dt << New Column( "Sub Lot Corrected AR", Numeric, Continuous, 
		Set Formula( :"CW Corrected AR"n - :"Foil Correction"n ) 
	);
	temp << delete formula;
	
	Try(
		dtSummary = dt << Summary(
			Group( parse(NameFluid), 
				parse( NameChem ), 
				parse( NameSL ),
				:"Assay"n, 
				:"Exclusion Rationale"n,
				/* :"Fiber Lot"n, */
				:"Buffer"n,
				/* :"Buffer Lot"n, */
				:"Dry Reads Used"n ),
			Mean( :"Sub Lot Corrected AR"n ),
			Std Dev( :"Sub Lot Corrected AR"n ),
			Freq( "None" ),
			Weight( "None" ),
			Link to original data table( 0 )
		);
		,
		dtSummary = dt << Summary(
			Group( parse(NameFluid), 
				parse( NameChem ), 
				parse( NameSL ),
				:"Assay"n, 
				:"Exclusion Rationale"n,
				/* :"Fiber Lot"n, */
				//:"Buffer"n,
				/* :"Buffer Lot"n, */
				:"Dry Reads Used"n ),
			Mean( :"Sub Lot Corrected AR"n ),
			Std Dev( :"Sub Lot Corrected AR"n ),
			Freq( "None" ),
			Weight( "None" ),
			Link to original data table( 0 )
		);
	);
	dtSummary << Select Where( Char( :Exclusion Rationale ) != "" ) << Delete Rows;

	dtSummary = linearFitadder( dtSummary, "Mean(Sub Lot Corrected AR)", slCol, fluidCol, slCol, chemCol, -99, 99 );
	dtSummary << Delete Columns( "Gain Check_"|| slCol );
	
	//gather information from chemistry array related to alpha, Gain SD and Offset SD.
	chem_info = chemistry_information();
	Summarize(dtSummary, b = by("Assay"));
	assay_code_tested = num(b[1]);
	
	
	dtSummary << New Column("Instrument Gain SD", set each value(chem_info[assay_code_tested]["Gain SD"]));
	dtSummary << New Column("Instrument Offset SD", set each value(chem_info[assay_code_tested]["Offset SD"]));
	dtSummary << New Column("Between ARSD", formula( Sqrt( (Tan( :"Instrument Gain SD"n ) * Abs( :"Mean(Sub Lot Corrected AR)"n )) ^ 2 + :"Instrument Offset SD"n ^ 2 ) ));
	dtSummary << New Column("Total ARSD", formula( Sqrt( :"StdDev(Sub Lot Corrected AR)"n ^ 2 + :"Between ARSD"n ^ 2 )));	

	temp = dtSummary << New Column( "Dose SD", Numeric, Continuous, 
		Set Formula( Abs( :"Total ARSD"n / AsColumn("Gain Calc_"|| slCol) ) ) 
	);
	temp << delete formula;

	dtSummary = productReqsFunc( dtSummary, fluidCol, chemCol, "N Rows", 0.01 );

	temp = dtSummary << New Column( "Pass/Fail Status", Character, Nominal, 
		Set Formula( If( :"Dose SD"n <= :"Req Upper CI"n, "Pass", "Fail" ) ) 
	);
	temp << delete formula;

	for each row( dtSummary,
		If(dtSummary:"Pass/Fail Status"n == "Pass", 
			dtSummary:"Pass/Fail Status"n << color cells("Green", row())
			, 
			dtSummary:"Pass/Fail Status"n << color cells ("Red", row())	
		)
	);
	dtSummary << Set Name(char(loopLot) || "_" || chemName || "_" ||"Loop Qualification Summary Report");

	dt << Clear Row States;

	dt_Errorsummary = dt << Summary(
		Group( parseNameFoil , :"Exclusion Rationale"n, parseNameChem, parseNameSL, parseNameFluid ),
		Std Dev( :"Sub Lot Corrected AR"n ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 )
	);
	
	/*  So, I am not sure exactly why we had to go this route. Having the command with parseNameChem etc or
	 parse(name) or as column() versions seemed to not work or not honor all of the groupings correctly.
	 Explicitly evaluating the variables before execution seems to have fixed that problem */
	Eval(
		EvalExpr(
			dt_Errorsummary2 = dt_Errorsummary << Split(
				Split By( :"Exclusion Rationale"n ),
				Split( :"N Rows"n ),
				Group( Expr(Parse(nameChem)) , Expr(parse(nameSL)), Expr(parse(NameFoil)), Expr(parse(NameFluid)) ),
				Remaining Columns( Keep All ),
				Sort by Column Property,
				private
			);
		)
	);

	Try(
		For Each Row(dt_Errorsummary2,
			If(IsMissing(:"NDE - Grubb's"n),:"NDE - Grubb's"n = 0)
		);
		,
		dt_Errorsummary2 << New Column("NDE - Grubb's",continuous, numeric,<<set each value(0))
	);
	
	foilErrorCount = dt_Errorsummary2 << Summary(
		Group( Parse(nameFoil),Parse(nameChem),Parse(NameSL) ),
		Sum( :"NDE - Grubb's"n ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 )
	);
	foilErrorCount << Delete Columns("N Rows");
	foilErrorCount:"Sum(NDE - Grubb's)"n << set name("NDE - Grubb's");
	foilErrorCount << Set Name(char(loopLot) || "_" || chemName || "_" ||"NDE Count by foil");
	
	doseErrorCount = dt_Errorsummary2 << Summary(
		Group( Parse(nameFluid),Parse(nameChem),Parse(NameSL) ),
		Sum( :Name( "NDE - Grubb's" ) ),
		Freq( "None" ),
		Weight( "None" ),
		Link to original data table( 0 ),
		private
	);
	doseErrorCount << Delete Columns("N Rows");
	doseErrorCount:"Sum(NDE - Grubb's)"n << set name("NDE - Grubb's");
	
	//chem_info = chemistry_information();
	//Summarize(dtSummary, b = by("Assay"));
	//assay_code_tested = num(b[1]);
	dtSummary << Update(
		With( doseErrorCount ),
		Match Columns( Parse(nameFluid) = Parse(nameFluid)  )
	);
	dtSummary << delete columns("Exclusion Rationale");
	dtSummary << New Column("Total Loop Outlier Threshold", set each value(chem_info[assay_code_tested]["Outlier Threshold - Loop"]));
	dtSummary << New Column("Outlier Status for Loop", 
		formula(
			If( Col Sum( :"NDE - Grubb's"n ) > :"Total Loop Outlier Threshold"n,
				"Exceeds Threshold",
				"Acceptable"
			)
		)
	);
	dtSummary:"N Rows"n << set name("Replicates");
	
	Try(
		dtSummary << Move Selected Columns(
			{
				Eval(chemCol),
				"Dry Reads Used",
				"Assay",
				Eval(slCol),
				Eval(fluidCol),
				/* "Fiber Lot", */
				"Buffer",
				/* "Buffer Lot", */
				"Replicates",
				"NDE - Grubb's",
				"Total Loop Outlier Threshold",
				"Outlier Status for Loop"
			},
			To First
		);
		,
		dtSummary << Move Selected Columns(
			{
				Eval(chemCol),
				"Dry Reads Used",
				"Assay",
				Eval(slCol),
				Eval(fluidCol),
				/* "Fiber Lot", */
				//"Buffer",
				/* "Buffer Lot", */
				"Replicates",
				"NDE - Grubb's",
				"Total Loop Outlier Threshold",
				"Outlier Status for Loop"
			},
			To First
		);
	);
	
	Close(doseErrorCount, nosave);
	Close(dt_Errorsummary2, nosave);
	
	dt_Errorsummary << select where(!IsMissing(:"Exclusion Rationale"n)) << delete rows;
	dt_Errorsummary << delete columns("Exclusion Rationale");
	dt_Errorsummary << set name(char(loopLot) || "_" || chemName || "_" ||"Sublot Corrected SDs by Foil and Fluid");

	Return(dt, dtSummary, dt_Errorsummary, foilErrorCount)
);

stitchingFunct = Function({startingTable_input},{default local},
	//startingTable_input = currentdatatable();
	
	//function is for stitching together all interweaving functions and their inputs/outputs
	//allows 'main' to stay cleaner
	startingTable_name = startingTable_input << get name;
	startingTable = startingTable_input << Subset(
		Output Table(startingTable_name || "_processed"),
		All rows, 
		Selected columns only (0) 
	);
	
	//modifies information in table based on keys in Barcode column
	Barcode_Parse(startingTable, "Barcode");
	
	//NEED ADD CHECK FOR NECESSARY COLUMNS (has colCheck from QSDMA, and failure function)
	Try(
		//checks to do the QSDMA stuff first.
		IsScriptable(Column(startingTable,"Assay"));
		print("starting QSDMA");
		lqReportSummaries = totalLoopReport_2(startingTable, "Corrected AR", "Crossweb_LQ", "Foil_LQ", "Panel Dose", "Loop Lot_LQ", "Chem Type");
		dryReadSet = "0";
		startingTable = lqReportSummaries[1];
		loopSummary = lqReportSummaries[2];
		loopErrorSummary = lqReportSummaries[3];
		loopFoilErrorCount = lqReportSummaries[4];
		
		//startingTable << New Column( "Dry Reads Used",Character,<< set each value(dryReadSet));
		temp = startingTable << New Column("Dry Read Start", Numeric, Continuous,
			Formula(Num(Word(1,:"Dry Reads Used"n,"-")))
		);
		temp << delete formula;
		temp = startingTable << New Column("Dry Read End", Numeric, Continuous,
			Formula(
				Num(
					Word(
						length(Words(:"Dry Reads Used"n,"-")),:"Dry Reads Used"n,"-"
					)
				)
			)
		);
		temp << delete formula;
		,
		//does lytes stuff if QSDMA stuff not satisfied. 
		//modifies information in table based on keys in FileName
		filename_parse_func(startingTable, "File Name");
		If(fileVsBCRloopLotCheck(startingTable) == 1, Empty()
			,
			loopNumNotMatchBCR();
			Close(startingTable,nosave);
			Throw();
		);
		//Creating ARs from the loop data
		newCap = Caption(
			{500, 500},
			"Please Wait: Offline Algorithm is Calculating ARs",
			Font( "Arial" ),
			Font Size( 16 ),
			Text Color( “blue” ),
			//Back Color( “yellow” ),
			//Spoken( 1 ),
			//Delayed( 1 )
		);
		Wait();
		prepOutput = prep4offline(startingTable,path);
		startingTable = runOfflineAlg(prepOutput[1],prepOutput[2],path);
		Caption(remove);
			//if CL is the assay(40) does the math on both dry read ARs and determines the best
		//dry read set to use. for NA or K it defaults to using dry reads 6-7 and moves forward as such
		If(startingTable:"Assay"n[1] == 40,

			initialName = startingTable << get name;
			//will produce two sets of tables, one for CL 9-10, one for CL 9-10-11
			startingTable1 = startingTable <<	Subset( Suppress formula evaluation( 0 ), All rows, Selected columns only( 0 ) );
			startingTable << bring window to front;
			lq_9_10_Summaries = totalLoopReport_2(startingTable, "DR Mean 9-10 offline_ar", "Crossweb_LQ", "Foil_LQ", "Dose", "Loop Lot_LQ", "Chem Type");
			startingTable1 << bring window to front;
			lq_9_10_11_Summaries = totalLoopReport_2(startingTable1, "DR Mean 9-10-11 offline_ar", "Crossweb_LQ", "Foil_LQ", "Dose", "Loop Lot_LQ", "Chem Type");
			/*
			if both pass/pass default to 9-10
			if one pass/fail and the other pass/pass use the pass/pass
			if both pass/fail, default to 9-10 (since pass/fail = pass)
			if one fail/fail, use the other one
			if both fail/fail, default to 9-10 and later steps will error
			*/
			status9_10 = Sort Ascending(lq_9_10_Summaries[2]:"Pass/Fail Status"n << get as matrix);
			status9_10_11 = Sort Ascending(lq_9_10_11_Summaries[2]:"Pass/Fail Status"n << get as matrix);
			If(
				(status9_10 == {"Pass","Pass"} & status9_10_11 == {"Pass","Pass"}) | 
				(status9_10 == {"Fail","Pass"} & status9_10_11 == {"Fail","Pass"}) | 
				(status9_10 == {"Pass","Pass"} & status9_10_11 == {"Fail","Pass"}) |
				(status9_10 == {"Pass","Pass"} & status9_10_11 == {"Fail","Fail"}) |
				(status9_10 == {"Fail","Pass"} & status9_10_11 == {"Fail","Fail"}) |
				(status9_10 == {"Fail","Fail"} & status9_10_11 == {"Fail","Fail"}),
					dryReadSet = "9-10";
					startingTable = lq_9_10_Summaries[1];
					loopSummary = lq_9_10_Summaries[2];
					loopErrorSummary = lq_9_10_Summaries[3];
					loopFoilErrorCount = lq_9_10_Summaries[4];
					unchosenTable = lq_9_10_11_Summaries[1];
					lq_9_10_11_Summaries[1] << Set Name("unchosen9-10-11_"||initialName);
					Close(lq_9_10_11_Summaries[2],nosave);
					Close(lq_9_10_11_Summaries[3],nosave);
					Close(lq_9_10_11_Summaries[4],nosave);
				,
				(status9_10 == {"Fail","Pass"} & status9_10_11 == {"Pass","Pass"}) | 
				(status9_10 == {"Fail","Fail"} & status9_10_11 == {"Pass","Pass"}) | 
				(status9_10 == {"Fail","Fail"} & status9_10_11 == {"Fail","Pass"}),
					dryReadSet = "9-10-11";
					startingTable = lq_9_10_11_Summaries[1];
					loopSummary = lq_9_10_11_Summaries[2];
					loopErrorSummary = lq_9_10_11_Summaries[3];
					loopFoilErrorCount = lq_9_10_11_Summaries[4];
					unchosenTable = lq_9_10_Summaries[1];
					lq_9_10_Summaries[1] << Set Name("unchosen9-10_"||initialName);
					Close(lq_9_10_Summaries[2],nosave);
					Close(lq_9_10_Summaries[3],nosave);
					Close(lq_9_10_Summaries[4],nosave);
			);
			,
			startingTable:"Assay"n[1] == 41 | startingTable:"Assay"n[1] == 42,
				lqReportSummaries = totalLoopReport_2(startingTable, "DR Mean 6-7 offline_ar", "Crossweb_LQ", "Foil_LQ", "Dose", "Loop Lot_LQ", "Chem Type");
				dryReadSet = "6-7";
				startingTable = lqReportSummaries[1];
				loopSummary = lqReportSummaries[2];
				loopErrorSummary = lqReportSummaries[3];
				loopFoilErrorCount = lqReportSummaries[4];
		);
		//startingTable << New Column( "Dry Reads Used",Character,<< set each value(dryReadSet));
		temp = startingTable << New Column("Dry Read Start", Numeric, Continuous,
			Formula(Num(Word(1,:"Dry Reads Used"n,"-")))
		);
		temp << delete formula;
		temp = startingTable << New Column("Dry Read End", Numeric, Continuous,
			Formula(
				Num(
					Word(
						length(Words(:"Dry Reads Used"n,"-")),:"Dry Reads Used"n,"-"
					)
				)
			)
		);
		temp << delete formula;

		startingTable = hideProgCurveColumns(startingTable);
	);
	
	modalthing = LoopQualModal(startingTable,loopSummary,loopErrorSummary,loopFoilErrorCount); 
	If(modalthing != 0,
		outcome = ModalOutcome(modalthing, loopSummary);
		outcome << bring window to front;
		Return(startingTable,outcome,loopErrorSummary,loopFoilErrorCount,unchosenTable)
		,
		Return(0); //since canceling triggers modalthing to be 0 AND closes all tables, this function will also return 0
	);	
	
	Return(startingTable,outcome,loopErrorSummary,loopFoilErrorCount,unchosenTable);
);


///// Untested Main Functions
runOfflineAlg = Function({mainTable,listOfTablesToAnalyze,mainPath},{default local},
	/*
	maintable = prepOutput[1];
	listOfTablesToAnalyze = prepOutput[2];
	mainPath = path;
	*/

	dt = mainTable;
	tblList4Offline = listOfTablesToAnalyze;
	//running offline algorithm
	For(z=1,z<=nitems(tblList4Offline),z++,
		//tblList4Offline[z] << bring window to front;
		CurrentDataTable(tblList4Offline[z]);
		
		run_offline_algorithm(tblList4Offline[z],{":uniqueCol"},offAlgParamMatch,offAlgTimeseriesMatch,mainPath);
		
		colList = tblList4Offline[z] << get column names(string);
		While(nitems(colList) > 1,
			If(colList[1] != "DryEnd",
				RemoveFrom(colList,1);
				,
				RemoveFrom(colList,1);
				Break()
			);
		);
		//Wait(1);
		dryReadSet = Word(2,tblList4Offline[z] << get name);
		insertinto(colList,"uniqueCol");
		tblSub = tblList4Offline[z] << Subset(
			All rows,
			columns( colList ),
			private
		);
		removefrom(colList,length(colList));
		For(l=1,l<=nitems(colList),l++,
			Column(tblSub,colList[l]) << set name("DR Mean "||dryReadSet||" "||colList[l]);
		);
		dt << Update(
			With( tblSub ),
			Match Columns(
				:"uniqueCol"n = :"uniqueCol"n
			)
		);
		Close(tblSub,nosave);
	);

	For(i=1,i<=nitems(tblList4Offline),i++,
		Close(tblList4Offline[i],nosave)
	);
	Return(mainTable)
);

////////////////////////////////////////
//                                    //
//              Main                  //
//                                    //
////////////////////////////////////////

If( Length( Include File List() ) == 1,
	//removes old version of addin (before assays combined)
	Unregister Addin("com.idexx.RoswellQCTools_QSDMA_loopqual");
	
	//checks to see if tool is in beta and expired
	// improve to automatically turn on beta if
	beta = betaTestCheck(betaLimitwk);
	If(beta[1] == 1,
		Empty()
		,
		betaFailWindow(beta[2]);
		Throw()
	);
	If( checkVersion( minJMPver ) == 1,
		trackUsage(u,addinID);

		//prompts user to open table if one not open
		If( N Table() == 0,
			dt_start = Open(),
			dt_start = Current Data Table()
		);

		stitchingFunct(dt_start);
		,
		wrongVer( minJMPver );
	)
	,
	Print( "Script was included from another source" );
);