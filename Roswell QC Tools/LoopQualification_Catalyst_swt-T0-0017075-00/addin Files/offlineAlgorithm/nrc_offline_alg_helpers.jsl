//Author(s)
//CFarrell, NClark
//IDEXX Laboratories, Inc.
//Westbrook, ME 04092
//Supporting functions to run the offline algorithm
Names Default To Here( 1 );

//------------------Revision History for both script and Help File--
//
//	1.2 NClark 121521
//		-> added additional offline algorithm columns
//	1.1 NClark 120921
//		-> added path paraemter to load_offline_alg_dll and run_offline_algorith
//		-> implemented path parameter so 'get default directory' is no longer needed
//	1.0 CFarrell, NClark 120321
//------------------------------------------------------------------

//compatability screen (not 16.0, windows, 64bit)
check_compatibility = Function({},
	jmp_compatible = .;
	if((jmpversion()>"16" & jmpversion()<"16.1"),
	jmp_compatible = 0;
	New Window( "Error", modal,
		Text Box("JMP 16.0 not supported, please update 16.1 or newer.");
	);,
	jmp_compatible = 1;
	);

	if(jmp_compatible==1,
		if( Host is( "Windows" ),
		jmp_compatible = 1;
		,
		jmp_compatible = 0;
		New Window( "Error", modal,
		Text Box("Operating System not supported, please use Windows.");
		);
	);
	);

	if(jmp_compatible==1,
		if( Host is( "Bits64" ),
		jmp_compatible = 1;
		,
		jmp_compatible = 0;
		New Window( "Error", modal,
		Text Box("Only 64bit supported at this time.");
		);
	);
	);
	Return(jmp_compatible);
);

generate_unique_double = Function({dt,unique_columns},
	un = dt << New Column( "unique_numeric","Numeric");
	unique_form = "col min(row()";
	past_first = 1;
	for(i=1,i<=n items(unique_columns),i++,
		if(past_first==1,
			unique_form = unique_form || ",";
			);
		unique_form = unique_form || ":" || (unique_columns)[i];
		past_first = 1;
	);
	unique_form = unique_form || ")";
	//print(unique_form);
	un << Set Formula(eval(parse(unique_form)));
	un << hide(1);
	dt << Run Formulas;
	return(un);
);
//take list of any format grouping columns and make numeric
generate_unique_parameters = Function({dt,un,parameter_columns},
	unique_holder = {{}};
	unique_summary = "Summarize( unique_list = by(un),unique_holder[1]=mean(un)";
	u = 2;
	for(i=1,i<=n items(parameter_columns),i+=2,
		unique_holder<<append({});
		unique_summary = unique_summary || ", unique_holder["||char(u) ||"] = mean("|| parameter_columns[i] ||")";
		u++;
	);
	
	unique_summary = unique_summary || ");";
	eval(parse(unique_summary));
	return(unique_holder);
);
//default parameter column names tied to inputs (interlaced)
acquire_parameter_inputs = Function({dll_obj},
	parameter_holder = {};
	parameter_output = {{}};
	
	param_count = dll_obj<<jmp_get_required_input_count();

	for(i=0,i<param_count,i++,
		insert into(parameter_holder,eval(dll_obj<<jmp_get_required_input(i,0)));
		insert into(parameter_holder,eval(dll_obj<<jmp_get_required_input(i,1)));
	);
	
	for(i=1,i<=n items(parameter_holder),i+=2,
		parameter_output[i] = Column( parameter_holder[i] ) << getname;
		parameter_output[i+1] = parameter_holder[i+1] ;
	);
	return(parameter_output);
);
//default timeseries column names, strictly sequential
acquire_timeseries_inputs = Function({dll_obj},
	timeseries_holder = {};
	timeseries_output = {{}};
	
	timeseries_count = dll_obj<<jmp_get_required_timeseries_count();

	for(i=0,i<timeseries_count,i++,
		insert into(timeseries_holder,eval(dll_obj<<jmp_get_required_timeseries_input(i)));
	);
	
	for(i=1,i<=n items(timeseries_holder),i++,
		timeseries_output[i] = Column( timeseries_holder[i] ) << getname;
	);
	return(timeseries_output);
);
//load DLL at addin location
load_offline_alg_dll = Function({mainPath},{default local},
	//path = ConvertFilePath(GetDefaultDirectory());
	dll_path = (mainPath||"offlineAlgorithm\Algorithm_Wrapper.dll");
	dll_obj = Load DLL(dll_path,AutoDeclare(Quiet));
	
	dll_obj<<initialize();

	return(dll_obj);
);
//populate parameters inside the algorithm. 
populate_parameters = Function({dll_obj,unique_holder,column_parameters},
	meta_size = n items(unique_list);
	data_in = J( meta_size, 1, . );
	result = dll_obj<<jmp_meta_table2_(meta_size,"initialize",unique_holder[1],data_in);
	if(result!=1,
		print("SUMMARY INITIALIZE ERROR: "||char(result));
	);

	//build metatable
	h = 2;
	for(c=2,c<=n items(column_parameters),c+=2,
		cat_string = column_parameters[c];

		result = dll_obj<<jmp_meta_table2_(meta_size,cat_string,unique_holder[1],unique_holder[h]);
		if(result!=0,
			print("SUMMARY " || cat_string || " ERROR "||char(result));
		);
		h++;
	);
);

populate_timeseries = Function({dll_obj,unique_num,timeseries_parameters},
	unique_ids = unique_num << Get Values;
	unique_count = N items(unique_ids);
	ar_out = J( unique_count, 1, . );
	time_data = column(timeseries_parameters[1]) << Get Values;

	read_flag_data = column(timeseries_parameters[2]) << Get Values;

	read_data = column(timeseries_parameters[3])<< Get Values;
	read_data2 =  column(timeseries_parameters[4])<< Get Values;
	read_data3 = J( unique_count, 1, 0 );

	read_type__ = 2;

	result = dll_obj<<jmp_calc_(unique_count,read_type__,unique_ids,time_data,read_flag_data,read_data,read_data2,read_data3,ar_out);
	return(ar_out);
);

run_offline_algorithm = Function({dt,unique_ids,column_parameters,column_timeseries,mainPath}, {default local},
	//dt = currentdatatable();
	//unique_ids = {":uniqueCol"};
	if(check_compatibility,
		unique_num = generate_unique_double(dt,unique_ids);
		
		dll_obj = load_offline_alg_dll(mainPath);
		try(
			// OVERRIDE PARAMETERS
			/*column_parameters = {
			  "Assay","IN_ASSAY",
			  "Dilution Parts","IN_DILUTION",
			  "False Light","IN_FALSE_LIGHT",
			  "Gain","IN_GAIN",
			  "Offset","IN_OFFSET",
			  "NumWL","IN_WAVELENGTH_COUNT",
			  "CenterWL1","IN_WAVELENGTH1",
			  "CenterWL2","IN_WAVELENGTH2",
			  "DryStart","IN_DRY_START",
			  "DryEnd","IN_DRY_END"
			};*/
			
			//column_parameters = acquire_parameter_inputs(dll_obj);

			unique_holder = generate_unique_parameters(dt,unique_num,column_parameters);

			populate_parameters(dll_obj,unique_holder,column_parameters);

			// OVERRIDE TIMESERIES
			/*column_timeseries = {"median read time",
				"ReadFlag",
				"RD",
				"RD2"
			};*/
			
			//column_timeseries = acquire_timeseries_inputs(dll_obj);
			
			ar_out = populate_timeseries(dll_obj,unique_num,column_timeseries);
			dt << New Column("offline_ar", values(ar_out) );

			status_out = J( unique_count, 1, . );
			result = dll_obj<<jmp_output_(unique_count,"OUTPUT_ALG_FLAG",unique_ids,status_out);
			dt << New Column("alg_status", values(status_out) );

			drift_out = J( unique_count, 1, . );
			result = dll_obj<<jmp_output_(unique_count,"OUTPUT_SAMPLE_DRIFT",unique_ids,drift_out);
			dt << New Column("sample_drift", values(drift_out) );

			drift_out = J( unique_count, 1, . );
			result = dll_obj<<jmp_output_(unique_count,"OUTPUT_DRY_DIFF",unique_ids,drift_out);
			dt << New Column("dry_diff", values(drift_out) );

			drift_out = J( unique_count, 1, . );
			result = dll_obj<<jmp_output_(unique_count,"OUTPUT_WET_DIFF",unique_ids,drift_out);
			dt << New Column("wet_diff", values(drift_out) );

			drift_out = J( unique_count, 1, . );
			result = dll_obj<<jmp_output_(unique_count,"OUTPUT_SHIFT_COUNT",unique_ids,drift_out);
			dt << New Column("shift_count", values(drift_out) );

			drift_out = J( unique_count, 1, . );
			result = dll_obj<<jmp_output_(unique_count,"OUTPUT_SPIKE_COUNT",unique_ids,drift_out);
			dt << New Column("spike_count", values(drift_out) );

			drift_out = J( unique_count, 1, . );
			result = dll_obj<<jmp_output_(unique_count,"OUTPUT_MAX_SHIFT",unique_ids,drift_out);
			dt << New Column("max_shift", values(drift_out) );
			,
			//throw("Error, avoiding DLL crash and unloading");
			print("Error, avoiding DLL crash and unloading");
			New Window( "Error", modal,
				Text Box("Hard crash detected, unloading DLL.");
			);
		);
		dll_obj << UnLoadDLL;
		
		dt << Delete Columns( unique_num );
		wait();
	);
	Return(1);
);


