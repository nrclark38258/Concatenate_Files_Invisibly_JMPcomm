//Author(s)
//NClark
//IDEXX Laboratories, Inc.
//Westbrook, ME 04092

//Tool Calculates ARs for Operations Bile Acids data

//------------------Revision History for both script and Help File--
//
//	1.0.0 NClark 060821
//		-> 1st commits for 1st release
//------------------------------------------------------------------

Names Default To Here( 1 );

//-----------Variable Declarations (above Main for easy access)--
	
	If(HostIs("MAC"),
		u = Get Environment Variable("USER");
		,
		u = Get Environment Variable("USERNAME");
	);
	addinID = "com.idexx.RoswellQCTools_SDMA4_AR";

	minJMPver = "15.2";
	knownChemType = "SDMA";

	respCol = "ReflDens_avg";
	timeCol = "TimeFromSampleDispense:sec";
	uniqueCol = "uniqueCurveID";

	//version now tied to currently installed addin version
	//MAY NOT BE CORRECT WHEN TESTING
	Try(
		arCalcVer = Char( Get Addin( "com.idexx.RoswellQCTools_SDMA4_AR" ) << version )
		,
		Print( "Addin not installed yet" );
		arCalcVer = "v999";
	);

	cannonTimes = AssociativeArray(
		{
			{6, 100}, 
			{7, 115}, 
			{8, 130}, 
			{9, 145}, 
			{10, 160}, 
			{11, 175}, 
			{12, 190}, 
			{13, 205}
		}
	);
	cannonMax = Max(cannonTimes << get keys);
	cannonMin = Min(cannonTimes << get keys);

	nestedLinear = AssociativeArray(
		{
			{"linear",
				Associative Array(
					{
						{"m",-0.00337932050468136},
						{"b",0.972954848151445}
					}
				)
			},
			{"quad",
				Associative Array(
					{
						{"a",0.368029064830265},
						{"b",-8.86898563719204},
						{"c",56.0217911976737}
					}
				)
			}
		}
	);

	aberrantThresh = [14, -14];

	//Define the table variables for use in formulas
	SOPtimes = [15 105 195 250];
	startTime = 100;
	endTime = 205;

	units = "ug/dL";// update for QSDMA

//-----------/Variable Declarations-----------------------
path = ConvertFilePath(GetDefaultDirectory());

include(ConvertFilePath(path||"Libraries\AssayDev_TablePreparation2.jsl"));
include(ConvertFilePath(path||"Libraries\AssayDev_FunctionLibrary2.jsl"));
include(ConvertFilePath(path||"Libraries\AssayDev_Utilities.jsl"));

////////////////////////////////////////
//                                    //
//            Functions               //
//                                    //
////////////////////////////////////////

checkVersion = Function( {minVer},
	{default local},
	currVer = JMP Version();
	currWords = words(currVer,".");
	minWords = words(minVer,".");
	minBackHalf = If(nitems(minWords)==1,"0",concatitems(minWords[2::nitems(minWords)],""));
	backHalf = If(nitems(currWords)==1,"0",concatitems(currWords[2::nitems(currWords)],""));
	newNumVer = Num(currWords[1]||"."||backHalf);
	newMinVer = Num(minWords[1]||"."||minBackHalf);
	
	If(newNumVer >= newMinVer, Return(1),Return(0));
);

wrongVer = Function( {maxVer},
	{Default Local},
	New Window( "Requires JMP " || Char( maxVer ),
		<<Modal,
		Text Box( "This addin requires the used of JMP " || Char( maxVer ) || "+" ),
		Button Box( "OK" )
	)
);

qsdmaPtPriemannSlope = Function({tableName, uniqueColName, timeColName, respColName, startTime, endTime, normTimeColName = ""}, {default local},
	//tableName = dt;
	//uniqueColName = "uniqueCurveID";
	//timeColName = "TimeFromSampleDispense:sec";
	//respColName = "ReflDens_avg";
	//startTime = 100;
	//endTime = 205;
	//normTimeColName = "Canon Time";
	
	t1 = tableName << New Column( "P2P Slope - Response",
		Numeric,
		Continuous,
		Set Formula( 
			If( AsColumn(uniqueColName) == Lag( AsColumn(uniqueColName) ),
				( AsColumn(respColName) - Lag( AsColumn(respColName) )) / (AsColumn(timeColName) - Lag( AsColumn(timeColName) )) 
			)
		)
	);
	t2 = tableName << New Column( "P2P Slope - Int",
		Numeric,
		Continuous,
		Set Formula( 
			AsColumn(respColName)  - AsColumn(timeColName) * :Name( "P2P Slope - Response" ) 
		)
	);
	/*Summarize(tableName, a = By(AsColumn(normTimeColName)));
	For(i=1,i<=nitems(a),i++,
		SubstituteInto(a,a[i],Num(a[i]))
	);
	minNormTime = Min(Matrix(a));
	maxNormTime = Max(Matrix(a));*/
	
	minRdPt = tableName << get rows where(AsColumn(normTimeColName) == startTime);
	maxRdPt = tableName << get rows where(AsColumn(normTimeColName) == endTime);
	canonMin = tableName:"Read Point"n[minRdPt[1]];
	canonMax = tableName:"Read Point"n[maxRdPt[1]];
	t3 = tableName << New Column( normTimeColName || " Progress Curve",
		Numeric,
		Continuous,
		Set Formula( AsColumn(normTimeColName) * :Name( "P2P Slope - Response" ) + :Name( "P2P Slope - Int" ) )
	);
	t4 = tableName << New Column( normTimeColName || " P2P Slope Values",
		Numeric,
		Continuous,
		Set Formula(
			If( Lag( AsColumn(uniqueColName) ) == AsColumn(uniqueColName),
				(AsColumn(normTimeColName || " Progress Curve") - Lag( AsColumn(normTimeColName || " Progress Curve") )) / (AsColumn(normTimeColName) - Lag( AsColumn(normTimeColName) )) 
			)
		)
	);
	t5 = tableName << New Column( "Slope Vals for AR",
		Numeric,
		Continuous,
		Set Formula(
			If( :"Read Point"n == 7,
				:Name( "P2P Slope - Response" )
				,
				AsColumn(normTimeColName || " P2P Slope Values")
			)
		)
	);
	t6 = tableName << New Column( "Rebuilt Curve",
		Numeric,
		Continuous,
		Set Formula(
			If( AsColumn(uniqueColName) == Lag( AsColumn(uniqueColName) ) & :"Read Point"n > canonMin,
				:"Slope Vals for AR"n + Lag( :Rebuilt Curve ),
				0
			)
		)
	);
	t7 = tableName << New Column("AUC AR-Read Window "||Char(canonMin + 1)||" - "||Char(canonMax),
		Numeric,
		Continuous,
		Set Formula(
			Col Sum( :"Slope Vals for AR"n, AsColumn(uniqueColName) )
		)
	);
	/*
	dt_algorithm << Select Where( :"Read Point"n == canonMax );
	Column(dt_algorithm,uniqueColName) << set selected;
	dt_algorithm:"Rebuilt Curve"n << set selected;
	
	dt_Datasub = dt_algorithm << Subset( Selected Rows( 1 ), Selected Columns( 1 ) );
	dt_Datasub:"Rebuilt Curve"n << Set Name( "AUC AR-Read Window "||Char(canonMin + 1)||" - "||Char(canonMax) );
	dt_algorithm << Update( With( dt_Datasub ), Match Columns( AsColumn(uniqueColName) = AsColumn(uniqueColName) ), All );*/
	
	t1 << delete formula;
	t2 << delete formula;
	t3 << delete formula;
	t4 << delete formula;
	t5 << delete formula;
	t6 << delete formula;
	t7 << delete formula;
	
	t1 << hide(1);
	t2 << hide(1);
	t3 << hide(1);
	t4 << hide(1);
	t5 << hide(1);
	t6 << hide(1);
);

arCalc = Function({tableName},{default local},
	//tablename = currentdatatable();
	parseResp = Parse(EvalInsert(":\!"^respCol^\!"n")); //added when asColumn() stopped working when col vars moved outside function
	tableName = tablePrep( tableName, knownChemType );

	//Sets up MMDDYYYY date for Table Naming
	todayDate=Short Date( Today() );
	newTodayDate = Munger(todayDate,1,"/","");
	nextTodayDate = Munger(newTodayDate,1,"/","");

	//Sets up Variables for new naming nomenclature (rules in revision history)
	table = tableName<<GetName;
	titleName = Word(1,table,"-");
	dateName = Substr(table,Munger( table, 1, "-" )+1,6);
	
	tableName << New Column( "Canon Time",
		Numeric,
		Continuous,
		Set Formula( 
			Try(cannonTimes[:"Read Point"n],.)
		)
	);
	tableName:"Canon Time"n << delete formula;
	tableName:"Canon Time"n << hide(1);

	//preDevelopmentMetric{tableName,yColumn,xColumn,byColumn,columnName,metric="sp",direction="Dry",eventOneTime="NULL",eventTwoTime="NULL",singlePoint=1};
	preDevelopmentMetric( tableName, respCol, timeCol, uniqueCol, "Mean(Response, Dry)", "avg", "Dry", "NULL", "NULL", 1 );
	
	tableName << New Column( "Dry Normalized Response", Numeric, Continuous, Set Formula( parseResp / :"Mean(Response, Dry)"n ) );
	tableName:"Dry Normalized Response"n << Delete Formula;

	tableName:"Mean(Response, Dry)"n << hide(1);
	tableName:"Dry Normalized Response"n << hide(1);
	
	qsdmaPtPriemannSlope(tableName, uniqueCol, timeCol, respCol, startTime, endTime, "Canon Time");
	
	tableName << New Column( "Corrected AR",
		Numeric,
		Continuous,
		Set Formula( :Name( "AUC AR-Read Window 7-13" ) * :"Assay Gain"n + :"Assay Offset"n )
	);
	tableName:"Corrected AR"n << delete formula;
	
	tableName << SetName( titleName || "-" || dateName || "_" || knownChemType || " AR_" || nextTodayDate || "_progCurves" );
	
	Return(tableName)
);

flagging = Function({tableName},{default local},//, flagParams},{default local},
	//tableName = currentdatatable();
	parseUnique = Parse(EvalInsert(":\!"^uniqueCol^\!"n")); //added when asColumn() stopped working when col vars moved outside function
	
	temp1 = tableName << New Column( "Predicted Progress Curve Point from Previous",
		Numeric,
		Continuous,
		Set Formula(
			If( parseUnique == Lag( parseUnique ) & cannonMin < :"Read Point"n < cannonMax,
				(nestedLinear["linear"]["b"] + nestedLinear["linear"]["m"] * (:"Read Point"n - 1)) * Lag( :Slope Vals for AR ) + (nestedLinear["quad"]["c"] +
				nestedLinear["quad"]["b"] * (:"Read Point"n - 1) + nestedLinear["quad"]["a"] * (:"Read Point"n - 1) ^ 2)
			)
		)
	);
	
	temp2 = tableName << New Column( "Progress Curve Predicted Bias to Measured",
		Numeric,
		Continuous,
		Set Formula( If( :"Read Point"n == (cannonMin + 1), 0, :Slope Vals for AR - :Predicted Progress Curve Point from Previous ) )
	);
	
	temp3 = tableName << New Column( "Aberrant Point",
		Numeric,
		Continuous,
		Set Formula( If( :Progress Curve Predicted Bias to Measured > aberrantThresh[1], 1, :Progress Curve Predicted Bias to Measured < aberrantThresh[2], -1, 0 ) )
	);
		
	For( i = 1, i < N Col( SOPTimes ), i++,
		colNametemp1 = "Slope(" || Char( SOPTimes[i] ) || "-" || Char( SOPTimes[i + 1] ) || ")";
		genericInterpMetric( tableName, respCol, timeCol, uniqueCol, colNametemp1, SOPTimes[i], SOPTimes[i+1], "Slope" );
		Column(tableName,colNameTemp1) << hide(1);
	);
	
	temp4 = tableName << New Column( "AR-Script",
		Formula(:"Corrected AR"n)
		/*Formula(
			If(
				AsColumn(arCol) == -999, -2
			,
				Contains(:Name("Flag_nums"),"*") > 0, -1 // only takes 1 * fail to cause suppression
			,
				AsColumn(arCol)
			)
		)*/
	);
	
	temp1 << delete formula;
	temp2 << delete formula;
	temp3 << delete formula;
	temp4 << delete formula;

	temp1 << hide(1);
	temp2 << hide(1);
	temp3 << hide(1);
	
	Return(tableName);
);

finishingOff = Function({tableName},{default local},
	//tableName = currentdatatable();
	tblName = tableName << get name;
	tblWords = Words(tblName,"_");
	If(tblWords[nitems(tblWords)] == "progCurves",
		tblName = Munger(tblName,1,"_progCurves","")
	);
	parseUnique = Parse(EvalInsert(":\!"^uniqueCol^\!"n")); //added when asColumn() stopped working when col vars moved outside function

	//adds version column
	tableName << New Column( "Roswell AR Calc Version", Character( 10 ), Formula( Eval( arCalcVer ) ) );
	tableName:"Roswell AR Calc Version"n << delete formula;

	//adds units column
	tableName << New Column( "Units_Script", Character(10), << Set each value(units));

	//moves important columns to first
	tableName << MoveSelectedColumns(
		{
			"AR-Script",
			"Corrected AR",
			//"Units_Script",
			//"Flag",
			//"Flag_nums", 
			"uniqueCurveID",
			"Roswell AR Calc Version",
			"Chem Type",
			"Inst Type",
			"TimeFromSampleDispense:sec",
			"ReflDens_avg",
			"Instrument ID"
		},
		To First
	);


	//Hides and groups all columns that are listed in 'hidecols'
	//Default is for any column to be unhidden unless added to this list
	hideCols = {
		//specific to QSDMA
		"P2P Slope - Response", "P2P Slope - Int", "Canon Time", "Canon Time Progress Curve", "Canon Time P2P Slope Values",
		"Slope Vals for AR", "Predicted Progress Curve Point from Previous", "Progress Curve Predicted Bias to Measured",
		"Aberrant Point", "Rebuilt Curve", "Mean(Response, Dry)", "Dry Normalized Response", "Date and Time Script Run",
		//
		"Alg Calc Ar Error Status :4", "Algorithm Conc Error Flags", "Algorithm IM Error Flags", "Algorithm Status", "AR Qualifer",
		"AR Qualifier", "AR2", "AR2 Qualifer", "AR2 Qualifier", "Concentration units", "Curve Area", "Curve Cubic", "Curve Fifth", "Curve File Version",
		"Curve Intercept", "Curve Linear", "Curve Quad", "Curves Version :5", "Date", "Date-orig", "Dilution Parts", "Dilution Type", "Discrepant Type",
		"Dry Read Finish", "Dry Read Start", "DryReadingMean", "Final Scalar", "Flag :3", "Flag1 :4", "Flag2 :4", "Flag3 :4", "From Optics Module",
		"Gain Applied", "Gain Applied :4", "Gain Applied 2", "GMTime", "ID Source :2", "Log Entry Timestamp :3", "Normalized RD", "Num Dry Reads :2",
		"Num Of Assays", "Num Of Points :2", "Num Of Readings :2", "Num Wavelengths Used :4", "Offset Applied", "Offset Applied :4",
		"Offset Applied Type", "Paired Results Flag :4", "Point :3", "Post Analysis Notes", "Progress Curve Analysis", "Qual :4", "Qualifier",
		"RD Normalization Reading", "Read Point", "Reading Time", "Reading2 :3", "Reflective :2", "Re-Review of Consumable/Slide", "Run Done Timestamp",
		"Run Fault", "Sample Container", "Sample_conjugate_alq2", "Scalar", "Scalar Adjustment", "Segment", "Slide Load Position :4", "Spot Time",
		"Stored Wet Offset", "Stored WLC Offset", "Substrate_alq1", "Time", "Time Offset :2", "Time-orig", "Timeseries pt", "Timeseries RD2",
		"TS Read Flag", "uldry Intensity", "ulfalse light Molded", "ulfalselight", "ulfalselight Laminate", "ulwet Intensity", "Units :4", "Units :5",
		"Wash 1 End", "Wash 2 End", "Wash1_alq3", "Wavelength", "Wavelength2", "Wavelength3", "Wavelengths Used", "X Intersect", "Y Intersect"
	};
		
	hideGroupCols = {};
	For( i = 1, i <= N Cols( tableName ), i++,
		a = Column( tableName, i ) << getname;
		If( Contains( hideCols, a ) > 0,
			Column( tableName, i ) << hide( 1 );
			Insert Into( hideGroupCols, a );
		);
	);
	tableName << groupcolumns( "Hidden Columns", hideGroupCols );
	tableName << MoveColumnGroup( To Last, "Hidden Columns" );

	
	tableName << Select Where( parseUnique != Lag( parseUnique, -1 ) | Row() == N Row() );

	//Get subset with just the results
	dt_justResult = tableName << Subset(
		output table name( tblName || "_justResults" )
	);
	tableName << SelectAllRows;
	tableName << InvertRowSelection;




	Return(dt_justResult);
);


////////////////////////////////////////
//                                    //
//              Main                  //
//                                    //
////////////////////////////////////////

If( Length( Include File List() ) == 1,
	
	If( checkVersion( minJMPver ) == 1,
		trackUsage(u,addinID);

		Try(
			dt_start = Open();
			flagTable = arCalc( dt_start );
			finishTable = flagging( flagTable );
			finalTable = finishingOff( finishTable );
			,
			Print("No Table Opened");
		);
	,
		wrongVer( minJMPver );
	)
	,
	Print( knownChemType || " AR script was included from another source" );
);
