//Author:
//Nathan Clark
//IDEXX Laborabories, Inc.
//Westbrook, ME
//nathan-clark@idexx.com

//------------------Revision History for both script and Help File--
//
// B4 NClark 022619
//		-> added variables to send to new functions for auto update and tracking
//		-> added included to utilities.jsl
//		-> added check functions in main function of script
// B3 NClark 081817
//		-> Updated graphics script (in table and report) to work when no table present (like a jrn)
//			-> Fixed so won't get hung up looking for a rowstate for a row that doesn't exisit
// B2 NClark 053017
//		-> working recall
//		-> Help not implemented yet[working help]
//		-> "dashed" Egg of shame(less than 24)
//		-> Proper handling of excluded/hidden rows
//		-> BY not implemented yet[Test BY Vars]
// B1 NClark 050917
//		-> First Beta released(B1)
//------------------------------------------------------------------

NamesDefaultToHere(1);

include("$ADDIN_HOME(com.idexx.assayDevLibraries2)\AssayDev_Utilities.jsl");

u = Get Environment Variable("username");
addinID = "RnD_SDMA-t_EggOverlay";
addinLib = "com.idexx.assayDevLibraries2";

if(isMissing(checkForUpdate(addinID)),
	checkForUpdate(addinLib)
);
trackUsage(u,addinID);

//clearglobals();
orig = currentDataTable();
If(IsEmpty(orig),orig=open());
nc = ncol(orig);
lbWidth = 130;
notImplemented = Function({},
	New Window("Feature Not Available",<<Modal,TextBox("This feature has not been implemented yet."),ButtonBox("OK"))
);
Help = expr(Open( "$ADDIN_HOME(com.idexx.nclark.exactBinom)\ExactBinomial_Help.pdf" ));
IndRow = expr(Open( "$ADDIN_HOME(com.idexx.nclark.exactBinom)\ExactBinomSample-Individual Row.jmp" ));
Summarized = expr(Open( "$ADDIN_HOME(com.idexx.nclark.exactBinom)\ExactBinomSample-Summarized.jmp" ));
About = Expr(Dialog(
	VList("Egg Overlay vB2",
		"",
		"Nathan Clark",
		"IDEXX Laboratories, Inc.",
		"Westbrook, ME 04092",
		"nathan-clark@idexx.com"
	)
));

exprCancel = Expr(eggOverlayDlg << Close Window);

::globalListEgg = {::ba1ListEgg,::ba2ListEgg,::ba3ListEgg,::ba4ListEgg}; //Mean, SD, N, By - respectively
//::globalVarEgg = {::ba1VarEgg};
::globalVarEgg = {::ba1VarEgg,::ba2VarEgg};//comboset, textalpha - respectively

::lbListEgg = Expr({::colListYegg,::colListXegg,::colListNegg,::colListBegg });
//::lbVarEB = Expr({::dataOrg});
lbVarEgg = Expr({comboSet,newAlpha});


populateGlobals = Function({globalList,localList,diagOption},
	For(i=1,i<=N Items(globalList),i++,
		//show(nitems(globalList));
		Eval(
			Substitute(
				Expr(
					Unlock Globals(glVar);
					/*Match(diagOption,
						1, glVar = lb << Get Items
					,
						2, glVar = lb << Get
					,
						3, glVar = lb
					);*/
					Try(
						glVar = lb << Get Items
					,
						Try(
							glVar = lb << get
						,
							glVar = lb
						)
					);
					Lock Globals(glVar);
				),
				Expr(lb),localList[i],
				Expr(glVar),Name Expr(globalList[i])
			)
		);
	);
	Return(1)
);

recallItems = Function({},
//Is List will produce error if ba1List is not declared
	//If error, declare vars, otherwise get vars
	colList = orig << Get Column Names( String );
	Try(
		For( i = 1, i <= N Items( ::globalListEgg ), i++,
			nextList = ::globalListEgg[i];
			For( j = 1, j <= N Items( nextList ), j++,
				If( N Row( Loc( colList, nextList[j] ) ) > 0,
					Eval( Substitute( Expr( lb << Append( item ) ), Expr( lb ), ::lbListEgg[i], Expr( item ), nextList[j] ) )
				)
			);
		)
	,
		Print( "No columns to recall." )
	);

	Try(
		::comboObj<<set(Num(::ba1VarEgg))
	);
	Try(
		::textObj<<settext(::ba2VarEgg);
		newAlpha = ::ba2VarSDCI
	);
);

addEggTableScript = Function({},
	unparseSD = Eval Insert( ":name( \!"^sdCol^\!" )" );
	unparseMean = Eval Insert( ":name( \!"^meanCol^\!" )" );
	unparseRuns = Eval Insert( ":name( \!"^runsCol^\!" )" );
	Eval(
		EvalExpr(
			orig << New Script("Egg Overlay",
				sds = {};
				means = {};
				nRuns = {};
				lowerSDInt1 = {};
				upperSDInt1 = {};
				meanInt1 = {};
				colors = {};
				alpha = Expr(alpha);
				For Each Row(Expr(orig),
					If(
						Is Missing( Expr(Parse(unparseSD)) ) |
						Is Missing( Expr(Parse(unparseMean)) ) | Expr(Parse(unparseRuns)) == 0,
						Empty(),
						s = Expr(Parse(unparseSD));
						insertInto(sds, s);
						u = Expr(Parse(unparseMean));
						insertInto(means, u);
						n = Expr(Parse(unparseRuns));
						insertInto(nRuns,n);
						insertInto(colors,Color Of( Row State() ) );
						insertInto(lowerSDInt1, s - s * Root(
							(n - 1) / ChiSquare Quantile( 1 - alpha / 2, n - 1 ),
							2
						));
						insertInto( upperSDInt1, s * Root( (n - 1) / ChiSquare Quantile( alpha / 2, n - 1 ), 2 ) - s);
						insertInto(meanInt1,Normal Quantile( 1 - alpha / 2 ) * s / Root( n, 2 ));
					);
				);

				maxAxisY = Max(upperSDInt1) + Max(sds);
				minAxisY = Min(sds)- Max(lowerSDInt1);
				maxAxisX = Max(means) + Max(meanInt1);
				minAxisX = Min(means) - Max(meanInt1);
				biv = Expr(orig) << Bivariate(
					Y( Expr(Parse(unparseSD)) ),
					X( Expr(Parse(unparseMean)) ),
					Fit Special( Intercept( 0 ), {Line Color( "Medium Dark Gray" )} ),
					SendToReport(
						Dispatch(
							{},
							"1",
							ScaleBox,
							{Min( minAxisX * 0.9 ), Max( maxAxisX * 1.1 ), Inc( 0.005 ),
							Minor Ticks( 0 )}
						),
						Dispatch(
							{},
							"2",
							ScaleBox,
							{Min( minAxisY * 0.9 ), Max( maxAxisY * 1.1 ),
							Inc( 0.00025 ), Minor Ticks( 0 )}
						)
					),
					By(Expr(::colListBegg<<getitems))
				);
				Report(biv)[Outlinebox(2)]<<close;

				Expr(
					Parse(
						"Eval(
							Eval Expr(
								Report(biv)[Framebox(1)] << Add Graphics Script(
									1,
									Description( \!"Egg Overlay\!" ),
									sds = Expr(sds);
									means = Expr(means);
									meanInt = Expr(meanInt1);
									upperSDInt = Expr(upperSDInt1);
									lowerSDInt = Expr(lowerSDInt1);
									colors = Expr(colors);

									EggBottomX = J( 181, 1, 0 );
									EggBottomY = J( 181, 1, 0 );
									EggTopX = J( 181, 1, 0 );
									EggTopY = J( 181, 1, 0 );
									For( i = 0, i <= 180, i++,
										A = i * 2 * Pi() / 360;
										EggTopX[i + 1] = Cos( A );
										EggTopY[i + 1] = Sin( A );
										A = A + Pi();
										EggBottomX[i + 1] = Cos( A );
										EggBottomY[i + 1] = Sin( A );
									);

									/*For(i=1,i<=nitems(sds),i++,
										If( Excluded(RowState(i)) == 1 | Hidden(RowState(i)), Empty()
										,
											If(nRuns[i] >= 24,
												Transparency( 0.25 );
												PenColor(colors[i]);
												FillColor(colors[i]);
												Polygon( means[i] + EggTopX * meanInt[i], sds[i] + EggTopY * upperSDInt[i] );
												Polygon( means[i] + EggBottomX * meanInt[i], sds[i] + EggBottomY * lowerSDInt[i] )
											,
												Transparency(1);
												PenColor(colors[i]);
												LineStyle(\!"Dashed\!");
												Line( means[i] + EggTopX * meanInt[i], sds[i] + EggTopY * upperSDInt[i] );
												Line( means[i] + EggBottomX * meanInt[i], sds[i] + EggBottomY * lowerSDInt[i] )
											)
										)
									)*/

									For( i = 1, i <= N Items( sds ), i++,
										If(IsMissing(Row State(i)),
											If( nRuns[i] >= 24,
												Transparency( 0.25 );
												Pen Color( colors[i] );
												Fill Color( colors[i] );
												Polygon(
													means[i] + EggTopX * meanInt[i],
													sds[i] + EggTopY * upperSDInt[i]
												);
												Polygon(
													means[i] + EggBottomX * meanInt[i],
													sds[i] + EggBottomY * lowerSDInt[i]
												);
											,
												Transparency( 1 );
												Pen Color( colors[i] );
												Line Style( \!"Dashed\!" );
												Line(
													means[i] + EggTopX * meanInt[i],
													sds[i] + EggTopY * upperSDInt[i]
												);
												Line(
													means[i] + EggBottomX * meanInt[i],
													sds[i] + EggBottomY * lowerSDInt[i]
												);
											)
										,
											If( Excluded( Row State( i ) ) == 1 | Hidden( Row State( i ) ),
												Empty(),
												If( nRuns[i] >= 24,
													Transparency( 0.25 );
													Pen Color( colors[i] );
													Fill Color( colors[i] );
													Polygon(
														means[i] + EggTopX * meanInt[i],
														sds[i] + EggTopY * upperSDInt[i]
													);
													Polygon(
														means[i] + EggBottomX * meanInt[i],
														sds[i] + EggBottomY * lowerSDInt[i]
													);
												,
													Transparency( 1 );
													Pen Color( colors[i] );
													Line Style( \!"Dashed\!" );
													Line(
														means[i] + EggTopX * meanInt[i],
														sds[i] + EggTopY * upperSDInt[i]
													);
													Line(
														means[i] + EggBottomX * meanInt[i],
														sds[i] + EggBottomY * lowerSDInt[i]
													);
												)
											)
										)
									)
								)
							)
						);"
					)
				)
			)
		)
	);
);

runOK = Expr(

	populateGlobals(::globalListEgg,::lbListEgg,1);
	newAlpha = ::textObj<<get text;
	If( Is Missing( Num(newAlpha) ) == 0,
		alpha = Num( newAlpha );
		comboSet = Char(::comboObj<<get)
	,
		newAlpha="";
		comboSet = Char(::comboObj<<get);
		Match( comboSet,
			"1", alpha = 0.10,
			"2", alpha = 0.05,
			"3", alpha = 0.01
		)
	);
	populateGlobals(::globalVarEgg,lbVarEgg,3);

	If(Nitems(::colListYegg<<get items) < 1 | Nitems(::colListXegg<<get items) < 1| Nitems(::colListNegg<<get items) < 1,
		Dialog("Mean / SD / n are required for analysis to run");throw()
	);

	Eval(exprCancel);
	//show(::ba1ListEgg,::ba2ListEgg,::ba3ListEgg);
	meanCol = ::ba1ListEgg[1];
	sdCol = ::ba2ListEgg[1];
	runsCol = ::ba3ListEgg[1];
	meanVar = Parse( Eval Insert( ":name( \!"^meanCol^\!" )" ) );
	sdVar = Parse( Eval Insert( ":name( \!"^sdCol^\!" )" ) );
	runsVar = Parse( Eval Insert( ":name( \!"^runsCol^\!" )" ) );
	//show(alpha);

	sds = {};
	means = {};
	lowerSDInt1 = {};
	upperSDInt1 = {};
	meanInt1 = {};
	nRuns = {};
	colors = {};
	For Each Row(orig,
		If(
			Is Missing( sdVar ) |
			Is Missing( meanVar ) | runsVar == 0,
			Empty(),
			s = sdVar;
			insertInto(sds, s);
			u = meanVar;
			insertInto(means, u);
			n = runsVar;
			insertInto(nRuns,n);
			insertInto(colors,Color Of( Row State() ) );
			insertInto(lowerSDInt1, s - s * Root(
				(n - 1) / ChiSquare Quantile( 1 - alpha / 2, n - 1 ),
				2
			));
			insertInto( upperSDInt1, s * Root( (n - 1) / ChiSquare Quantile( alpha / 2, n - 1 ), 2 ) - s);
			insertInto(meanInt1,Normal Quantile( 1 - alpha / 2 ) * s / Root( n, 2 ));
		);
	);

	maxAxisY = Max(upperSDInt1) + Max(sds);
	minAxisY = Min(sds)- Max(lowerSDInt1);
	maxAxisX = Max(means) + Max(meanInt1);
	minAxisX = Min(means) - Max(meanInt1);
	biv = orig << Bivariate(
		Y( sdVar ),
		X( meanVar ),
		Fit Special( Intercept( 0 ), {Line Color( "Medium Dark Gray" )} ),
		SendToReport(
			Dispatch(
				{},
				"1",
				ScaleBox,
				{Min( minAxisX * 0.9 ), Max( maxAxisX * 1.1 ), Inc( 0.005 ),
				Minor Ticks( 0 )}
			),
			Dispatch(
				{},
				"2",
				ScaleBox,
				{Min( minAxisY * 0.9 ), Max( maxAxisY * 1.1 ),
				Inc( 0.00025 ), Minor Ticks( 0 )}
			)
		),
		By(::colListBegg<<getitems)
	);
	Report(biv)[Outlinebox(2)]<<close;

	Eval(
		Eval Expr(
			Report(biv)[Framebox(1)] << Add Graphics Script(
				1,
				Description( "Egg Overlay" ),
				sds = Expr(sds);
				means = Expr(means);
				meanInt = Expr(meanInt1);
				upperSDInt = Expr(upperSDInt1);
				lowerSDInt = Expr(lowerSDInt1);
				nRuns = Expr(nRuns);
				colors = Expr(colors);

				EggBottomX = J( 181, 1, 0 );
				EggBottomY = J( 181, 1, 0 );
				EggTopX = J( 181, 1, 0 );
				EggTopY = J( 181, 1, 0 );
				For( i = 0, i <= 180, i++,
					A = i * 2 * Pi() / 360;
					EggTopX[i + 1] = Cos( A );
					EggTopY[i + 1] = Sin( A );
					A = A + Pi();
					EggBottomX[i + 1] = Cos( A );
					EggBottomY[i + 1] = Sin( A );
				);

				/*For(i=1,i<=nitems(sds),i++,
					//show(nRuns[i]);
					If( Excluded(RowState(i)) == 1 | Hidden(RowState(i)), Empty()
					,
						If(nRuns[i] >= 24,
							//Print("Greater or equal to 24");
							Transparency( 0.25 );
							PenColor(colors[i]);
							FillColor(colors[i]);
							Polygon( means[i] + EggTopX * meanInt[i], sds[i] + EggTopY * upperSDInt[i] );
							Polygon( means[i] + EggBottomX * meanInt[i], sds[i] + EggBottomY * lowerSDInt[i] )
						,
							//Print("Less than 24");
							Transparency(1);
							PenColor(colors[i]);
							LineStyle("Dashed");
							Line( means[i] + EggTopX * meanInt[i], sds[i] + EggTopY * upperSDInt[i] );
							Line( means[i] + EggBottomX * meanInt[i], sds[i] + EggBottomY * lowerSDInt[i] )
						)
					)
				)*/

				For( i = 1, i <= N Items( sds ), i++,
					Try(
						If(IsMissing(Row State(i)),
							If( nRuns[i] >= 24,
								Transparency( 0.25 );
								Pen Color( colors[i] );
								Fill Color( colors[i] );
								Polygon(
									means[i] + EggTopX * meanInt[i],
									sds[i] + EggTopY * upperSDInt[i]
								);
								Polygon(
									means[i] + EggBottomX * meanInt[i],
									sds[i] + EggBottomY * lowerSDInt[i]
								);
							,
								Transparency( 1 );
								Pen Color( colors[i] );
								Line Style( "Dashed" );
								Line(
									means[i] + EggTopX * meanInt[i],
									sds[i] + EggTopY * upperSDInt[i]
								);
								Line(
									means[i] + EggBottomX * meanInt[i],
									sds[i] + EggBottomY * lowerSDInt[i]
								);
							)
						,
							If( Excluded( Row State( i ) ) == 1 | Hidden( Row State( i ) ),
								Empty(),
								If( nRuns[i] >= 24,
									Transparency( 0.25 );
									Pen Color( colors[i] );
									Fill Color( colors[i] );
									Polygon(
										means[i] + EggTopX * meanInt[i],
										sds[i] + EggTopY * upperSDInt[i]
									);
									Polygon(
										means[i] + EggBottomX * meanInt[i],
										sds[i] + EggBottomY * lowerSDInt[i]
									);
								,
									Transparency( 1 );
									Pen Color( colors[i] );
									Line Style( "Dashed" );
									Line(
										means[i] + EggTopX * meanInt[i],
										sds[i] + EggTopY * upperSDInt[i]
									);
									Line(
										means[i] + EggBottomX * meanInt[i],
										sds[i] + EggBottomY * lowerSDInt[i]
									);
								)
							)
						)
						,
						If( nRuns[i] >= 24,
							Transparency( 0.25 );
							Pen Color( colors[i] );
							Fill Color( colors[i] );
							Polygon(
								means[i] + EggTopX * meanInt[i],
								sds[i] + EggTopY * upperSDInt[i]
							);
							Polygon(
								means[i] + EggBottomX * meanInt[i],
								sds[i] + EggBottomY * lowerSDInt[i]
							);
						,
							Transparency( 1 );
							Pen Color( colors[i] );
							Line Style( "Dashed" );
							Line(
								means[i] + EggTopX * meanInt[i],
								sds[i] + EggTopY * upperSDInt[i]
							);
							Line(
								means[i] + EggBottomX * meanInt[i],
								sds[i] + EggBottomY * lowerSDInt[i]
							);
						)
					)
				)
			)
		)
	);
	addEggTableScript();
);

//Constructs dialog and sets up variables for subsequent analysis
eggOverlayDlg = New Window( "Egg Overlay",
	Border Box( Left( 3 ), top( 2 ),
		V List Box(
			Text Box( "Choose columns for Egg Overlay Analysis" ),
			H List Box(
				Panel Box( "Select Columns",
					colListData = Col List Box(
						All,
						width( lbWidth ),
						nLines( Min( nc, 10 ) )
					)
				),
				V List Box(
					Panel Box( "Cast Selected Columns into Roles",
						Lineup Box( N Col( 2 ), Spacing( 3 ),
							Button Box( "Mean Column",
								::colListYegg << Append( colListData << GetSelected )
							),
							::colListYegg = Col List Box( width( lbWidth ), minitems( 1 ), maxitems( 1 ), nLines( 2 ), numeric ),
							Button Box( "SD Column",
								::colListXegg << Append( colListData << GetSelected )
							),
							::colListXegg = Col List Box( width( lbWidth ), minitems(1), maxitems( 1 ), nLines( 2 ), numeric ),
							Button Box( "# Runs",
								::colListNegg << Append( colListData << GetSelected )
							),
							::colListNegg = Col List Box( width( lbWidth ), minitems(1), maxitems( 1 ), nLines( 2 ), numeric ),
							Button Box( "By",
								notImplemented()//)::colListBegg << Append( colListData << GetSelected )
							),
							::colListBegg = Col List Box( width( lbWidth ), nLines( 1 ) )
						)
					)
				),
				Panel Box( "Action",
					Lineup Box( N Col( 1 ),
						Button Box( "OK", Eval(runOK)),
						Button Box( "Cancel", Eval(exprCancel) ),
						Text Box( " " ),
						Button Box( "Remove",
							::colListYegg << RemoveSelected;
							::colListXegg << RemoveSelected;
							::colListNegg << RemoveSelected;
							::colListBegg << RemoveSelected;
						),
						Button Box( "Recall", recallItems() ),
						Button Box( "Help", Eval(notImplemented)),//Eval(Help) ),
						Button Box( "About", Eval(About) )
					)
				)
			),
			H List Box(
				Panel Box( "Alpha",
					H List Box(
						V List Box(
							TextBox("Select Alpha"),
							H List Box(
								::comboObj = Combo Box( {"0.10", "0.05", "0.01"}, <<Set( 2 ) ),
								TextBox("   or")
							),
							H List Box(
								TextBox("Enter Desired Alpha "),
								::textObj = Text Edit Box("",<<Script(newAlpha=::textObj<<GetText))
							)
						)
					)
				)
			)
		)
	)
);
//----------------------------/SUB ExactBinomDlg-----------------------------------
