//Author(s)
//NClark
//IDEXX Laboratories, Inc.
//Westbrook, ME 04092

//Tool Calculates AR for the Bile Acids Assay

//------------------Revision History for both script and Help File--
//
//	2.2.0.0 NClark 030921
//		-> Updated finshing off to use Slide Lot as lot column for concentration calculation
//	2.1.0.1 NClark 021121
//		-> updated two tableprep calls to reset table variable so not lost if tableprep makes new table
//	2.1.0.0 NClark 021021
//		-> updated use of uniqueAssayID to uniqueCurveID
//	2.0.0.0 NClark 051420
//		-> Updated flag limits to most recent updates
//	1.9.0.0 Nclark 051220
//		-> Added tableConcCalc() function to 'finshing off'
//	1.8.0.1 NClark 121219
//		-> fixed lack of proper comment on line 12
//	1.8 NClark 121119
//		-> Made flag 91 suppressible
//	1.7 NClark 110619
//		-> Updated SOPstartTime to 25 from 30
//	1.6 NClark 103019
//		-> removed flag and flag_nums formula
//		-> updated so no point 2 check so 1st point can't be glitch corrected (removed all point 2 check references)
//		-> Updated *4 flag threshold to 0.0005
//	1.5 NClark 102819
//		-> Updated DryNorm AR to DryNorm RD (as it's a corrected RD, not AR)
//		-> Verified final algorithm flags and thresholds
//	1.4 NClark 102219
//		-> Updated to existing flag #s where known
//		-> added residual variance flag information
//		-> updated dynamic AR to include residual variance data
//		-> fixed to correct units
//		-> removed defaults from function start
//		-> Updated read point glitch to be its own formula and not rely on read point
//		-> Updated so glitch points calculated for all glitches even though only 1st one is Corrected
//	1.3 NClark 102119
//		-> Updated algorithm method(s) to new Dynamic Region AR along with glitch detection
//		-> added in flagging information based on above AR work (manually coded in, not function based, yet)
//		-> updated units
//	1.2 NClark 082619
//		-> opened up flagging function to create AR-Script column (necessary to use multiAssay tool)
//		-> updated flagging function to bring in final AR col name
//	1.1 NClark 080519
//		-> Updated 'finishing off' to have isscriptable() to force error on 'after' column for move so user doesn't get dialog
//	1.0 NClark 080219
//		-> 1st version based on v7.0 of PROG AR Calculator
//------------------------------------------------------------------

Names Default To Here( 1 );
/*Dont think i need these namespaces if not basing off of generic tool(s)*/
/*may need for solid multi-assay performance*/
If( !Namespace Exists( "bileFunctions" ),
	New Namespace(
		"bileFunctions"
	)
);
bFunct = Namespace( "bileFunctions" );

//-----------Variable Declarations (above Main for easy access)--
	
	u = Get Environment Variable("username");
	addinID = "com.idexx.RnD_Bile";
	//addinLib = "com.idexx.assayDevLibraries2";

	updateIDs = {"com.idexx.assayDevLibraries2","com.idexx.RnD_Bile"};

	minJMPver = "14";

	listOfIDXassays = {28, 23, 18, 17, 30, 21};
	
	//version now tied to currently installed addin version
	//MAY NOT BE CORRECT WHEN TESTING
	Try(
		arCalcVer = Char( Get Addin( "com.idexx.RnD_Bile" ) << version )
		,
		Print( "Addin not installed yet" );
		arCalcVer = "v999";
	);
	//Known Chemistry to be used if assay info not available.
	knownChemType = "Bile";
	targetCode = {21};
		
	//Define the table variables for use in formulas
	SOPstartTime = 25;
	SOPendTime = 105;
	SOPtimes = [35 45 55 65];
	
	posThreshold = 0;
	negThreshold = -0.0008;
	
	//Variables starting as empty lists
	startTime1 = {};
	endTime1 = {};
	
	assayFlags = {
		{glitchCorrect, 1, "GlitchCorrect[75 76]"},
		{glitchSuppress, 2, "Glitch[*75]"},
		{quadSlopeFlag, -0.007, 0.5, "Quad[*82]"},
		{dryReadFlag, 0.103, "Dry[*77]"},
		{quadVslopeFlag, -0.00395, 0.000055, -0.00395, -0.000055, "QuadVSlope[*82]"},
		{arRange, -0.0005, 0.036, "ARrange[*91]"},
		{residVar, 0.0005,"ExceedVarLim[*4]"}
	};

	//extreme high dose flag values per species.
	//species must be all uppercase
	extremeHighDose = Associative Array( 
		{
			{"None", .}
		}
	);
		
	units = "umol/L";// update for Bile

//-----------/Variable Declarations-----------------------

include("$ADDIN_HOME(com.idexx.assayDevLibraries2)\AssayDev_FunctionLibrary2.jsl");
Include( "$ADDIN_HOME(com.idexx.assayDevLibraries2)\AssayDev_TablePreparation2.jsl" );
Include( "$ADDIN_HOME(com.idexx.assayDevLibraries2)\AssayDev_Utilities.jsl" );
//Include("R:\Systems_Chemistry_Engineering\Tools\Official JMP Addin Development\Official JMP Addin Working\Library Files2\AssayDev_FunctionLibrary2.jsl");
//include("R:\Systems_Chemistry_Engineering\Tools\Official JMP Addin Development\Official JMP Addin Working\Library Files2\AssayDev_TablePreparation2.jsl");

////////////////////////////////////////
//                                    //
//            Functions               //
//                                    //
////////////////////////////////////////

checkVersion = Function( {minVer},
	{default local},
	version = Num( Substitute( minVer, ".", "" ) );
	If( Num( Word( 1, JMP Version(), "." ) ) < version,
		a = 0,
		a = 1
	);
	Return( a );
);

wrongVer = Function( {maxVer},
	{Default Local},
	New Window( "Requires JMP " || Char( maxVer ),
		<<Modal,
		Text Box( "This addin requires the used of JMP " || Char( maxVer ) || "+" ),
		Button Box( "OK" )
	)
);

missingCols = Function( {},
	New Window( "Default Columns Not Present",
		<<Modal,
		Text Box( "Defaults chosen, but one or more default columns missing", <<setfontstyle( "bold" ), <<setfontsize( 12 ) ),
		Text Box( "" ),
		Button Box( "OK" ),

	)
);

tooManyNwAssays = Function( {},
	New Window( "More than 1 Assay present",
		<<Modal,
		Text Box( "More than the desired new Assays are present", <<setfontstyle( "bold" ), <<setfontsize( 12 ) ),
		Text Box( "Please subset each New IDEXX assay separately and run correct script" ),
		Text Box( "" ),
		Button Box( "OK" ),

	)
);

noNwAssays = Function( {},
	New Window( "No New Assays present",
		<<Modal,
		Text Box( "There are no new assays present in the table", <<setfontstyle( "bold" ), <<setfontsize( 12 ) ),
		Text Box( "Please consider just running the Table Preparation Script" ),
		Text Box( "" ),
		Button Box( "OK" ),

	)
);

wrongNwAssay = Function( {},
	New Window( "Assay not supported",
		<<Modal,
		Text Box( "The Assay in the table is not supported by this script", <<setfontstyle( "bold" ), <<setfontsize( 12 ) ),
		Text Box( "Please try again" ),
		Text Box( "" ),
		Button Box( "OK" ),

	)
);

scriptJustResults = Function( {tableName, uniqueCol},
	{default Local},
	dt_algorithm = tableName;
	parseUnique = Eval Insert( ":Name(\!"^uniqueCol^\!")" );
	Eval(
		Eval Expr(
			dt_algorithm << New Script(
				"Make justResults",
				tblName = Current Data Table() << Getname;
				Data Table( tblName ) << select all rows;
				Data Table( tblName ) << invert row selection;
				Try( newName = Munger( tblName, 1, "_progCurves", "" ), newName = tblName );
				Data Table( tblName ) << SelectWhere( Expr( Parse( parseUnique ) ) != Lag( Expr( Parse( parseUnique ) ), -1 ) );
				Data Table( tblName ) << Subset( output table name( newName || "_justResults" ) );
				Data Table( tblName ) << select all rows;
				Data Table( tblName ) << invert row selection;
			)
		)
	);
);

cannotReplace = Function( {},
	New Window( "Unable to Sort Data",
		<<Modal,
		Text Box(
			"JMP is unable to sort data table because existing reports are linked to this table. Please close those reports and try again.",
			<<setfontstyle( "bold" ),
			<<setfontsize( 12 )
		),
		Text Box( "" ),
		Button Box( "OK" ),

	)
);

cleanup = Function( {namespaceList},
	{},
	For(i=1,i<=nitems(namespaceList),i++,
		namespaceList[i] << delete namespace;
	);
	Throw();
);

dynamicARfun = Function( {table, timeCol, respCol, uniqueCol, startT, endT, timePtsv},
	{default local},
	
	//table = tableName;
	//timeCol = "TimeFromSampleDispense:sec";
	//respCol = "Dry Normalized Response";
	//uniqueCol = "uniqueCurveID";
	//startT = SOPstartTime;
	//endT = SOPendTime;
	//timePtsv = SOPtimes;
	
	parseRespCol = Parse(EvalInsert(":name(\!"^respCol^\!")"));
	parseTimeCol = Parse(EvalInsert(":name(\!"^timeCol^\!")"));
	parseUniqueCol = Parse(EvalInsert(":name(\!"^uniqueCol^\!")"));
	
	dt1 = table << Select Where( startT <= parseTimeCol <= endT ) << Subset( Selected Rows( 1 ), Selected Columns( 0 ), private );
	
	respMap = dt1 << Bivariate(
		Y( EvalExpr(parseRespCol) ),
		X( EvalExpr(parseTimeCol) ),
		Fit Special( Degree( 2 ), Centered Polynomial( 0 ), {Line Color( {212, 73, 88} )}, {Save Predicteds()} ),
		By( EvalExpr(parseUniqueCol) )
	);
	fitData = Try(
		Report( respMap[1] )["Parameter Estimates"][Table Box( 1 )] << Make Combined Data Table(invisible(1)),
		Report( respMap )["Parameter Estimates"][Table Box( 1 )] << Make Combined Data Table(invisible(1))
	);
	fitDataB = Try(
		Report( respMap[1] )["Summary of Fit"][Table Box( 1 )] << Make Combined Data Table(invisible(1)),
		Report( respMap )["Summary of Fit"][Table Box( 1 )] << Make Combined Data Table(invisible(1))
	);

	predName = Column(dt1,ncol(dt1)) << get name;
	parsePredName = Parse(EvalInsert(":name(\!"^predName^\!")"));

	dt1 << New Column("ResidualVariance",
		Formula(
			Col Sum(
				(parseRespCol - parsePredName)^ 2,parseUniqueCol) / Col Mean( parsePredName, parseUniqueCol )
		)
	);
	dt1:ResidualVariance << delete formula;

	keepList = EvalList({uniqueCol,"ResidualVariance"});
	show(keepList);
	For(i=ncol(dt1), i>=1, i--,
		If(Contains(keepList,Column(dt1,i) << Get Name) > 0,
			Empty()
			,
			deleteCol = Column(dt1,i) << Get Name;
			dt1 << delete columns(deleteCol);
		)
	);
	
	fitData2 = fitData << Split(
		Split By( :Term ),
		Split( :Estimate ),
		Group( EvalExpr(parseUniqueCol) ),
		Remaining Columns( Drop All ),
		Sort by Column Property,
		private
	);

	fitData2B = fitDataB << Split(
		Split By( :Column 1 ),
		Split( :Column 2 ),
		Group( EvalExpr(parseUniqueCol) ),
		Remaining Columns( Drop All ),
		Sort by Column Property,
		private
	);
	
	fitData2B << Delete Columns( "Mean of Response", "Observations (or Sum Wgts)", "RSquare", "RSquare Adj" );
	
	respMap << Close Window;
	fitData << Close Window;
	fitDataB << Close Window;
	
	timeCol2 = timeCol||"^2";
	parseTimeCol2 = Parse(EvalInsert(":name(\!"^timeCol2^\!")"));
	For( i = 1, i <= N Cols( timePtsv ), i++, 
	
		fitData2 << New Column( "Grab Time " || Char( timePtsv[i] ),
			Numeric,
			Continuous,
			Set Formula( parseTimeCol * timePtsv[i] + parseTimeCol2 * timePtsv[i] ^ 2 )
		);
		
		Column( fitData2, "Grab Time " || Char( timePtsv[i] ) ) << Delete Formula;
	);
	
	colListhave = fitData2 << Get Column Names( String );
	colListneed = {};
	
	For( i = 1, i <= Length( colListhave ), i++,
		If( Contains( colListhave[i], "Grab Time" ) > 0,
			Insert Into( colListneed, colListhave[i] )
		)
	);
	
	fitData3 = fitData2 << Stack( Columns( colListneed ), Source Label Column( "Grab Time" ), Stacked Data Column( "Signal" ), private );
	
	Column( fitData2, timeCol ) << Set Name( "B Term" );
	Column( fitData2, timeCol2 ) << Set Name( "A Term" );
	Column( fitData2, "Intercept" ) << Set Name( "C Term" );
	
	table << Update(
		With( fitData2 ),
		Match Columns( EvalExpr(parseUniqueCol) = EvalExpr(parseUniqueCol) ),
		Add Columns from Update table( :A Term, :B Term, :C Term )
	);
	
	table << Update(
		With( fitData2B ),
		Match Columns( EvalExpr(parseUniqueCol) = EvalExpr(parseUniqueCol) ),
		Add Columns for Update Table( :Root Mean Square Error )
	);

	table << Update(
		With( dt1 ),
		Match Columns( EvalExpr(parseUniqueCol) = EvalExpr(parseUniqueCol) ),
		Add Columns for Update Table( :Name("ResidualVariance"))
	);
		
	fitData2 << Close Window;
	fitData2B << Close Window;
	
	fitData3 << New Column( "Time", Numeric, Continuous, Set Formula( Num( Word( 3, :Grab Time, " " ) ) ) );
	Column( fitData3, "Time" ) << Delete Formula;
	fitData3 << Delete Columns( "Grab Time" );

	fitDatabeta = fitData3 << Bivariate( Y( :Signal ), X( :Time ), Fit Line( {Line Color( {212, 73, 88} )} ), By( EvalExpr(parseUniqueCol) ) );

	arFinal = Try(
		Report( fitDatabeta[1] )["Parameter Estimates"][Table Box( 1 )] << Make Combined Data Table(invisible(1)),
		Report( fitDatabeta )["Parameter Estimates"][Table Box( 1 )] << Make Combined Data Table(invisible(1))
	);

	fitDatabeta << Close Window;
	
	arFinal << Select Where( :Term == "Intercept" ) << Delete Rows;
	arFinal << Delete Columns( "X", "Y", "~Bias", "Std Error", "t Ratio", "Prob>|t|", "Term" );

	Column( arFinal, "Estimate" ) << Set Name( "Dynamic Region AR" );

	table << Update( With( arFinal ), Match Columns( EvalExpr(parseUniqueCol) = EvalExpr(parseUniqueCol) ) );
	
	dt1 << Close Window;
	arFinal << Close Window;
	fitData3 << Close Window;
	
);

glitchCalcFix = Function( {table,glitchReadPointCol,respCol,uniqueCol},{default local},
	timeInt = [1 2, 2 3, 3 4, 4 5, 5 6] - 1;
	parseRespCol = Parse(EvalInsert(":name(\!"^respCol^\!")"));
	parseUniqueCol = Parse(EvalInsert(":name(\!"^uniqueCol^\!")"));
	
	For( i = 1, i <= N Rows( timeInt ), i++,
		colNametemp1 = "Slope of Response(" || Char( timeInt[i, 1] ) || "-" || Char( timeInt[i, 2] ) || ")";
		genericInterpMetric( table, respCol, glitchReadPointCol, uniqueCol, colNametemp1, timeInt[i, 1], timeInt[i, 2], "Slope" );
	);
	
	//Point 2 check is for the 1st point in the array. Currently we will force allowance into the calculations and not glitch correct it
	table << New Column( "Point 2 Check",
		Numeric,
		//Continuous,
		//Set Formula( If( :Name( "Slope of Response(0-1)" ) >= posThreshold & :Name( "Slope of Response(1-2)" ) < negThreshold, 1, 0 ) )
		Character(10),
		<< Set Each Value("NotImplemented")
	);

	table << New Column( "Point 3 Check",
		Numeric,
		Continuous,
		Set Formula( If( :Name( "Slope of Response(1-2)" ) >= posThreshold & :Name( "Slope of Response(2-3)" ) < negThreshold, 1, 0 ) )
	);

	table << New Column( "Point 4 Check",
		Numeric,
		Continuous,
		Set Formula( If( :Name( "Slope of Response(2-3)" ) >= posThreshold & :Name( "Slope of Response(3-4)" ) < negThreshold, 1, 0 ) )
	);
	
	table << New Column( "Point 5 Check",
		Numeric,
		Continuous,
		Set Formula( If( :Name( "Slope of Response(3-4)" ) >= posThreshold & :Name( "Slope of Response(4-5)" ) < negThreshold, 1, 0 ) )
	);
	
	table << New Column( "Total Glitch Count",
		Numeric,
		Continuous,
		Set Formula( Sum( /*:Point 2 Check,*/ :Point 3 Check, :Point 4 Check, :Point 5 Check ) )
	);
	
	//table:Name("Point 2 Check") << delete formula;
	table:Name("Point 3 Check") << delete formula;
	table:Name("Point 4 Check") << delete formula;
	table:Name("Point 5 Check") << delete formula;
	table:Name("Total Glitch Count") << delete formula;
	
	glitchCheck = Max( Column( table, "Total Glitch Count" ) << Get Values );
	If( glitchCheck > 0,
		Try(
			dt_Data_glitch = table << Select Where( :Total Glitch Count >= 1 ) << Subset( Selected Rows( 1 ), Selected Columns( 0 ), Invisible );
			//will error here if no table is created
			dt_Data_glitch << New Column( "P2P Slope",
				Numeric,
				Continuous,
				//changed bottom from 1 to 2 so the first point is not considered for glitching
				Set Formula( If( 2 <= :Read Point_glitch <= 5, parseRespCol - Lag( parseRespCol ) ) )
			);
			Column( dt_Data_glitch, "P2P Slope" ) << Delete Formula;
			dt_Data_glitch << New Column( "Glitch Point", Numeric, Continuous, Set Formula( If( :P2P Slope >= posThreshold & Lag( :P2P Slope, -1 ) < negThreshold, 1, 0 ) ) );
			Column( dt_Data_glitch, "Glitch Point" ) << Delete Formula;
			//dt_Data_glitch << Select Where( :Glitch Point == 1 ) << Delete Rows();
		
			dt_Data_glitch << Delete Columns( "P2P Slope" );
			//dynamicARfun( dt_Data_glitch, "TimeFromSampleDispense:sec","Dry Normalized Response","uniqueCurveID",SOPstartTime,SOPendTime,SOPtimes );
			dtGtemp = dt_Data_glitch << Subset( Columns( Column(uniqueCol), "Read Point_glitch", "Glitch Point" ), Selected Rows( 0 ) );
			//Column( dtGtemp, "Dynamic Region AR" ) << Set Name( "Glitch Corrected AR" );
			table << Update(
				With( dtGtemp ),
				Match Columns(
					Eval(NameExpr(parseUniqueCol)) = Eval(NameExpr(parseUniqueCol)),
					:Read Point_glitch = :Read Point_glitch
				)
			);
			For Each Row(table,
				If(IsMissing(:Name("Glitch Point")),:Name("Glitch Point") = 0)
			);
		
			dtGtemp << Close Window;
			dt_Data_glitch << Close Window;
			,
			//Only total of 1 gets fixed
			table << New Column( "Glitch Point", Numeric, Continuous, << set each value(0) );
			//Column( table, "Glitch Corrected AR" ) << Delete Formula;
		)
	,
		table << New Column( "Glitch Point", Numeric, Continuous, << set each value(0) );
		//Column( table, "Glitch Corrected AR" ) << Delete Formula;
	);
	
);

bFunct:arCalc = Function( {tableName, knownChemtype, targetCode, fullDefaults = 0},
	{}, 
	//tableName = dt_start;
	//knownChemType = "Bile";
	//targetCode = {21};
	//fullDefaults = 1;
	
	tblGetName = tableName << GetName;
	
	//determines if any other paramSets are present and find the next paramSet
	tableVars = tableName << get table variable names;
	
	//determines if any AR tool has been run before
	//makes new table if first time use
	//does tableprep no matter what
	If( Contains( tblGetName, "_progCurves" ) > 0,
		newTable = 0;
		dt_algorithm = tableName;
		dt_algorithm = tablePrep( dt_algorithm, knownChemType );
	,
		newTable = 1;
		//Creates working copy of data table so original data is never 'touched'
		dt_algorithm = tableName << Subset( Output Table( tblGetName ), All Rows, Selected columns only( 0 ), invisible );
		dt_algorithm = tablePrep( dt_algorithm, knownChemType );
	);
	
	nwAssayCodes = {};
	Try(
		Is Scriptable( Column( dt_algorithm, "Assay" ) );
		Summarize( dt_algorithm, a = by( :Name("Assay") ) );
		For( i = 1, i <= N Items( listOfIDXassays ), i++,
			If( Contains( a, Char( listOfIDXassays[i] ) ) > 0,
				Insert Into( nwAssayCodes, listOfIDXassays[i] )
			)
		);
	,
		Insert Into( nwAssayCodes, 999 )
	);

	Match( newTable,
		0,
			Match( N Items( nwAssayCodes ),
				0,
					noNwAssays();
					Throw();,
				1,
					If(
						nwAssayCodes[1] == 999, Empty(),
						Contains( targetCode, nwAssayCodes[1] ) == 0,
							wrongNwAssay();
							Return( 0 );
					),
				tooManyNwAssays();
				Return( 0 );
			),
		1,
			Match( N Items( nwAssayCodes ),
				0,
					Close( dt_algorithm, nosave );
					noNwAssays();
					Return( 0 );,
				1,
					If(
						nwAssayCodes[1] == 999, Empty(),
						Contains( targetCode, nwAssayCodes[1] ) == 0,
							Close( dt_algorithm, nosave );
							wrongNwAssay();
							Return( 0 );
					),
				Close( dt_algorithm, nosave );
				tooManyNwAssays();
				Return( 0 );
			)
	);
	
	colList1 = dt_algorithm << get column names( string );
	//discovers presence of any column that would become default
	//assigns cols or throws error dialog
	foundTimeCol = 0;
	foundRespCol = 0;
	foundUniqueCol = 0;
	If( Contains( colList1, "TimeFromSampleDispense:sec" ) > 0,
		foundTimeCol = 1
	);
	If( Contains( colList1, "ReflDens_avg" ) > 0,
		foundRespCol = 1
	);
	If( Contains( colList1, "uniqueCurveID" ) > 0,
		foundUniqueCol = 1
	);
	If( fullDefaults == 0,
		useDefaultCols = chooseDefBox << get,
		useDefaultCols = 1
	);
	Match( useDefaultCols,
		0,
			Try(
				respCol = (colListY << Get items)[1];
				timeCol = (colListX << Get items)[1];
				uniqueCol = (colListT << Get items)[1];
			,
				If( foundTimeCol == 1 & foundRespCol == 1 & foundUniqueCol == 1,
					respCol = "ReflDens_avg";
					timeCol = "TimeFromSampleDispense:sec";
					uniqueCol = "uniqueCurveID";
				,
					missingCols();
					If( newTable = 1,
						Close( dt_algorithm, nosave )
					);
					Throw();
				)
			),
		1,
			If( foundTimeCol == 1 & foundRespCol == 1 & foundUniqueCol == 1,
				respCol = "ReflDens_avg";
				timeCol = "TimeFromSampleDispense:sec";
				uniqueCol = "uniqueCurveID";
			,
				missingCols();
				If( newTable == 1,
					Close( dt_algorithm, nosave )
				);
				Throw();
			)
	);
	//show(respCol,timeCol,uniqueCol);
	
	Try( diagwindow << close window() );
	dt_algorithm << show window();
	
	//Sets up Variables for new naming nomenclature (rules in revision history)
	dt_name = tblGetName;
	titleName = Word( 1, dt_name, "-" );
	dateName = Substr( dt_name, Munger( dt_name, 1, "-" ) + 1, 6 );
	
	//Sets up MMDDYYYY date for Table Naming
	todayDate = Short Date( Today() );
	newTodayDate = Munger( todayDate, 1, "/", "" );
	nextTodayDate = Munger( newTodayDate, 1, "/", "" );
	
	If( fullDefaults != 0,
		insertInto(startTime1,char(SOPstartTime));
		insertInto(endTime1,char(SOPendTime));
		startTime = startTime1;
		endTime = endTime1;
	,
		startTime = startTime1 << get text;
		endTime = endTime1 << get text;
	);

	//Show(normTime,threshTime,threshArea,numRegressPoints);
	dt_algorithm << New Column( "R&D AR Calc Version", Character( 10 ), Formula( Eval( arCalcVer ) ) );
	Column( dt_algorithm, "R&D AR Calc Version" ) << delete formula;
	
	Try(
		dt_algorithm << Sort(
			By( Column( dt_algorithm, uniqueCol ), Column( dt_algorithm, timeCol ) ),
			Order( Ascending, Ascending ),
			ReplaceTable( 1 )
		),
		cannotReplace();
		Return( 0 );
	);
	
	//preDevelopmentMetric{tableName,yColumn,xColumn,byColumn,columnName,metric="sp",direction="Dry",eventOneTime="NULL",eventTwoTime="NULL",singlePoint=1};
	preDevelopmentMetric(dt_algorithm,respCol,timeCol,uniqueCol,"AvgDry","avg","Dry","NULL","NULL",1);
	parseRespCol = Parse(EvalInsert(":name(\!"^respCol^\!")"));
	parseTimeCol = Parse(EvalInsert(":name(\!"^timeCol^\!")"));
	parseUniqueCol = Parse(EvalInsert(":name(\!"^uniqueCol^\!")"));
	
	dt_algorithm << New Column( "Read Point_glitch",
		Numeric,
		Nominal,
		Set Formula(
			If( :Name( "Inst Type" ) == "CatOne",
				If( Row() == 1 | Lag( :Name( "uniqueCurveID" ), 1 ) != :Name( "uniqueCurveID" ),
					If( :Name( "TimeFromSampleDispense:sec" ) < 0,
						Index1 = -1;
						While( Lag( :Name( "TimeFromSampleDispense:sec" ), Index1 ) < 0, Index1-- );
						rp = 0 + index1;
						//show(rp, index1);
						rp = rp -1;
					,
						rp = 0
					)
				,
					Lag( :Read Point_glitch, 1 ) + 1
				)
			,
				If( Row() == 1 | Lag( :Name( "uniqueCurveID" ), 1 ) != :Name( "uniqueCurveID" ),
					If( :Name( "TimeFromSampleDispense:sec" ) < 0,
						Index1 = -1;
						While( Lag( :Name( "TimeFromSampleDispense:sec" ), Index1 ) < 0, Index1-- );
						rp = 0 + index1;
					,
						rp = 0
					)
				,
					Lag( :Read Point_glitch, 1 ) + 1
				)
			)
		)
	);
	Column( dt_algorithm, "Read Point_glitch" ) << Delete Formula;
	
	glitchCalcFix(dt_algorithm,"Read Point_glitch",respCol,uniqueCol );
	
	dt_algorithm << New Column("Glitch Corrected RD",Numeric, Continuous,
		Formula(
			If(:Name("Glitch Point") == 1, Empty(),
				parseRespCol
			)
		)
	);
	dt_algorithm:Name("Glitch Corrected RD") << delete formula;
	
	dt_algorithm << New Column("DryNorm_correctedRD",
		Formula(
			:Name("Glitch Corrected RD") / :Name("AvgDry")
		)
	);
	
	dynamicARfun(dt_algorithm,timeCol,"DryNorm_correctedRD",uniqueCol,SOPstartTime,SOPendTime,SOPtimes);
	
	If( newTable == 1,
		dt_algorithm << SetName( titleName || "-" || dateName || "_" || knownChemType || " AR_" || nextTodayDate || "_progCurves" );
		scriptJustResults( dt_algorithm, uniqueCol );
	,
		Empty()
	);
	Current Data Table( dt_algorithm );
	colName = "Dynamic Region AR";//this should be dynamically made, perhaps output from the dynamicFunction?
	Return( dt_algorithm, nwAssayCodes, colName );
);

bFunct:flagging = Function( {tableName, flagParams,arCol},
	{default local}, 
	//tableName = flagTable[1];
	//flagParams = assayFlags;
	//arCol = "DryNorm_Slope(35-90)";
	
	parseARcol = Parse( Eval Insert( ":name(\!"^arCol^\!" )" ) );
	
	/*
	//adds table variable to show the flag parameter limits
	flagString = {};
	For( k = 1, k <= N Items( flagParams ), k++,
		Match( N Items( flagParams[k] ),
			4, flagString[k] = Concat( Char( flagParams[k][1] ), " = ", Char( flagParams[k][2] ), ", ", Char( flagParams[k][3] ), "\!n" ),
			6,
				flagString[k] = Concat(
					Char( flagParams[k][1] ),
					" = ",
					Char( flagParams[k][2] ),
					", ",
					Char( flagParams[k][3] ),
					", ",
					Char( flagParams[k][4] ),
					", ",
					Char( flagParams[k][5] ),
					"\!n"
				)
		)
	);
	finalFlagString = Concat Items( flagString, "" );
	
	tableName << New Table Variable( "Flag Parameters", finalFlagString );
	*/
	/// THE BELOW WILL BE MOVED INTO assayDevFlagging function
	tableName << New Column("Flag",Character,
		Formula(
			If(Row() == 1 | :Name( "uniqueCurveID" ) != Lag(:Name( "uniqueCurveID" ),1),
				flagList = {};
				For(i=1,i<=nitems(flagParams),i++,
					Match(i,
						1,
							If(
								:Name("Total Glitch Count") != flagParams[i][2],
								flagList[i] = "NF("||flagParams[i][3]||")"
								,
								flagList[i] = flagParams[i][3]
							);
						,
						2,
							If(
								:Name("Total Glitch Count") < flagParams[i][2],
								flagList[i] = "NF("||flagParams[i][3]||")"
								,
								flagList[i] = flagParams[i][3]
							);
						,
						4,
							If(
								:Name("AvgDry") < flagParams[i][2],
								flagList[i] = "NF("||flagParams[i][3]||")"
								,
								flagList[i] = flagParams[i][3]
							);
						,
						3,
							If(
								flagParams[i][2] <= :Name("B Term") <= flagParams[i][3],
								flagList[i] = "NF("||flagParams[i][4]||")"
								,
								flagList[i] = flagParams[i][4]
							);
						,
						6,
							If(
								flagParams[i][2] <= :Name("Dynamic Region AR") <= flagParams[i][3],
								flagList[i] = "NF("||flagParams[i][4]||")"
								,
								flagList[i] = flagParams[i][4]
							);
						,
						5,
							If(
								Round(flagParams[i][4] * :Name("B Term") + flagParams[i][5], 10) <= :Name("A Term") <= Round(flagParams[i][2] * :Name("B Term") + flagParams[i][3], 10),
								flagList[i] = "NF("||flagParams[i][6]||")",
								flagList[i] = flagParams[i][6];
							)
							,
						7,
							If(
								:Name("ResidualVariance") < flagParams[i][2],
								flagList[i] = "NF("||flagParams[i][3]||")"
								,
								flagList[i] = flagParams[i][3]
							);
					);
				);
				
				flagList1="";
				For(j=1,j<=nitems(flagList),j++,
					flagList1 = flagList1 || " " || flagList[j]
				);
				Trim(flagList1);
				,
				Lag(:Flag,1)
			)
		)
	);
	
	tableName<<New Column("Flag_nums",Character(20),
		Formula(
			//If(:Chem Type == assay_Name,
				flagNumList = Words(:Flag,"[");
				flagNumList1 = "";
				For(k=1,k<=nitems(flagNumList)-1,k++,
					If(Contains(flagNumList[k],"NF") == 0,
						flagNumList1 = flagNumList1 || " " || Word(1,flagNumList[k+1],"]")
					)
				);
				If(flagNumList1 == "",
					"None"
					,
					Trim(flagNumList1);
				)
			//);
		)
	);
	Column(tableName,"Flag_Nums") << Eval Formula;

	tableName:Flag << delete formula;
	tableName:Flag_nums << delete formula;
	////////
	/*
	//update to handle the nwAssayCodes like finishingOff()
	assayDevFlagging( tableName, flagParams, knownChemType );
	*/
	tableName << New Column( "AR-Script",
		Formula(
			If(
				:Dynamic Region AR == -999, -2
			,
				Contains(:Name("Flag_nums"),"*") > 0, -1 // only takes 1 * fail to cause suppression
			,
				:Dynamic Region AR
			)
		)
	);
	Column(tableName, "AR-Script")<<deleteformula;
);

bFunct:finishingOff = Function( {tableName, iaCode, units, colName},
	{default local}, 
	//tableName = currentdatatable();
	
	//Calculates concentrations based on available curves
	tableConcCalc("uniqueCurveID","AR-Script","Species Name","Slide Lot","Assay",tableName);
	
	Try(
		tableName << New Column( "Calc Dose",
			numeric,
			Formula(
				If( :Name( "AR-Script" ) == -1 | :Name( "AR-Script" ) == -2,
					:Name( "AR-Script" ), 
					//Try included if species isn't in array, will default to displaying the calc dose all value
					Try(
						If( :Name( "Calc_Dose_All" ) > extremeHighDose[Uppercase( :Name( "Species Name" ) )],
							-3,
							:Name( "Calc_Dose_All" )
						),
						:Name( "Calc_Dose_All" )
					)
				)
			)
		);
		Column( tableName, "Calc Dose" ) << DeleteFormula;
	);
	tableName << New Column( "Units_script", character( 10 ), <<Set Each Value( units ) );
	
	//Moves most important columns within table
	//Try() functions move columns not in common beteween table origins
	tableName << MoveSelectedColumns(
		{
			"AR-Script",
			Eval(colName),
			"Calc Dose",
			"Units_script",
			"Flag",
			"Flag_nums", 
			"uniqueCurveID",
			"R&D AR Calc Version",
			"Chem Type",
			"Inst Type",
			"TimeFromSampleDispense:sec",
			"ReflDens_avg",
			"DryNorm_correctedRD",
			"Instrument ID"
		},
		To First
	);

	//Try() statments cover a number of columns that may be present but may not depending on data source
	//Column movement Try() commands done in reverse order as JMP doesn't allow a move 'before' only 'after'
	//So to maintain correct order in case some of colums are there but others aren't, reverse ensures correct ordering 'after' a given column
	//IsScriptable added to induce failure if "after" column not present. Otherwise user just prompted with 'move column' dialog
	Try( IsScriptable(Column(tableName,"Flag_nums")); tableName << MoveSelectedColumns( {"Flags"}, After( "Flag_nums" ) ) );
	Try( IsScriptable(Column(tableName,"Flag_nums")); tableName << MoveSelectedColumns( {"CDx Conc Error Flags"}, After( "Flag_nums" ) ) );
	Try( IsScriptable(Column(tableName,"Flag_nums")); tableName << MoveSelectedColumns( {"CDx IM Error Flags"}, After( "Flag_nums" ) ) );
	Try( tableName << MoveSelectedColumns( {"condition 4"}, To First ) );
	Try( tableName << MoveSelectedColumns( {"condition 3"}, To First ) );
	Try( tableName << MoveSelectedColumns( {"condition 2"}, To First ) );
	Try( tableName << MoveSelectedColumns( {"condition 1"}, To First ) );
	Try( IsScriptable(Column(tableName,"uniqueCurveID")); tableName << MoveSelectedColumns( {"Configuration"}, After( "uniqueCurveID" ) ) );
	Try( IsScriptable(Column(tableName,"uniqueCurveID")); tableName << MoveSelectedColumns( {"Script Version"}, After( "uniqueCurveID" ) ) );
	Try( IsScriptable(Column(tableName,"uniqueCurveID")); tableName << MoveSelectedColumns( {"Foil Found"}, After( "uniqueCurveID" ) ) );
	Try( IsScriptable(Column(tableName,"uniqueCurveID")); tableName << MoveSelectedColumns( {"Barcode"}, After( "uniqueCurveID" ) ) );
	Try( IsScriptable(Column(tableName,"R&D AR Calc Version")); tableName << MoveSelectedColumns( {"Metering Firmware"}, After( "R&D AR Calc Version" ) ) );
	Try( IsScriptable(Column(tableName,"Inst Type")); tableName << MoveSelectedColumns( {"Species Name"}, After( "Inst Type" ) ) );
	Try( IsScriptable(Column(tableName,"Inst Type")); tableName << MoveSelectedColumns( {"Species"}, After( "Inst Type" ) ) );
	
	//Hides and groups all columns that are listed in 'hidecols'
	//Default is for any column to be unhidden unless added to this list
	hideCols = {"Alg Calc Ar Error Status :4", "Algorithm Conc Error Flags", "Algorithm IM Error Flags", "Algorithm Status", "AR Qualifer",
	"AR Qualifier", "AR2", "AR2 Qualifer", "AR2 Qualifier", "Concentration units", "Curve Area", "Curve Cubic", "Curve Fifth", "Curve File Version",
	"Curve Intercept", "Curve Linear", "Curve Quad", "Curves Version :5", "Date", "Date-orig", "Dilution Parts", "Dilution Type", "Discrepant Type",
	"Dry Read Finish", "Dry Read Start", "DryReadingMean", "Final Scalar", "Flag :3", "Flag1 :4", "Flag2 :4", "Flag3 :4", "From Optics Module",
	"Gain Applied", "Gain Applied :4", "Gain Applied 2", "GMTime", "ID Source :2", "Log Entry Timestamp :3", "Normalized RD", "Num Dry Reads :2",
	"Num Of Assays", "Num Of Points :2", "Num Of Readings :2", "Num Wavelengths Used :4", "Offset Applied", "Offset Applied :4",
	"Offset Applied Type", "Paired Results Flag :4", "Point :3", "Post Analysis Notes", "Progress Curve Analysis", "Qual :4", "Qualifier",
	"RD Normalization Reading", "Read Point", "Reading Time", "Reading2 :3", "Reflective :2", "Re-Review of Consumable/Slide", "Run Done Timestamp",
	"Run Fault", "Sample Container", "Sample_conjugate_alq2", "Scalar", "Scalar Adjustment", "Segment", "Slide Load Position :4", "Spot Time",
	"Stored Wet Offset", "Stored WLC Offset", "Substrate_alq1", "Time", "Time Offset :2", "Time-orig", "Timeseries pt", "Timeseries RD2",
	"TS Read Flag", "uldry Intensity", "ulfalse light Molded", "ulfalselight", "ulfalselight Laminate", "ulwet Intensity", "Units :4", "Units :5",
	"Wash 1 End", "Wash 2 End", "Wash1_alq3", "Wavelength", "Wavelength2", "Wavelength3", "Wavelengths Used", "X Intersect", "Y Intersect"};
	
	hideGroupCols = {};
	For( i = 1, i <= N Cols( tableName ), i++,
		a = Column( tableName, i ) << getname;
		If( Contains( hideCols, a ) > 0,
			Column( tableName, i ) << hide( 1 );
			Insert Into( hideGroupCols, a );
		);
	);
	tableName << groupcolumns( "Hidden Columns", hideGroupCols );
	tableName << MoveColumnGroup( To Last, "Hidden Columns" );
	
	//Sets up Variables for new naming nomenclature (rules in revision history)
	dt_name = tableName << get name;
	titleName = Word( 1, dt_name, "-" );
	dateName = Substr( dt_name, Munger( dt_name, 1, "-" ) + 1, 6 );
	
	//Sets up MMDDYYYY date for Table Naming
	todayDate = Short Date( Today() );
	newTodayDate = Munger( todayDate, 1, "/", "" );
	nextTodayDate = Munger( newTodayDate, 1, "/", "" );

	//Selects one read from each curve to subset into table with only 1 Angle result per run
	//updated to use uniqueCurveID instead of uniqueAssayID
	tableName << Select Where( :uniqueCurveID != Lag( :uniqueCurveID, -1 ) | Row() == N Row() );
	
	//Get subset with just the results
	dt_justResult = tableName << Subset(
		output table name( titleName || "-" || dateName || "_" || knownChemType || " AR_" || nextTodayDate || "_justResults" )
	);
	tableName << SelectAllRows;
	tableName << InvertRowSelection;
	
	dt_justResult << Delete Table Property( "Make justResults" );
	Return( dt_justResult );
);

////////////////////////////////////////
//                                    //
//              Main                  //
//                                    //
////////////////////////////////////////


If( Length( Include File List() ) == 1,
	defaultsNoDialog = 1;
	batchUpdateChk(updateIDs);
	trackUsage(u,addinID);

	If( checkVersion( minJMPver ) == 1,
		//defaultsNoDialog = 1;

		//Gets data table if non opened
		If( N Table() == 0,
			dt_start = Open(),
			dt_start = Current Data Table()
		); 

		flagTable = bFunct:arCalc( dt_start, knownChemtype, targetCode, defaultsNoDialog );
		If( flagTable == 0,
			cleanup({bFunct})
		);
		bFunct:flagging( flagTable[1], assayFlags, flagTable[3] );
		bFunct:finishingOff( flagTable[1], flagTable[2][1], units, flagTable[3] );
		
		//bAR << delete namespace;

		bFunct << delete namespace;
	,
		wrongVer( minJMPver );
		cleanup({bFunct});
	)
	,
	Print( knownChemType || " AR script was included from another source" );
	//build within try() command
	//dt_start = mf:subsetDT;
);


