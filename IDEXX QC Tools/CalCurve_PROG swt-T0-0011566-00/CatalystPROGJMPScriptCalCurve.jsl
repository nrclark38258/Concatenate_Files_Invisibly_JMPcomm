//Author(s)
//NClark (JSL)
//IDEXX Laboratories, Inc.
//Westbrook, ME 04092

//Tool Calculates a Calibration curve for assay

//------------------Revision History for both script and Help File--
//	1.0 NClark 090418
//		-> Changed SDMA to PROG
//		-> Updated to use hard coded columns, AR and PROG Conc
//	Ported from v1.2 version of of OPS SDMA Cal Curve Tool
//------------------------------------------------------------------
Names Default to Here(1);
clearglobals();

progCal = New Namespace( "progCalibration" );
progCal:version = 1.0;
progCal:lbWidth = 130;
//::globalListprogCal = {::ba1ListprogCal, ::ba2ListprogCal, ::ba3ListprogCal, ::ba4ListprogCal}; //global list for column lists
//progCal:lbList = {colListYprogCal, colListBprogCal, colListXprogCal, colListTprogCal};

progCal:DataTable = Current Data Table();
If( Is Empty( progCal:DataTable ),
	Try(progCal:DataTable = Open(),progCal<<delete;throw())
);
progCal:nc = N Col( progCal:DataTable );

////////////////////////////////////////
//                                    //
//            Functions               //
//                                    //
////////////////////////////////////////

notImplemented = Function({},
	New Window( "Feature Not Available", <<Modal, Text Box( "This feature has not been implemented yet." ), Button Box( "OK" ) );
	Return(0)
);

dataQuality = Function({},
	New Window( "Curve Data Suspect", <<Modal,
		VListBox(
			Text Box( "ONE OR MORE FITS NOT SHOWN" ),
			TextBox( "One or more curves contains suspect data or data of poor quality. " ),
			TextBox( "Please investigate data and rerun tool" ),
			TextBox( "" )
		),
		Button Box( "OK" )
	);
	Return(0)
);

wrongVer = Function({maxVer},{Default Local},
	New Window( "Requires JMP "||char(maxVer), <<Modal, Text Box( "This addin requires the used of JMP "||char(maxVer)||"+" ), Button Box( "OK" ))
);

populateGlobals = Function({globalList,localList,diagOption},
	For(i=1,i<=N Items(globalList),i++,
		//show(nitems(globalList));
		Eval(
			Substitute(
				Expr(
					Unlock Globals(glVar);
					/*Match(diagOption,
						1, glVar = lb << Get Items
					,
						2, glVar = lb << Get
					,
						3, glVar = lb
					);*/
					Try(
						glVar = lb << Get Items
					,
						Try(
							glVar = lb << get
						,
							glVar = lb
						)
					);
					Lock Globals(glVar);
				),
				Expr(lb),Name Expr(localList[i]),
				Expr(glVar),Name Expr(globalList[i])
			)
		);
	);
	Return(1)
);

recallItems = Function({},
	//Is List will produce error if ba1List is not declared
	//If error, declare vars, otherwise get vars
	progCal:colList = progCal:DataTable << Get Column Names( String );
	Try(
		For( i = 1, i <= N Items( ::globalListprogCal ), i++,
			progCal:nextList = ::globalListprogCal[i];
			For( j = 1, j <= N Items( progCal:nextList ), j++,
				If( N Row( Loc( progCal:colList, progCal:nextList[j] ) ) > 0,
					Eval( Substitute( Expr( lb << Append( item ) ), Expr( lb ), progCal:lbList[i], Expr( item ), progCal:nextList[j] ) )
				)
			);
		)
	,
		Print( "No columns to recall." )
	);
);

wrongCols = Function({},
	New Window( "Incomplete Column Selection",
		<<Modal,
		Text Box( "One or more variables are missing or incorrect for data type", <<setfontstyle( "bold" ), <<setfontsize( 12 ) ),
		Text Box( "" ), 

		Text Box( "Both Concentration and Analyzer Resp require a single, continuous input", <<setfontstyle( "bold" ) ),
		Text Box( "Target Conc requires a single, input (cont or char, but integer values)", <<setfontstyle( "bold" ) ),
		Text Box( "BY can only be a single character column", <<setfontstyle( "bold" ) ),
		Button Box( "OK" ),

	)
);

missingCols = Function( {},{default local},
	//If(tableFail == "Both",
	//	tableFail = "Both Tables", tableFail = tableFail||" Table"
	//);
	New Window( "_Incomplete Column Selection",
		<<Modal,
		Text Box( "Naming issue with table columns", <<setfontstyle( "bold" ), <<setfontsize( 12 ) ),
		Text Box( "One or more columns are missing or incorrect for data type", <<setfontstyle( "bold" ), <<setfontsize( 10 ) ),
		Text Box( "" ), 

		Text Box( "Please be sure the following nomenclature stadards are being adhered to", <<setfontstyle( "bold" ) ),
		Text Box( "\!"AR\!" = Analyzer response column; Numeric/Continuous" ),
		Text Box( "\!"PROG Conc\!" = Reference dose column; Numeric/Continous" ),
		Button Box( "OK" ),

	)
);

exprCancel = Function({},
	//progCal:Diag << Close Window;
	diagWindow << close window;
	progCal << delete
);

dataWarning = Function({numBad},{Default Local},
	New Window( "Potential Suspect Data",
		<<Modal,
		Text Box( "ALERT", <<setfontstyle( "bold" ), <<setfontsize( 12 ) ),
		Text Box( "" ), 
		Text Box( "Suspect data... " || Char(numBad) || " curve(s) identified"),
		Text Box( "Represented by 'DASHED line of shame' curve fit lines"),
		Button Box( "OK" ),

	);
);

calibrationCurve = Function({},{x, suspectData},

	Try(
		Is Scriptable( Column( progCal:DataTable, "PROG Conc" ) );
		Is Scriptable( Column( progCal:DataTable, "AR" ) );
		,
		missingCols();
		Throw();
	);
	If(
		Column( progCal:DataTable, "PROG Conc" ) << Get Data Type != "Numeric" | Column( progCal:DataTable, "AR" ) << Get Data type != "Numeric",
			missingCols();
			Throw();,
		Column( progCal:DataTable, "PROG Conc" ) << Get Modeling Type != "Continuous" | Column( progCal:DataTable, "AR" ) << Get Modeling type !=
		"Continuous",
			missingCols();
			Throw();
	);
	
	progCal:colList = {};
	progCal:meanFive = {};
	progCal:fitCoeffList = {};
	progCal:rCoeffList = {};
	progCal:concavList = {};
	progCal:intersectPts = {};
	progCal:passFail = {};
	progCal:fitallFormulas = {};
	progCal:fitDerivFormulas = {};
	progCal:fitNotes = {};
	
	progCal:ycol = {"AR"};
	progCal:xcol = {"PROG Conc"};
	progCal:YvarUnParse = ":Name(\!"AR\!")";
	progCal:XvarUnParse = ":Name(\!"PROG Conc\!")";
	progCal:Yvar = Parse( ":Name(\!"AR\!")" );
	progCal:Xvar = Parse( ":Name(\!"PROG Conc\!")" );
	
	progCal:fit1 = progCal:DataTable << Subset( Copy formula( 0 ), All rows, Selected columns only( 0 ), private );
	
	//selects and deletes excluded rows and responses less than 0
	//if not deleted, the raw data may be transferred to fits and used in calculations
	progCal:fit1 << selectwhere( Excluded( Row State( Row() ) ) == 1 | progCal:ycol[1] <= 0);
	For( j = 1, j <= N Row( progCal:fit1 ), j += 3, 
		If( Selected( Row State( j ) ) == 1,
			progCal:fit1 << deleterows();
			Break();
		,
			Empty()
		)
	);

	//fit rodbard 'correctly' but keeping 0 in (LCMS will be changed to 0.01)
	For(i=1,i<=nrow(progCal:fit1),i++,
		If(Column(progCal:fit1,progCal:xcol[1])[i] == 0,
			Column(progCal:fit1,progCal:xcol[1])[i] = 0.0001
		,
			Empty()
		)
	);
	Try(
		Summarize( progCal:fit1, progCal:by = By( progCal:byCol[1] ));
	);
	//Adds 100 concentration 10000 @ AR = 0
	
	//X and Y columns swapped to plot the graph "correctly" with AR on the Y and Concentration on X
	progCal:fitCurve = Fit Curve(
		X( :Name("PROG Conc") ),
		Y( :Name("AR") ),
		Fit Logistic 4P Rodbard,
		//by( colListBprogCal << getitems )
	);

	progCal:fitCoeff = Report( progCal:fitCurve )[Table Box( 3 )] << make combined data table;
	
	For(i=ncol(progCal:fitCoeff),i>=1,i--,
		a = Column(progCal:fitCoeff,i) << getname();
		
		If(a != "Parameter" & a != "Estimate",
			//Print("deleting");
			progCal:fitCoeff << DeleteColumns(a);
		,
			Empty()
		)
	);
		
	progCal:fitCoeffDone = progCal:fitCoeff << Split(
		Split By( :Parameter ),
		Split( :Estimate ),
		//Group( colListBprogCal << getitems ),
		Sort by Column Property,
		Private
	);
	Close( progCal:fitCoeff, nosave );
	
	progCal:temp1FitCoeffList = {};
	For(l=1,l<=nrow(progCal:fitCoeffDone),l++,
		progCal:temp2FitCoeffList = {};
		For(m=1,m<=ncol(progCal:fitCoeffDone),m++,
			insertinto(progCal:temp2FitCoeffList,progCal:fitCoeffDone[l,m])
		);
		progCal:temp1FitCoeffList[l]=progCal:temp2FitCoeffList
	);
	progCal:fitCoeffList = progCal:temp1FitCoeffList;

	Close( progCal:fit1, nosave );
	Close( progCal:fitCoeffDone );

	/* Rodbard Normal Form (for deriv calculations):([c-L asympt]) + ([d-U asympt] - ([c-L asympt])) / (1 + ([Concentration] / [b-inflection]) ^ [a-Growth])*/

	For(i=1,i<=nitems(progCal:fitCoeffList),i++,
		If(nitems(progCal:fitCoeffList[i])==5,
			progCal:slopeEqn = Eval(
				Eval Expr(
					Derivative(
						(Expr(progCal:fitCoeffList[i][4])) + (Expr(progCal:fitCoeffList[i][5]) - (Expr(progCal:fitCoeffList[i][4]))) / (1 + (x / Expr(progCal:fitCoeffList[i][3])) ^ Expr(progCal:fitCoeffList[i][2])),
						x
					)
				)
			);
			,
			progCal:slopeEqn = Eval(
				Eval Expr(
					Derivative(
						(Expr(progCal:fitCoeffList[i][3])) + (Expr(progCal:fitCoeffList[i][4]) - (Expr(progCal:fitCoeffList[i][3]))) / (1 + (x / Expr(progCal:fitCoeffList[i][2])) ^ Expr(progCal:fitCoeffList[i][1])),
						x
					)
				)
			);
		);
	);

	Try(
		For( i = 1, i <= N Items( progCal:fitCoeffList ), i++,
			r = Eval Insert( "\!"^progCal:fitCoeffList[i][1]^\!"" );
			progCal:fitallFormulas[i] = r || "," || Char(
	/* Rodbard Inverse form (for conc calculations): [b-inflection] * Exp(	Log(([d-U asmypt] - ([c-L asympt])) / ([AR] - ([c-L asympt])) - 1	) / [a-Growth])*/
				Eval Expr(
					Expr(progCal:fitCoeffList[i][3]) * Exp(	Log((Expr(progCal:fitCoeffList[i][5]) - (Expr(progCal:fitCoeffList[i][4]))) / (Expr(Parse( progCal:YvarUnParse )) - (Expr(progCal:fitCoeffList[i][4]))) - 1	) / Expr(progCal:fitCoeffList[i][2]))
				)
			);
			progCal:fitDerivFormulas[i] = r || "," || Char(
				////STAY WITH DERIV OF 'NORMAL' FORM
				Eval Expr(
					Eval(
						Derivative(
							Expr(progCal:fitCoeffList[i][4]) + (Expr(progCal:fitCoeffList[i][5]) - Expr(progCal:fitCoeffList[i][4])) / (1 + (Expr(Parse( progCal:XvarUnParse )) / Expr(progCal:fitCoeffList[i][3] )) ^ Expr(progCal:fitCoeffList[i][2]))
						,
							Expr(Parse( progCal:XvarUnParse ))
						)
					)
				)
			);
		)
	, 
		suspectData = 0;
		progCal:fitallFormulas = Char(
			Eval Expr(
				Expr(progCal:fitCoeffList[i][2]) * Exp(	Log((Expr(progCal:fitCoeffList[i][4]) - (Expr(progCal:fitCoeffList[i][3]))) / (Expr(Parse( progCal:YvarUnParse )) - (Expr(progCal:fitCoeffList[i][3]))) - 1	) / Expr(progCal:fitCoeffList[i][1]))
			)
		);
		progCal:fitDerivFormulas = Char(
			Eval Expr(
				Eval(
					Derivative(
						Expr(progCal:fitCoeffList[i][3]) + (Expr(progCal:fitCoeffList[i][4]) - Expr(progCal:fitCoeffList[i][3])) / (1 + (Expr(Parse( progCal:XvarUnParse )) / Expr(progCal:fitCoeffList[i][2] )) ^ Expr(progCal:fitCoeffList[i][1]))
					,
						Expr(Parse( progCal:XvarUnParse ))
					)
				)
			)
		);
	);
	//Show( progCal:fitallFormulas, progCal:fitDerivFormulas );

	Try(
		progCal:fitconcatForms = Concat Items( progCal:fitallFormulas, "," ); //Concatenates all the list items into one final string
		progCal:fitDerivConcatForms = Concat Items( progCal:fitDerivFormulas, "," );
		//progCal:concatNotes = Concat Items( progCal:fitNotes, "," );
		,
		progCal:fitconcatForms = progCal:fitallFormulas;
		progCal:fitDerivConcatForms = progCal:fitDerivFormulas;
		//progCal:concatNotes = progCal:fitNotes;
	);

	//creates ":...." column name, in quotes (not like parse that removes the quotes)
	//then creates first half of match column insesrting 'By' column
	//then creates end of whole formula
	Try(
		progCal:zVar1 = Eval Insert( ":name( \!"^progCal:byCol[1]^\!" )" );
		progCal:startFormula = "progCal:DataTable<<newcolumn(\!"RodBard4P\!",
			Formula(
				Match(" || progCal:zVar1 || ",";
		progCal:endForm = ")))";
		progCal:DerivStartFormula = "progCal:DataTable<<newcolumn(\!"1stDeriv_RodBard4P\!",
			Formula(
				Match(" || progCal:zVar1 || ",";
		progCal:DerivEndForm = ")))";
		,
		progCal:startFormula = "progCal:DataTable<<newcolumn(\!"RodBard4P\!",
			Formula(";
		progCal:endForm = "))";
		progCal:DerivStartFormula = "progCal:DataTable<<newcolumn(\!"1stDeriv_RodBard4P\!",
			Formula(";
		progCal:DerivEndForm = "))";
	);
	
	//combines all pieces into final huge string to create column with large formula
	progCal:finalConcat = Concat( progCal:startFormula, progCal:fitconcatForms, progCal:endForm );
	progCal:derivFinalConcat = Concat( progCal:DerivStartFormula, progCal:fitDerivConcatForms, progCal:DerivEndForm );
	//Show( progCal:finalConcat, progCal:derivFinalConcat );
	
	//Evaluates the parsed version of the full concatenated string
	//Run just the Parse portion to see final format log window
	Eval( Parse( progCal:finalConcat ) );
	Eval( Parse( progCal:derivFinalConcat ) );
	
	//gets the last column created, which would be the derivate column above
	//ensures the graphs below use the latest instance of derivative and not a previous one
	progCal:lastDerivCol = Column( progCal:dataTable, N Col(progCal:dataTable) ) << getName;
	//creates inverse derivative to put slopes in "more expected way"
	progCal:derivName = Eval Insert( ":name( \!"^progCal:lastDerivCol ^\!" )" );
	Eval(
		EvalExpr(progCal:DataTable << New Column("Inverse(1stDeriv_RodBard4P)",
				Formula(
					1 / Expr(Parse(progCal:derivName))
				)
			)
		)
	);
	progCal:lastInvCol = Column( progCal:dataTable, N Col(progCal:dataTable) ) << getName;

	//graphs data from original table, one By 'By' varaiable, one combined
	progCal:fullBiv = progCal:dataTable << Fit Group(
		Bivariate( 
			Y( :Name("AR"), Column( progCal:lastDerivCol ) ),
			X( :Name("PROG Conc") )
		),
		Bivariate( 
			Y( Column( progCal:lastInvCol ) ),
			X( :Name("AR") )
		)
	);
	progCal:fullBiv << Arrange in Rows( 3 );

	progCal:colorList = {"Red", "Blue", "Black", "Gray", "Yellow", "Brown"};//should update for full list order
	//adds a custom script that graphs the equation over data

	Eval(
		Eval Expr(
			Report( progCal:fullBiv )[FrameBox( 1 )] << Add Graphics Script(
				1,
				Description( "RodBard4P-Linear" ),
				Pen Color( Expr( progCal:colorList[1] ) );
				Y Function(
					(Expr(progCal:fitCoeffList[1][3])) + (Expr(progCal:fitCoeffList[1][4]) - (Expr(progCal:fitCoeffList[1][3]))) / (1 + (x / Expr(progCal:fitCoeffList[1][2])) ^ Expr(progCal:fitCoeffList[1][1]))
				,
					x
				);
			);
			Report( progCal:fullBiv )[FrameBox( 2 )] << Add Graphics Script(
				1,
				Description( "RodBard4P-Linear" ),
				Pen Color( Expr( progCal:colorList[1] ) );
				Y Function(
					Eval(
						Derivative(
							(Expr(progCal:fitCoeffList[1][3])) + (Expr(progCal:fitCoeffList[1][4]) - (Expr(progCal:fitCoeffList[1][3]))) / (1 + (x / Expr(progCal:fitCoeffList[1][2])) ^ Expr(progCal:fitCoeffList[1][1]))
						,
						x
						)
					)
				,
					x
				);
			);
			Report( progCal:fullBiv )[FrameBox( 3 )] << Add Graphics Script(
					1,
					Description( "RodBard4P-Linear_" ),
					Pen Color( Expr( progCal:colorList[1] ) );
					Y Function(
						Eval(//deriv of inverted rodbard
							Derivative(Expr(progCal:fitCoeffList[1][2]) * Exp(	Log((Expr(progCal:fitCoeffList[1][4]) - (Expr(progCal:fitCoeffList[1][3]))) / (x - (Expr(progCal:fitCoeffList[1][3]))) - 1	) / Expr(progCal:fitCoeffList[1][1]))
							,
								x
							)
						)
					,
						x
					);
				);
		)
	);
		
	progCal << delete;

);

//MUCH OF THIS FUNCTION NO LONGER WORKS
//KEPT HERE AS REFERENCE IF NEEDED IN FUTURE (OTHER CURVE TOOLS GOOD REF ALSO)
progCal:startDialog = Function({},
	diagWindow = New Window( "Anchored Rodbard Calibration",
		Border Box( Left( 3 ), top( 2 ),
			V List Box(
				Text Box( "Choose columns for Control and Analyzer Response" ),
				H List Box(
					V List Box(
						Panel Box( "Select Columns",
							colListData = Col List Box( All, width( progCal:lbWidth ), nLines( Min( progCal:nc, 10 ) ), Grouped )
						),

					),
					Panel Box( "Cast Selected Columns into Roles",
						Lineup Box( N Col( 2 ), Spacing( 3 ),
							Button Box( "Concentration", colListYprogCal << Append( colListData << GetSelected ) ),
							colListYprogCal = Col List Box( width( progCal:lbWidth ), minitems( 1 ), maxitems( 1 ), nLines( 3 ), numeric ),
							Button Box( "Analyzer Resp", colListXprogCal << Append( colListData << GetSelected ) ),
							colListXprogCal = Col List Box( width( progCal:lbWidth ), minitems( 1 ), maxitems( 1 ), nLines( 1 ), numeric ),
							Button Box( "Target Conc", colListTprogCal << Append( colListData << GetSelected ) ),
							colListTprogCal = Col List Box( width( progCal:lbWidth ), minitems( 1 ), maxitems( 1 ), nLines( 1 ) ),
							Button Box( "By", colListBprogCal << Append( colListData << GetSelected ) ),
							colListBprogCal = Col List Box( width( progCal:lbWidth ), nLines( 1 ), maxitems( 1 ), character )
						)
					),
					Panel Box( "Action",
						Lineup Box( N Col( 1 ),
							Button Box( "OK",
								Batch Interactive(1);
								calibrationCurve();
								Batch Interactive(0)
							),
							Button Box( "Cancel", exprCancel() ),
							Text Box( " " ),
							Button Box( "Remove",
								colListYprogCal << RemoveSelected;
								colListBprogCal << RemoveSelected;
								colListXprogCal << RemoveSelected;
								colListTprogCal << RemoveSelected;
							),
							Button Box( "Recall", recallItems()),//Eval( progCal:recallItems ) )
						)
					)
				)
			)
		)
	);
);

////////////////////////////////////////
//                                    //
//             Main                   //
//                                    //
////////////////////////////////////////

If(Num(Word(1,jmpversion(),".")) <=12,
	wrongVer(13);
	progCal << delete;
	Throw();
);


calibrationCurve();
//progCal:startDialog();

