//Author(s)
//NClark
//IDEXX Laboratories, Inc.
//Westbrook, ME 04092

Names Default To Here( 1 );
//Clear Globals();

//------------------Revision History for script---------------------
//
//	1.9	NClark 041417
//		-> Updated CatOneUni expression for the absense of columns used later in the script (wavelength, segment)
//		-> Ensured all Column() references explicited listed dt_input as table reference
//		-> Invoked 'Names Default to Here()'
//	1.8 NClark 082916
//		-> Update idxQCPrep to work with CRP QC data - should still work with TT4, but will be verified for next TT4 update
//		-> Set up so no columns renamed, they are neither brand new or duplicates of existing columns with correct naming
//	1.7 NClark 062916
//		-> Updated the sort to include :Segment
//		-> Commented out 'Names default to Here' as includes match parent namespace
//	1.6	NClark 062416
//		-> Updated creation of 'Chem Type' formula to use assayCodes (included in main scripts) to match entire list of potential assay codes vs. data
//		-> Fixed bug with segNamePresence for assayNamePresence
//	1.5	NClark 062116
//		-> Updated 'fake' Chem Type formula in inHousePrep to use a 'knownChemType' variable
//			from the main script, if it exists, otherwise it sticks with 'unknown'
//	1.4 NClark 060316
//		-> updated idxQC to make 'Assay' column from CHEMCODE
//		-> added 'Chem Type' formula in idxQC to turn Assay # into Chem abbreivation
//		-> update default instMethod for idxQC to 'InstSW'
//		-> added 'Wavelength' column to idxQC
//	1.3 NClark 060116
//		-> Commented out 'clear globals' to allow globals to persist when this file is included
//	1.2 NClark 052616
//		-> Updated instMethod to be either InstSW or ISL as it is more indicative of the type of data
//	1.1 NCLark 052416
//		-> Reverted to old style duplicate removal (based on TimeFromSampleDispense:sec)
//			-> Found instances where duplicated existed but came from different source tables so row for row method didn't work
//	1.0 NClark 051616
//		-> First version released based on prep from CRP v2.2 script
//		-> Moved sorting outside of expressions (inside Try())
//		-> Moved truncation of TimeFromSampleDispense outside of expressions
//		-> Added wavelength support to inHousePrep
//		-> Added wavelength support to cdxUniverse
//		-> Added wavelength support to cat1Universe
//		-> Added wavelength support to robAssay
//		-> Added wavelength support to the Sort
//		-> Added support for either Assay :4 OR Assay :5 columns
//		-> Added support for either Segment :4 OR Segment :5 columns or No segment column
//		-> Added Chem Type support for all preps
//		-> Added Chem Type suppor to the sort (to help support multiple chems in a run w/o the need to subset)
//------------------------------------------------------------------

//A list of expressions that will set up the table for other Assay Dev scripts (correct column names, etc)
//Assumes the base 'Assay Dev' script has tagged the necessary table with the variable dt_input
//dt_input = currentdatatable();

//inhouse ... works with data from CatOne or Dx analyzers using system software or ISL scripting
//column names/renaming based on current base standards
inHousePrep = Expr(
 show(dt_input);
	instMtrx = Column(dt_input, "Instrument ID") << GetAsMatrix;
	instID = If(Contains(instMtrx[1],"CTDX")!=0,"CatDx","CatOne");

	//Done to establish presences of a "CatOne" labeled column (now also present in CDx data)
	colPresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Timeseries Time")),
			colPresence = 1
		),
	);
	
	//Done for presence of Species Name
	spNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Species Name")),
			spNamePresence = 1
		)
	);
	If(spNamePresence == 0,
		dt_input<<NewColumn("Species Name",Formula("default-Canine"));
		Column(dt_input,"Species Name")<<deleteformula;
	);
	
	//Done for presence of Wavelength
	wlNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Wavelength")),
			wlNamePresence = 1
		)
	);
	If(wlNamePresence == 0,
		dt_input<<NewColumn("Wavelength",Formula("Null"));
		Column(dt_input,"Wavelength")<<deleteformula
	,
		Column(dt_input,"Wavelength")<<DataType(Character);
	);
	
	//Done for presence of Segment
	segNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Segment")),
			segNamePresence = 1
		)
	);
	//Adds a fake segment column
	If(segNamePresence == 0,
		dt_input<<NewColumn("Segment",
			Formula(
				"UNK"
			)
		);
		Column(dt_input,"Segment")<<deleteformula;
	);
	
	//Done for presence of Chem Type
	chemTypeNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Chem Type")),
			chemTypeNamePresence = 1;
			chemTypeMtrx = Column(dt_input,"Chem Type")<<getasmatrix;
		)
	);
	//Adds a stand in Chem Type column
	If(chemTypeNamePresence == 0,
		dt_input<<NewColumn("Chem Type",
			Formula(
				If(IsMissing(knownChemType),"Unknown", knownChemType
				)
			)
		);
		Column(dt_input,"Chem Type")<<deleteformula;
	);
	//Updates existing Chem Type with Known Chem Type (if available)
	If(chemTypeMtrx[1] =="UNKNOWN",
		Column(dt_input,"Chem Type")<<SetFormula(
			If(IsMissing(knownChemType),"Unknown", knownChemType
			)
		);
		Column(dt_input,"Chem Type")<<evalformula;//if eval formula not done the formula didn't "stick" when it was deleted and original "UNKNOWN" remained
		Column(dt_input,"Chem Type")<<deleteformula;
	);

	//Esablishes difference b/n how ISL CDx data needs to be analysed vs. system SW CDx
	If(
		instID == "CatDx" & colPresence == 1,
			instMethod = "InstSW"
	,
		instID == "CatOne",
			instMethod = "InstSW"
	,
		instID == "CatDx",
			instMethod = "ISL"
	);

	//Renaming and creating a bunch of columns that may or may not be present depending on CDx or C1 origin
	Try(
		Column(dt_input,"Timeseries time")<<SetName("TimeFromSampleDispense:sec");
	);
	Try(
		Column(dt_input,"Timeseries RD")<<SetName("ReflDens_avg");
	);

	//Added 'workedFirst' to handle a new table-case that causes the Try() below to fail which results in
	//no 'Date' or 'Time' column to be created which then affects the 'Sort' command
	//If any part of the Try() works then worksFirst is changed to a different value
	//The If() below the Try() only processes if workedFirst == 0, signaling that the Date or Time columns weren't made
	workedFirst = 0;
	Try(
		If(
			instID == "CatDx" & colPresence == 1,
				Column(dt_input,"Time")<<SetName("GMTime");
				dt_input<<New Column("Date",Format("m/d/y"),
					Formula(
						If(
							IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) <= 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
								:DateTime,
							Lag( :Date, 1 )
						)
					)
				);
				dt_input<<New Column("Time",Format("h:m:s"),
					Formula(
						If(
							IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) <= 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
								:DateTime,
							Lag( :Time, 1 )
						)
					)
				);
				dt_input<<Move Selected Columns({"Date","Time"},After("DateTime"));
				workedFirst = 1;
		,
			instMethod == "ISL",
				dt_input<<New Column("DateTime",Format("y/m/d h:m:s"),
					Formula(
						Date DMY(
							Num( Word( 3, :Date ) ),
							Match( Word( 2, :Date ),
								"Jan", 1,
								"Feb", 2,
								"Mar", 3,
								"Apr", 4,
								"May", 5,
								"Jun", 6,
								"Jul", 7,
								"Aug", 8,
								"Sep", 9,
								"Oct", 10,
								"Nov", 11,
								"Dec", 12
							),
							Num( Word( 4, :Date ) )
						) + :Time
					)
				);
				Column(dt_input,"DateTime")<<DeleteFormula();
				Column(dt_input,"Date")<<SetName("Date-orig");
				Column(dt_input,"Time")<<SetName("Time-orig");
				dt_input<<New Column("Date",Format("m/d/y"),Formula(:Name("DateTime")));
				dt_input<<New Column("Time",Format("h:m:s"),Formula(:Name("DateTime")));
				dt_input<<Move Selected Columns({"Date","Time"},After("DateTime"));
				workedFirst = 2;
		,
			dt_input<<New Column("Date",Format("m/d/y"),
				Formula(
					If(
						IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) <= 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
							:DateTime,
						Lag( :Date, 1 )
					)
				)
			);
			dt_input<<New Column("Time",Format("h:m:s"),
				Formula(
					If(
						IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) <= 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
							:DateTime,
						Lag( :Time, 1 )
					)
				)
			);
			dt_input<<Move Selected Columns({"Date","Time"},After("Time Run Started"));
			workedFirst = 3;
		)
	);
	If(workedFirst == 0,
		dt_input<<New Column("Date",Format("m/d/y"),
			Formula(
				If(
					IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) <= 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
						:DateTime,
					Lag( :Date, 1 )
				)
			)
		);
		dt_input<<New Column("Time",Format("h:m:s"),
			Formula(
				If(
					IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) <= 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
						:DateTime,
					Lag( :Time, 1 )
				)
			)
		);
		dt_input<<Move Selected Columns({"Date","Time"},After("DateTime"));
	);
	Column(dt_input,"Date")<<DeleteFormula;
	Column(dt_input,"Time")<<DeleteFormula;
);

//smartServ ... works with raw data from smart service (the data warehouse) produced by another user with pre-defined queries
smartServPrep = Expr(
	
	Try(
		Column(dt_input,"INSTRUMENT_ID")<<SetName("Instrument ID");
	);
	
	instMtrx = Column(dt_input, "Instrument ID") << GetAsMatrix;
	instID = If(Contains(instMtrx[1],"CTDX")!=0,"CatDx","CatOne");

	//No field data should be run with old ISLs so all methods should be CatOne-like
	instMethod = "InstSW";	

	//Renaming and creating a bunch of columns that may or may not be present depending on CDx or C1 origin
	Try(
		Column(dt_input,"TIME_FR_SAMPLE_DISP")<<SetName("TimeFromSampleDispense:sec");
		Column(dt_input,"TimeFromSampleDispense:sec")<<Datatype(Numeric);
		Column(dt_input,"TimeFromSampleDispense:sec")<<ModelingType(Continuous);
	);
	
	Try(
		If(IsScriptable(Column(dt_input,"NORM_REFL")),
			dt_input << New Column("ReflDens_avg",Numeric,
				Formula(-Log10( Num( :NORM_REFL ) ))
			)
		)
	);

	Try(
		If(IsScriptable(Column(dt_input,"LINE_TIMESTAMP")),
			dt_input<<New Column("Date",Format("m/d/y"),Formula(:Name("LINE_TIMESTAMP")));
			dt_input<<New Column("Time",Format("h:m:s"),Formula(:Name("LINE_TIMESTAMP")));
			dt_input<<Move Selected Columns({"Date","Time"},After("LINE_TIMESTAMP"));
		)
	);
	
	Try(
		Column(dt_input,"SLIDE_LOT")<<SetName("Lot");
	);
	
	Try(
		Column(dt_input,"CHEM_TYPE")<<SetName("Chem Type");
	);
	
	Try(
		Column(dt_input,"SPECIES")<<SetName("Species Name");
	);

	//Creating new column with truncated decimals values to match query outputs
	//**********
	Try(//add if scriptable piece
		dt_input << New Column("TFSD:sec",Numeric,Continuous,
			Formula(Round(:Name("TimeFromSampleDispense:sec"),6))
		);

	//deleteing the formula, the original column and renaming the new column as the original
		Column(dt_input, "TFSD:sec")<<Delete Formula;
		dt_input << Delete Columns("TimeFromSampleDispense:sec");
		Column(dt_input, "TFSD:sec")<<SetName("TimeFromSampleDispense:sec");
	);

	//////Get Rid of Unwanted data
	//SAP
	dt_input<<Select Where(Char(:SAP_ID) == "191204" | Char(:SAP_ID) == "4300" | Char(:SAP_ID) == "UNKNOWN" )<<deleterows();
	//SW
	//dt_input<<Select Where(Starts With(:SW_VER, "1."))<<deleterows();
	
	//Sorting the data as one individual run at a time SORT BY SAPID, IVLSID, RUNID too???!!!
	dt_input << Sort(
		By( :SAP_ID, :IVLS_ID, :Instrument ID, :RUN_ID, :Date, :Time, :Name( "TimeFromSampleDispense:sec" ) ),
		Order( Ascending, Ascending, Ascending, Ascending, Ascending, Ascending, Ascending  ),
		Replace Table
	);
);

//idxQC ... designed to work with data that comes from the QC data tool (originally for TT4) and base structure has stayed consistent
idxQCprep = Expr(
	//Renaming and creating a bunch of columns that may or may not be present depending on R&D or Ops origin
	Try(
		Is Scriptable( Column(dt_input, "Instrument ID" ) ),
		If( Is Scriptable( Column(dt_input, "Instrument" ) ),
			dt_input << New Column( "Instrument ID", Formula( :Instrument ) );
			Column( dt_input, "Instrument ID" ) << DeleteFormula;
		)
	);
	
	instMtrx = Column(dt_input, "Instrument ID") << GetAsMatrix;
	instID = If(Contains(instMtrx[1],"CTDX")!=0,"CatDx","CatOne");

	//No field data should be run with old ISLs so all methods should be CatOne-like
	instMethod = "InstSW";
	
	Try(
		Is Scriptable(Column(dt_input,"TimeFromSampleDispense:sec")),
		If(Is Scriptable(Column(dt_input,"Seconds from Dispense")),
			dt_input << New Column( "TimeFromSampleDispense:sec", Formula( :Seconds from Dispense ) );
			Column( dt_input, "TimeFromSampleDispense:sec" ) << DeleteFormula;
		)
	);
	
	Try(
		If(IsScriptable(Column(dt_input,"Date/time")),
			dt_input<<New Column("Date",Format("m/d/y"),
				Formula(
					If(
						IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) <= 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
							:Name("Date/time"),
						Lag( :Date, 1 )
					)
				)
			);
			dt_input<<New Column("Time",Format("h:m:s"),
				Formula(
					If(
						IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) <= 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
							:Name("Date/time"),
						Lag( :Time, 1 )
					)
				)
			);
			dt_input<<Move Selected Columns({"Date","Time"},After("Date/time"));
		);
		Column( dt_input, "Date" ) << deleteformula;
		Column( dt_input, "Time" ) << deleteformula;
	);

	
	Try(
		Is Scriptable(Column(dt_input,"ReflDens_avg")),
		If(Is Scriptable(Column(dt_input,"Reflective Density")),
			dt_input << New Column( "ReflDens_avg", Formula( :Reflective Density ) );
			Column( dt_input, "ReflDens_avg" ) << DeleteFormula;
		)
	);
	Try(
		Is Scriptable(Column(dt_input,"Concentration Slide")),
		If(Is Scriptable(Column(dt_input,"CONCENTRATION")),
			dt_input << New Column( "Concentration Slide", Formula( :CONCENTRATION ) );
			Column( dt_input, "Concentration Slide" ) << DeleteFormula;
		)
	);
	
	Try(
		Is Scriptable(Column(dt_input,"Assay")),
		If(Is Scriptable(Column(dt_input,"CHEMCODE")),
			dt_input << New Column( "Assay", Formula( :CHEMCODE ) );
			Column( dt_input, "Assay" ) << DeleteFormula;
		)
	);

	dt_input<<NewColumn("Chem Type",Character(10),
		Formula(
			If(IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) < 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
				For(i=1,i<=nitems(assayCodes),i++,
					If(Contains(assayCodes[i],:Assay)>0,
					break();
					);
				);
				assayCodes[i][2]
			,
				Lag(:Chem Type,1)
			)
		)
	);
	Column(dt_input, "Chem Type") << DeleteFormula;
	
	dt_input<<NewColumn("Wavelength",Formula("Null"));
	Column(dt_input,"Wavelength")<<deleteformula
	
);

//cdxUni ... works with data from the CDx data warehouse that has unaltered names, but an expected base of columns is necessary
cdxUniverse = Expr(
	Column(dt_input,"Instrument Serial Number")<<SetName("Instrument ID");
	
	instMtrx = Column(dt_input, "Instrument ID") << GetAsMatrix;
	instID = If(Contains(instMtrx[1],"CTDX")!=0,"CatDx","CatOne");

	//Done for presence of Species Name
	spNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Species Name")),
			spNamePresence = 1
		)
	);
	If(spNamePresence == 0,
		dt_input<<NewColumn("Species Name",Formula("default-Canine"));
		Column(dt_input,"Species Name")<<deleteformula
	,
		dt_input<<New Column("Species Name",
			Formula(Match(:Species, 1, "Canine", 0, "Feline", 2, "Equine"))
		);
	);
	
	instMethod = "InstSW";

	//Renaming and creating a bunch of columns that may or may not be present depending on CDx or C1 origin
	Try(
		Column(dt_input,"Time :3")<<SetName("TimeFromSampleDispense:sec");
	);
	Try(
		Column(dt_input,"Reading :3")<<SetName("ReflDens_avg");
	);
	Try(
		Column(dt_input,"Lot :5")<<SetName("Lot");
	);
	Try(
		Column(dt_input,"Run Start Timestamp")<<SetName("DateTime");
	);
	Try(
		Column(dt_input,"Center Wavelengths1 :2")<<SetName("Wavelength");
	);
	
	
	//Done for presence of Assay
	assayNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Assay :4")),
			assayNamePresence = 1
		)
	);
	Try(
		If(IsScriptable(Column(dt_input,"Assay :5")),
			assayNamePresence = 2
		)
	);
	//Changes name of segment column or adds a fake segment column for 
	If(
		assayNamePresence == 1,
		Column(dt_input,"Assay :4")<<SetName("Assay")
	,
		assayNamePresence == 2,
		Column(dt_input,"Assay :5")<<SetName("Assay")
	);
	
	//Done for presence of Segment
	segNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Segment :4")),
			segNamePresence = 1
		)
	);
	Try(
		If(IsScriptable(Column(dt_input,"Segment :5")),
			segNamePresence = 2
		)
	);
	//Changes name of segment column or adds a fake segment column for analysis (large number so know not original value)
	If(segNamePresence == 0,
		dt_input<<NewColumn("Segment",
			Formula(
				If( Is Missing( Lag( :RunID, 1 ) ) | Lag( :RunID, 1 ) != :RunID,
					1,
					If( :Assay == Lag( :Assay, 100 ),
						Lag( :Name( "Segment" ), 1 ),
						Lag( :Name( "Segment" ), 1 ) + 1
					)
				)
			)
		);
		Column(dt_input,"Segment")<<deleteformula;
	,
		segNamePresence == 1,
		Column(dt_input,"Segment :4")<<SetName("Segment")
	,
		segNamePresence == 2,
		Column(dt_input,"Segment :5")<<SetName("Segment")
	);
	
	//Done for presence of Wavelength
	wlNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Wavelength")),
			wlNamePresence = 1
		)
	);
	If(wlNamePresence == 0,
		dt_input<<NewColumn("Wavelength",Formula("Null"));
		Column(dt_input,"Wavelength")<<deleteformula
	,
		Column(dt_input,"Wavelength")<<DataType(Character);
	);
	
	dt_input<<NewColumn("Chem Type",Character(10),
		Formula(
			If(IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) < 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0),
				For(i=1,i<=nitems(assayCodes),i++,
					If(Contains(assayCodes[i],:Assay)>0,
					break();
					);
				);
				assayCodes[i][2]
			,
				Lag(:Chem Type,1)
			)
		)
	);
	Column(dt_input, "Chem Type") << DeleteFormula;
	
	dt_input<<New Column("Date",Format("m/d/y"),Formula(:Name("DateTime")));
	dt_input<<New Column("Time",Format("h:m:s"),Formula(:Name("DateTime")));
	dt_input<<Move Selected Columns({"Date","Time"},After("DateTime"));
	
);

//cdxUni ... works with data from the CatOne data warehouse that has unaltered names, but an expected base of columns is necessary
cat1Universe = Expr(
	Column(dt_input,"Instrument Serial Number")<<SetName("Instrument ID");
	
	instMtrx = Column(dt_input, "Instrument ID") << GetAsMatrix;
	instID = If(Contains(instMtrx[1],"CTDX")!=0,"CatDx","CatOne");

	instMethod = "InstSW";

	//Renaming and creating a bunch of columns that may or may not be present depending on CDx or C1 origin
	Try(
		Column(dt_input,"Readings: Time Between Read and Dispense")<<SetName("TimeFromSampleDispense:sec");
	);
	Try(
		If(IsScriptable(Column(dt_input,"Readings: Normal Reflectance")),
			dt_input << New Column("ReflDens_avg",Numeric,
				Formula(-Log10( Num( :Name("Readings: Normal Reflectance") ) ))
			)
		)
	);
	//Done for presence of Species Name
	spNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Species")),
			spNamePresence = 1
		)
	);
	If(spNamePresence == 0,
		dt_input<<NewColumn("Species Name",Formula("default-Canine"));
		Column(dt_input,"Species Name")<<deleteformula
	,
		Column(dt_input,"Species")<<SetName("Species Name");
	);
	Try(
		Column(dt_input,"Results: Slide Lot Number")<<SetName("Lot");
	);
	Try(
		Column(dt_input,"Run Start Timestamp")<<SetName("DateTime");
	);
	//Done for presence of Segment
	segNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Results: Carousel Segment")),
			segNamePresence = 1
		)
	);
	//Adds a fake segment column
	If(segNamePresence == 0,
		dt_input<<NewColumn("Segment",
			Formula(
				"UNK"
			)
		);
		Column(dt_input,"Segment")<<deleteformula
	,
		Column(dt_input,"Results: Carousel Segment")<<SetName("Segment");
	);
	
	Try(
		Column(dt_input,"Assay Type")<<SetName("Chem Type");
	);
	
	//Done for presence of Wavelength
	wlNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Results: Center Wavelengths 1")),
			wlNamePresence = 1
		)
	);
	If(wlNamePresence == 0,
		dt_input<<NewColumn("Wavelength",Formula("Null"));
		Column(dt_input,"Wavelength")<<deleteformula
	,
		Column(dt_input,"Results: Center Wavelengths 1")<<SetName("Wavelength");
		Column(dt_input,"Wavelength")<<DataType(Character);
	);
	
	//Done for presence of Wavelength
	wlNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Wavelength")),
			wlNamePresence = 1
		)
	);
	If(wlNamePresence == 0,
		dt_input<<NewColumn("Wavelength",Formula("Null"));
		Column(dt_input,"Wavelength")<<deleteformula
	,
		Column(dt_input,"Wavelength")<<DataType(Character);
	);

	dt_input<<New Column("Date",Format("m/d/y"),Formula(:Name("DateTime")));
	dt_input<<New Column("Time",Format("h:m:s"),Formula(:Name("DateTime")));
	dt_input<<Move Selected Columns({"Date","Time"},After("DateTime"));
	
);

//robAssay ... based on a custom tool to pull log data with a very basic structure
robAssayToolPrep = Expr(
	Column(dt_input,"Instrument#")<<SetName("Instrument ID");
	
	instMtrx = Column(dt_input, "Instrument ID") << GetAsMatrix;
	instID = If(Contains(instMtrx[1],"CTDX")!=0,"CatDx","CatOne");

	//Done to establish presences of a "CatOne" labeled column (now also present in CDx data)
	colPresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Timeseries Time")),
			colPresence = 1
		)
	);
	
	//Done for presence of Species Name
	spNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Species Name")),
			spNamePresence = 1
		)
	);
	If(spNamePresence == 0,
		dt_input<<NewColumn("Species Name",Formula("default-Canine"));
		Column(dt_input,"Species Name")<<deleteformula;
	);
	
	//Done for presence of Segment
	//Adds 'Segment' column for commonRunID, but isn't true segment
	segNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Segment")),
			segNamePresence = 1
		)
	);
	If(segNamePresence == 0,
		dt_input<<NewColumn("Segment",
			Formula(
				If( Is Missing( Lag( :RunID, 1 ) ) | Lag( :RunID, 1 ) != :RunID,
					1,
					If( :Assay# == Lag( :Assay#, 100 ),
						Lag( :Name( "Segment" ), 1 ),
						Lag( :Name( "Segment" ), 1 ) + 1
					)
				)
			)
		);
		Column(dt_input,"Segment")<<deleteformula;
	);
	
	//Done for presence of Chem Type
	chemTypeNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Chem Type")),
			chemTypeNamePresence = 1
		)
	);
	//Adds a fake segment column
	If(chemTypeNamePresence == 0,
		dt_input<<NewColumn("Chem Type",
			Formula(
				"Unknown"
			)
		);
		Column(dt_input,"Chem Type")<<deleteformula;
	);

	//Esablishes difference b/n how ISL CDx data needs to be analysed vs. system SW CDx
	If(
		instID == "CatDx" & colPresence == 1,
			instMethod = "InstSW"
	,
		instID == "CatOne",
			instMethod = "InstSW"
	,
		instID == "CatDx",
			instMethod = "ISL"
	);

	//Renaming and creating a bunch of columns that may or may not be present depending on CDx or C1 origin
	Try(
		Column(dt_input,"Time")<<SetName("TimeFromSampleDispense:sec");
	);
	Try(
		Column(dt_input,"RD")<<SetName("ReflDens_avg");
	);
	
	//Done for presence of Wavelength
	wlNamePresence = 0;
	Try(
		If(IsScriptable(Column(dt_input,"Wavelength")),
			wlNamePresence = 1
		)
	);
	If(wlNamePresence == 0,
		dt_input<<NewColumn("Wavelength",Formula("Null"));
		Column(dt_input,"Wavelength")<<deleteformula
	,
		Column(dt_input,"Wavelength")<<DataType(Character);
	);

	//Added 'workedFirst' to handle a new table-case that causes the Try() below to fail which results in
	//no 'Date' or 'Time' column to be created which then affects the 'Sort' command
	//If any part of the Try() works then worksFirst is changed to a different value
	//The If() below the Try() only processes if workedFirst == 0, signaling that the Date or Time columns weren't made
	workedFirst = 0;
	//following unecessary for this table prep but leaving in if it's needed later
	/*Try(
		If(
			instID == "CatDx" & colPresence == 1,
				Column(dt_input,"Time")<<SetName("GMTime");
				dt_input<<New Column("Date",Format("m/d/y"),Formula(:Name("DateTime")));
				dt_input<<New Column("Time",Format("h:m:s"),Formula(:Name("DateTime")));
				dt_input<<Move Selected Columns({"Date","Time"},After("DateTime"));
				workedFirst = 1;
		,
			instMethod == "ISL",
				dt_input<<New Column("DateTime",Format("y/m/d h:m:s"),
					Formula(
						Date DMY(
							Num( Word( 3, :Date ) ),
							Match( Word( 2, :Date ),
								"Jan", 1,
								"Feb", 2,
								"Mar", 3,
								"Apr", 4,
								"May", 5,
								"Jun", 6,
								"Jul", 7,
								"Aug", 8,
								"Sep", 9,
								"Oct", 10,
								"Nov", 11,
								"Dec", 12
							),
							Num( Word( 4, :Date ) )
						) + :Time
					)
				);
				Column(dt_input,"DateTime")<<DeleteFormula();
				Column(dt_input,"Date")<<SetName("Date-orig");
				Column(dt_input,"Time")<<SetName("Time-orig");
				dt_input<<New Column("Date",Format("m/d/y"),Formula(:Name("DateTime")));
				dt_input<<New Column("Time",Format("h:m:s"),Formula(:Name("DateTime")));
				dt_input<<Move Selected Columns({"Date","Time"},After("DateTime"));
				workedFirst = 2;
		,
			dt_input<<New Column("Date",Format("m/d/y"),Formula(:Name("Time Run Started")));
			dt_input<<New Column("Time",Format("h:m:s"),Formula(:Name("Time Run Started")));
			dt_input<<Move Selected Columns({"Date","Time"},After("Time Run Started"));
			workedFirst = 3;
		)
	);*/
	If(workedFirst == 0,
		dt_input<<New Column("Date",Format("m/d/y"),Formula(:Name("DateTime")));
		dt_input<<New Column("Time",Format("h:m:s"),Formula(:Name("DateTime")));
		dt_input<<Move Selected Columns({"Date","Time"},After("DateTime"));
	);

);


//Sets up whether or not this data is in-house or from the field (smart service) and evaluates the correct prep sequence
//based on specific column presence (assume this one columen equates to one data type or another)
fieldDataPresence = 0;
Try(
	If(IsScriptable(Column(dt_input,"CHEM_CODE")), //Only Present in smart service data
		fieldDataPresence = 1
	)
);

Try(
	If(IsScriptable(Column(dt_input,"Instrument")), //Only Present in manufacturing data
		fieldDataPresence = 2
	)
);

Try(
	If(IsScriptable(Column(dt_input,"Reading :3")), //Only Present in manufacturing data
		fieldDataPresence = 3
	)
);

Try(
	If(IsScriptable(Column(dt_input,"Readings: Time Between Read and Dispense")), //Only Present in cat1 universe data
		fieldDataPresence = 4
	)
);

Try(
	If(IsScriptable(Column(dt_input,"RD")), //Only Present data from Rob's Generic assay (TT4) tool
		fieldDataPresence = 5
	)
);

//based on results of 'column finding' the correct expression is evaluated
Match(fieldDataPresence,
	0, Eval(inHousePrep)
,
	1, Eval(smartServPrep)
,
	2, Eval(idxQCprep)
,
	3, Eval(cdxUniverse)
,
	4, Eval(cat1Universe)
,
	5, Eval(robAssayToolPrep)
);

//Creating new column with truncated decimals values to match query outputs
//**********
Try(//add if scriptable piece
	dt_input << New Column("TFSD:sec",Numeric,Continuous,
		Formula(Round(:Name("TimeFromSampleDispense:sec"),6))
	);

//deleteing the formula, the original column and renaming the new column as the original
	Column(dt_input, "TFSD:sec")<<Delete Formula;
	dt_input << Delete Columns("TimeFromSampleDispense:sec");
	Column(dt_input, "TFSD:sec")<<SetName("TimeFromSampleDispense:sec");
);

//Sorting the data as one individual run at a time
Try(
	dt_input << Sort(
		By( :Instrument ID, :Date, :Time, :Wavelength, :Chem Type, :Segment,:Name( "TimeFromSampleDispense:sec" ) ),
		Order( Ascending, Ascending, Ascending, Ascending, Ascending, Ascending, Ascending ),
		Replace Table
	);
);

//Removes duplicate runs by comparing timestamps (TimeFromSampleDispense:sec)
dt_input << SelectWhere((:Name("TimeFromSampleDispense:sec")==Lag(:Name("TimeFromSampleDispense:sec"),1)))<<deleterows();

//Once sorted, a read point column is added
dt_input << New Column( "Read Point",
	Formula(
		If( Is Missing( Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) ) | Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) > :Name( "TimeFromSampleDispense:sec" ),
				If(:Name("TimeFromSampleDispense:sec") < 0,
					Index1 = -1;
					While( Lag( :Name( "TimeFromSampleDispense:sec" ), Index1 ) < 0, Index1-- );
					readPoint = 0 + index1
				,
					readPoint = 0
				)
		,
			Lag( :Read Point, 1 ) + 1
		)
	)
);

//Sets all rows and columns to being unselected
dt_input << SelectAllRows;
dt_input << InvertRowSelection;
For(i=1,i<=ncol(dt_input),i++,
	Column(dt_input,i) << Set Selected(0)
);

////////////////////////////////////////// End Table Prep //////////////////////////////////////////////



