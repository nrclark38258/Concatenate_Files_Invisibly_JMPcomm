//Author(s)
//NClark
//IDEXX Laboratories, Inc.
//Westbrook, ME 04092

Names Default To Here( 1 );
//Clear Globals();

//------------------Revision History for script---------------------
//
//	3.3 NClark 072417
//		-> Updated flagging function to use assay_Name instead of assayName
//	3.2 NClark 012617
//		-> Updated flagging for TT4 so Sample+Conj is Sample Mix
//		-> Updated calc concs to handle empty AR rows correctly
//	3.1 NClark 010217
//		-> Added preDeveopmentMetric function for more dynamic calculations around predevelopment reads
//		-> Updated assayDevFlagging so sampMixMinusRespAvg (CRP) is minus AR instead of RespAvg
//	3.0 NClark 120816
//		-> Further improved function (dry read and flagging) handling of instrument errors
//	2.9 NClark 111716
//		-> concentration calculation
//			-> updated so CRP is always species '99'
//	2.8 NClark 111516
//		-> concentration calculation
//			-> fixed typo with stdCharCubic
//			-> updated logic so only evaluates if correct chem code
//			-> only evaluates when AR changes, otherwise just repeats previous value
//			-> added parsed version of colName to use in formula for lag() function
//	2.7 NClark 111416
//		-> concentration calculation
//			-> Updated so function opens correct curve database file
//			-> Added CRP to chemcode list
//			-> Updated formula not to evaluate if no match found
//	2.6 NClark 101216
//		-> updated genericInterpMetric to handle all 'wet' reads (post time 0) for any of the metrics
//		-> updated assayDevFlagging to handle CRP
//	2.5 NClark 062116
//		-> Added an chemCalculatedConcentration function
//		-> Added a flagging function (assayDevFlagging)
//	2.4 NClark 061316
//		-> genericInterpMetric
//			-> added xList check to catch issue where ending time is before 1st postive read (usually for EndPoint just prior to postive reads)
//			-> check added additional point so extrapolation happens correctly
//	2.3 NClark 060216
//		-> Eliminated checkvalue and expectnum from genericInterpMetric
//		-> Improved While() in genericInterpMetric
//			-> in order to iterate index and index1, lag of time cannot be less than previous time else a fail flag (failTest) is tripped
//		-> Updated start of IF statement for calculation to check failTest rather than expectNum
//		-> changed genericAngleCalc so parameter set addon is "-paramSet" instead of "_paramSet"
//	2.2 NClark 060116
//		-> Added genericAngleCalc fuction for angle calculations
//		-> Commented out 'clear globals' to allow globals to persist when this file is included
//		-> Updated genericInterpMetric so the checkValue is based on the 5th and 4th list value rather than the 2nd and 1st
//	2.1 NClark 052516
//		-> Updated all functions to have a tableName parameter
//	2.0 NClark 052416
//		-> Added dryReadMetric function
//		-> Updated 'metric' in both functions to be String
//		-> Added preDevelopmentRead function
//		-> Updated functions to delete formulas made
//	1.0 NClark 051616
//		-> First version released
//------------------------------------------------------------------


//-------------------------------------genericInterpMetric------------------------------
//Function produces a column metric for a progress curve between two time points in that curve
//Assumptions are as follows:
//	Time and RD columes are "TimeFromSampleDispense:sec" and "ReflDens_avg" respectively
//		this will be true if the table prep script is run as with most AssayDev Tools
//
//Inputs are as follows:
//	tableName - variable for table or Datatable("actual table name")
//	columName - desired final column name, quoted string
//	startingTime - start time of metric calculation, number
//		typing 'all' will use all response reads in metric
//	endingTime - end time of metric calculation, number
//		typing 'all' will use all response reads in metric
//	metric - String call for metric:
//		"Slope"
//		"Range"
//		"AvgEP" - Average End Point (average of several points)
//		"EP" - End Point
// All metrics use interpolation to estimate ReflDens_avg values for the specific start and end time
// End Point times do not use 'startingTime' but a number - smaller than endingTime - is needed for function to work. The function only uses the endingTime for end point calculation
//
//Outputs are as follows:
//	parseColName - a column form of the quoted string ("Test Column" becomes :Test Column)
//	column in table but deleted formula

genericInterpMetric = Function({tableName,columnName,startingTime,endingTime,metric},

	parseColName = Parse( Eval Insert( ":name(\!"^columnName^\!" )" ) );

	tableName << New Column( columnName,
		Numeric,
		Continuous,
		Formula(
			If( :Name( "TimeFromSampleDispense:sec" ) ==0 & (Lag( :Name( "TimeFromSampleDispense:sec" ), -1 ) <= 0 | IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), -1 ))),
					-999,
				IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) < 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0), 
					xList = {};
					yList = {};
					Index = 1;
					Index1 = 1;
					failTest1 = 1;
					failTest2 = 1;
					//Translates starting and endingTime to ALL CAPS to ensure 'All' matches correctly, if present
					//Try covers if a failure occurs when value is a number not character
					Try(st = Uppercase(startingTime),
						st = startingTime
					);
					Try(et = Uppercase(endingTime),
						et = endingTime
					);
					//show(startingTime, endingTime, st, et);
					
					If(st == "ALL" | et == "ALL",
						//Print("All found");
						//Grabs row for 1st row after time 0
						While( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index ) < 0,
							If( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index - 1 ) < Lag( :Name( "TimeFromSampleDispense:sec" ), -Index ), failTest1 = 2;Break()
							,
								Index++
							)
						);
						//Grabs row right before move to next run (or error run)
						While( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 ) < Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 - 1 ),
							If( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 - 1 ) < Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 ), failTest2 = 2;Break()
							,
								Index1++
							)
						);			
					,		
						//Print("I went Normal");
						//Grabs row right after startingTime
						While( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index ) < startingTime,
							If( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index - 1 ) < Lag( :Name( "TimeFromSampleDispense:sec" ), -Index ), failTest1 = 2;Break()
							,
								Index++
							)
						);
						//Grabs row right after endingTime
						While( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 ) < endingTime,
							If( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 - 1 ) < Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 ), failTest2 = 2;Break()
							,
								Index1++
							)
						);
					);	
					
					StartPoint = Row() + Index;
					//Index2 = Row();
					EndPoint = Row() + Index1 - 1;
					numRows = EndPoint - StartPoint + 1;
					//Show(startPoint,endPoint);
					
					//creates x and y lists. if time is present, lists need additional values to bookend times
					If(st == "ALL" | et == "ALL",
						For( i = StartPoint, i <= EndPoint + 1, i++,
							Insert Into( xList, :Name( "TimeFromSampleDispense:sec" )[i] );
							Insert Into( yList, :ReflDens_avg[i] );
						);
					,
						For( i = StartPoint - 1, i <= EndPoint + 1, i++,
							Insert Into( xList, :Name( "TimeFromSampleDispense:sec" )[i] );
							Insert Into( yList, :ReflDens_avg[i] );
						);
					);
					//show(xlist,ylist);
					
					//For the rare event when the ending time isn't bookeneded by two usable numbers (first is negative, second is larger)
					//Adds an additional number to each of the lists to perform the exrapolation
					//Typically would happen when looking for EndPoint and endingTime is the desired EndPoint which occurs prior to the first positive read
					If(xList[1]<0 & xList[2]>endingTime & nitems(xList) ==2,
						Insert Into( xList, :Name( "TimeFromSampleDispense:sec" )[i] );
						Insert Into( yList, :ReflDens_avg[i] );
					);
					//Show( failTest1,failTest2,Row(),Index,Index1,startpoint,endpoint,xList, yList );
					//checkValue = xList[5] - xList[4];
					//expectNum = (endingTime - startingTime) / checkValue;
					//show(checkValue, expectNum);
					If( failTest1 == 2 | failTest2 == 2,
						-999,
						endInterp = N Items( yList );
						endInterp1 = endInterp - 1;
						
						If(st == "ALL" | et == "ALL",
							Empty()
						,
							If( xList[1] > 0, 
								//Moved away from clean 'interpolate' function as it does not handle negative slopes - a true possibility for assay development
								//interp1 = Interpolate( startingTime, xList[1], yList[1], xList[2], yList[2] );
								mSlope = ((yList[2] - yList[1]) / (xList[2] - xList[1]));
								bInt = yList[2] - mSlope * xList[2];
								interp1 = mSlope * startingTime + bInt;
								//interp2 = Interpolate( endingTime, xList[endInterp1], yList[endInterp1], xList[endInterp], yList[endInterp] );
								mSlope1 = ((yList[endInterp] - yList[endInterp1]) / (xList[endInterp] - xList[endInterp1]));
								bInt1 = yList[endInterp] - mSlope1 * xList[endInterp];
								interp2 = mSlope1 * endingTime + bInt1;
								//Show( interp1, interp2 );
								Remove From( xList, endInterp );
								Remove From( yList, endInterp );
								Remove From( xList, 1 );
								Remove From( yList, 1 );
								Insert Into( xList, startingTime, 1 );
								Insert Into( yList, interp1, 1 );
								Insert Into( xList, endingTime );
								Insert Into( yList, interp2 );
							, 
								
								mSlope = ((yList[3] - yList[2]) / (xList[3] - xList[2]));
								bInt = yList[3] - mSlope * xList[3];
								interp1 = mSlope * startingTime + bInt;
								//interp2 = Interpolate( endingTime, xList[endInterp1], yList[endInterp1], xList[endInterp], yList[endInterp] );
								mSlope1 = ((yList[endInterp] - yList[endInterp1]) / (xList[endInterp] - xList[endInterp1]));
								bInt1 = yList[endInterp] - mSlope1 * xList[endInterp];
								interp2 = mSlope1 * endingTime + bInt1;
								//Show( mSlope, bInt, interp1, interp2 );
								Remove From( xList, endInterp );
								Remove From( yList, endInterp );
								Remove From( xList, 1 );
								Remove From( yList, 1 );
								Insert Into( xList, startingTime, 1 );
								Insert Into( yList, interp1, 1 );
								Insert Into( xList, endingTime );
								Insert Into( yList, interp2 );
							);
						);
						
						//Show( xList, yList );
						xMtrx = Matrix( xList );
						yMtrx = Matrix( yList );
						//Show( xMtrx, yMtrx );
						
						Match(metric,
							//Slope
							"Slope", xMtrx = J( N Row( xMtrx ), 1 ) || xMtrx;
								intSlope = Inv( xMtrx` * xMtrx ) * xMtrx` * yMtrx;
								arSlope = intSlope[2];
								arSlope;
							,
							//Range
							"Range", range = Max(yMtrx) - Min(yMtrx);
							,
							//Average
							"AvgEP", avgEndPoint = Mean(yMtrx);
							,
							//EndPoint
							"EP", npts = nitems(yList);
								endPoint = yMtrx[npts];
						);						
					);
			,
				:Name( "TimeFromSampleDispense:sec" ) > Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ),
					Lag( parseColName, 1 )
			)
		)
	);
	Column(tableName,columnName)<<deleteformula;
);

//-------------------------------------End/genericInterpMetric------------------------------

//-------------------------------------dryReadMetric----------------------------------------
//Function calculates a dry read from a single or multiple dry read points
//Assumptions are as follows:
//	Time and RD columes are "TimeFromSampleDispense:sec" and "ReflDens_avg" respectively
//		this will be true if the table prep script is run as with most AssayDev Tools
//
//Inputs are as follows:
//	tableName - variable for table or Datatable("actual table name")
//	pointsBetween - numerical value for the number of non-dry read points between dry reads and positive time reads
//		(EX: TT4 has the Sample/Conjugate and Wash reads [1 each] between dry and positive time so pointsBetween = 2)
//	metric - String call for metric:
//		"Average" - Will take a single dry read or the average of several
//		"Range"
//
//Outputs are as follows:
//	dryColumnName - a quoted version of the column name, specific for this function 
//	dryParseColName - a column form of the quoted string ("Test Column" becomes :Test Column)
//	column in table but deleted formula

dryReadMetric = Function({tableName,pointsBetween,metric},
	
	Match(metric,
		//Average
		"Average", dryColumnName = "Dry Read";
	,
		//Range
		"Range", dryColumnName = "Dry Read Range";
	);
	dryParseColName = Parse( Eval Insert( ":name(\!"^dryColumnName^\!" )" ) );
	
	tableName << New Column( dryColumnName,
		Numeric,
		Continuous,
		Formula(
			If( :Name( "TimeFromSampleDispense:sec" ) ==0 & (Lag( :Name( "TimeFromSampleDispense:sec" ), -1 ) <= 0 | IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), -1 ))),
					-999,
				IsMissing(Lag(:Name( "TimeFromSampleDispense:sec" ),1)) | :Name( "TimeFromSampleDispense:sec" ) < 0 & Lag(:Name( "TimeFromSampleDispense:sec" ),1) >= 0,
					Index1 = 1;
					While(Lag(:Name("TimeFromSampleDispense:sec"),-Index1)<0,Index1++);
					StartPoint= Row();
					EndPoint = StartPoint + Index1 - (pointsBetween + 1);
					numPts = endPoint - startPoint + 1;
					//show(startpoint,index1,endpoint,numPts);
					/*SumXY = Summation(
						sp = StartPoint,
						EndPoint,
						:ReflDens_avg[sp,Empty()]
					);*/
					//puts all dry RDs in list and calculates the range
					dryList = {};
					For(i=startPoint, i<=endPoint, i++,
						InsertInto(dryList,:ReflDens_avg[i])
					);

					//m = SumXY / numPts;//set up for several metrics
					Match(metric,
						//Average
						"Average", avg = Mean(dryList);
					,
						//Range
						"Range", range = Max(dryList) - Min(dryList);
					);
			,
				Lag( dryParseColName, 1 )
			)
		)
	);
	Column(tableName,dryColumnName)<<deleteformula;
);

//-------------------------------------End/dryReadMetric------------------------------------

//-------------------------------------preDevelopmentRead----------------------------------------
//Function extracts other pre-development reads that only occur once per read type (one wash read, one sample/gold read)
//Assumptions are as follows:
//	Time and RD columes are "TimeFromSampleDispense:sec" and "ReflDens_avg" respectively
//		this will be true if the table prep script is run as with most AssayDev Tools
//	Read in question only occurs once for a given run (you can't have several wash reads, etc)
//
//Inputs are as follows:
//	tableName - variable for table or Datatable("actual table name")
//	columnName - Named for read being gathered ("Sample/Conjugate", for example)
//	pointsBeforeDev - numerical value for the number of reads before color development
//		(EX wash is 1 for TT4, sample/conjugate is 2 for TT4, sample/gold is 1 for CRP)
//
//Outputs are as follows:
//	preDevParseColName - a column form of the quoted string ("Test Column" becomes :Test Column)
//	column in table but deleted formula
//NOTE: This function could be used for dry read if only 1 dry read value is present or you only want a specific dry read taken

preDevelopmentRead = Function({tableName,columnName, pointsBeforeDev},
	
	preDevParseColName = Parse( Eval Insert( ":name(\!"^columnName^\!" )" ) );
	
	tableName << New Column( columnName,
		Numeric,
		Continuous,
		Formula(
			If( :Name( "TimeFromSampleDispense:sec" ) ==0 & (Lag( :Name( "TimeFromSampleDispense:sec" ), -1 ) <= 0 | IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), -1 ))),
					-999,
				IsMissing(Lag(:Name( "TimeFromSampleDispense:sec" ),1)) | :Name( "TimeFromSampleDispense:sec" ) < 0 & Lag(:Name( "TimeFromSampleDispense:sec" ),1) >= 0,
					Index1 = 1;
					While(Lag(:Name("TimeFromSampleDispense:sec"),-Index1)<0,Index1++);
					devStart= Row() + index1;
					getRead = devStart - pointsBeforeDev;
					//show(row(),index1,devStart,getRead);
					readValue = :Name("ReflDens_avg")[getRead]
			,
				Lag( preDevParseColName, 1 )
			)
		)
	);
	Column(tableName,columnName)<<deleteformula;
);

//-------------------------------------End/preDevelopmentRead------------------------------------

//-------------------------------------preDevelopmentMetric----------------------------------------
//Function creates metrics from predevelopment reads (although some use could be done with post development)
//	Time and RD columes are "TimeFromSampleDispense:sec" and "ReflDens_avg" respectively
//		this will be true if the table prep script is run as with most AssayDev Tools
//	Unlike other preDevelopment read functions, this one works with several dry reads, sampleMix reads, etc
//	However, it is limited to only two "Events" pre development (ie sampleMix and Wash)
//
//Inputs are as follows:
//	tableName - variable for table or Datatable("actual table name")
//	columnName - Named for read being gathered ("Sample/Conjugate", for example)
//	metric - string version of following metrics (script will adjust case)
//		- SP, single point (uninterpolated EndPoint)
//		- range, range of uninterpolated values
//		- avg, average of uninterpolated values
//		- slope, slope of uninterpolated values
//		//// The above is defaulted to SP for single point choice
//	direction - string Dry or Wet (script will adjust case) fills list directionally based on eventOneTime (dry looks left, wet looks right)
//		//// The above is defaulted to Dry
//	eventOneTime - Time of 1st event (ie, SampleMix). Script gathers list starting with 1st read post this time
//	eventTwoTime - Time of 2nd event (ie, wash). Script gathers list ending with read just prior to this number unless NULL
//		//// The two above are defaulted as NULL and aren't necessary. The script gathers all reads pre 0 for 'dry' and all reads post '0' for wet
//		//// The script converts any string to "NULL"
//	singlePoint - choice of point in list
//		//// The above is defaulted to 1
//		//// Any string value is converted to "LAST" and selects the last point in the list, no matter how long
//
// -999 is the default return for many cases indicating a problem with the curve or user inputs in the function
//		-- event times greater than total read times
//		-- single point choice greater than number of items in the list
//		-- curve errors where curve isn't fully complete (may result the above two)
//		-- metric listed isn't an allowable metric (typos included)
//
//Outputs are as follows:
//	preDevParseColName - a column form of the quoted string ("Test Column" becomes :Test Column)
//	column in table but deleted formula
//NOTE: This function has opportunities to be used for other sets of reads, but it hasn't been tested as such

preDevelopmentMetric = Function({tableName,columnName,metric="sp",direction="Dry",eventOneTime="NULL",eventTwoTime="NULL",singlePoint=1},
	
	preDevParseColName = Parse( Eval Insert( ":name(\!"^columnName^\!" )" ) );
	metric = Uppercase(metric);
	direction = Uppercase(direction);
	origEventOneTime = If(!IsNumber(eventOneTime),"NULL",eventOneTime); //to reset for error conditions
	origEventTwoTime = If(!IsNumber(eventTwoTime),"NULL",eventTwoTime); //to reset for error conditions
	eventOneTime = If(!IsNumber(eventOneTime),"NULL",eventOneTime);
	eventTwoTime = If(!IsNumber(eventTwoTime),"NULL",eventTwoTime);
	origSinglePoint = If(!IsNumber(singlePoint),"LAST",singlePoint); //to reset at the end
	singlePoint = If(!IsNumber(singlePoint),"LAST",singlePoint);
	//show(metric,direction,eventOneTime,eventTwoTime);
	
	tableName << New Column( columnName,
		Numeric,
		Continuous,
		Formula(
			If( :Name( "TimeFromSampleDispense:sec" ) == 0 & (Lag( :Name( "TimeFromSampleDispense:sec" ), -1 ) <= 0 | IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), -1 ))),
					-999,
				IsMissing(Lag( :Name( "TimeFromSampleDispense:sec" ), 1 )) | (:Name( "TimeFromSampleDispense:sec" ) < 0 & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) >= 0), 
					xList = {};
					yList = {};
					Index = 1;
					Index1 = 1;
					Index2 = 1;
					failTest1 = 1;
					failTest2 = 1;
					failTest3 = 1;
					
					//gets the time of the last read in the run
					While( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index2 ) > Lag( :Name( "TimeFromSampleDispense:sec" ), -Index2 + 1 ),
						Index2++
						
					);
					runEndRow = Row() + Index2 - 1;
					runEndTime = :Name( "TimeFromSampleDispense:sec" )[runEndRow];
					
					//Used to trigger failure if run doesn't have times great enough for time capture
					If(eventOneTime > runEndTime, eventOneTime = runEndTime; failTest3 = 2);
					If(eventTwoTime > runEndTime, eventTwoTime = runEndTime; failTest3 = 2);
					
					//if both event times are missing, assumption will be all negative reads used in metric
					If(eventOneTime == "NULL",
						If(direction == "DRY", eventOneTime = -10000 //should guarantee the 1st read will be grabbed
						, 
							direction == "WET", eventOneTime = 0
						)
					);
					If(eventTwoTime == "NULL",
						If(direction == "DRY", eventTwoTime = 0
						,
							direction == "WET", eventTwoTime = runEndTime //should guarantee the last read will be grabbed
						)
					);
					//show(runEndRow,runEndTime,eventOneTime,eventTwoTime);
					
					//Grabs row right after startingTime
					While( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index ) < eventOneTime,
						If( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index - 1 ) < Lag( :Name( "TimeFromSampleDispense:sec" ), -Index ), failTest1 = 2;Break()
						,
							Index++
						)
					);
					//Grabs row right after endingTime
					While( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 ) < eventTwoTime,
						If( Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 - 1 ) < Lag( :Name( "TimeFromSampleDispense:sec" ), -Index1 ), failTest2 = 2;Break()
						,
							Index1++
						)
					);
					
					Match(direction,
						"DRY", startPoint = Row(); endPoint = Row() + Index - 1
					,
						"WET",
							startPoint = Row() + Index; 
							If(eventTwoTime == runEndTime, Index1 = Index1,
								Index1 = Index1 - 1
							);
							endPoint = Row() + Index1;
					);
					//show(Row(),Index,Index1,Index2,startPoint,endPoint,failTest1,failTest2,failTest3);
					
					If(eventOneTime == runEndTime, eventOneTime = origEventOneTime); //resets eventOneTime for next run
					If(eventTwoTime == runEndTime, eventTwoTime = origEventTwoTime); //resets eventTwoTime for next run
					
					//creates x and y lists. if time is present, lists need additional values to bookend times
					For( i = StartPoint, i <= EndPoint, i++,
						Insert Into( xList, :Name( "TimeFromSampleDispense:sec" )[i] );
						Insert Into( yList, :ReflDens_avg[i] );
					);
					//show(xlist,ylist);

					If( failTest1 == 2 | failTest2 == 2 | failTest3 == 2,
						-999,
						//Show( xList, yList );
						xMtrx = Matrix( xList );
						yMtrx = Matrix( yList );
						//Show( xMtrx, yMtrx, metric );
						
						Match(metric,
							//singlePoint
							"SP",
								If(singlePoint == "LAST",
									singlePoint = nitems(ylist); metricValue = yMtrx[singlePoint]
								,
									IsNumber(singlePoint) & singlePoint <= nitems(yList), metricValue = yMtrx[singlePoint]
								,
									-999
								);
								singlePoint = origSinglePoint;
							,
							//Slope
							"SLOPE", xMtrx = J( N Row( xMtrx ), 1 ) || xMtrx;
								intSlope = Inv( xMtrx` * xMtrx ) * xMtrx` * yMtrx;
								metricValue = intSlope[2];
							,
							//Range
							"RANGE", metricValue = Max(yMtrx) - Min(yMtrx);
							,
							//Average
							"AVG", metricValue = Mean(yMtrx);
							,
							-999
						);						
					);
					metricValue;
			,
				:Name( "TimeFromSampleDispense:sec" ) > Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ),
					Lag( preDevParseColName, 1 )
			)
		)
	);
	Column(tableName,columnName)<<deleteformula;
);

//-------------------------------------End/preDevelopmentMetric------------------------------------

//-------------------------------------genericAngleCalc------------------------------------------
//Function calculates angle AR based on TT4 methodologies
//Assumptions are as follows:
//	Time and RD columes are "TimeFromSampleDispense:sec" and "ReflDens_avg" respectively
//		this will be true if the table prep script is run as with most AssayDev Tools
//
//Inputs are as follows:
//	tableName - variable for table or Datatable("actual table name")
//	normalizationTime - time to normalized progress curve to
//	thresholdTime - sets up X value for ellipse to overlay on area curve
//	thresholdArea - sets up Y value for ellipse to overlay on area curve
//	numberRegressionPoints - number of points to use in regression across intersection area
//	severalParamSets - "True" if more than one parameter set is being evaluated
//
//Outputs are as follows:
//	several Column names and their parsed version:
//	rdNormRead - RD Normalization Reading"||appendedColName;
//	parseRDNormRead
//	normRD - Normalized RD"||appendedColName;
//	parseNormRD
//	readTime - Reading Time"||appendedColName;
//	parsereadTime
//	curveArea - Curve Area"||appendedColName;
//	parseCurveArea
//	xInt - X Intersect"||appendedColName;
//	parseXint
//	yInt - Y Intersect"||appendedColName;
//	parseYint
//	angleA - Angle"||appendedColName;
//	parseAngleAR
//
//	column in table but deleted formula

genericAngleCalc=function({tableName,normalizationTime,thresholdTime,thresholdArea,numberRegressionPoints,severalParamSets},
	If(severalParamSets == "True",
		appendedColName = "-paramSet"||Char(j),
		appendedColName = "";
	);
	//Sets up all Column Names for parameter sets
	//parse step allows variable name to be called in the :Name() format for used in formulas
	rdNormRead = "RD Normalization Reading"||appendedColName;
	parseRDNormRead = Parse(Eval Insert( ":name(\!"^rdNormRead^\!" )"));
	normRD = "Normalized RD"||appendedColName;
	parseNormRD = Parse(Eval Insert( ":name(\!"^normRD^\!" )"));
	readTime = "Reading Time"||appendedColName;
	parsereadTime =  Parse(Eval Insert( ":name(\!"^readTime^\!" )"));
	curveArea = "Curve Area"||appendedColName;
	parseCurveArea = Parse(Eval Insert( ":name(\!"^curveArea^\!" )"));
	xInt = "X Intersect"||appendedColName;
	parseXint =  Parse(Eval Insert( ":name(\!"^xInt^\!" )"));
	yInt = "Y Intersect"||appendedColName;
	parseYint =  Parse(Eval Insert( ":name(\!"^yInt^\!" )"));
	angleAR = "Angle"||appendedColName;
	parseAngleAR = Parse(Eval Insert( ":name(\!"^angleAR^\!" )"));
	
	tableName << New Column( rdNormRead,
		Numeric,
		Continuous,
		Formula(
			If(
				:Name( "TimeFromSampleDispense:sec" ) < Num(normalizationTime), Empty(),
				:Name( "TimeFromSampleDispense:sec" ) >= Num(normalizationTime) & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) < Lag( Num(normalizationTime), 1 ), :ReflDens_avg
			,
				Lag( parseRDNormRead, 1 )
			)
		)
	);
	
	tableName << New Column( normRD,
		Numeric,
		Continuous,
		Formula(
			If( :Name( "TimeFromSampleDispense:sec" ) < Num(normalizationTime), 0
			,
				:ReflDens_avg - parseRDNormRead
			)
		)
	);
	
	tableName << New Column( readTime,
		Numeric,
		Continuous,
		Formula(
			If(
				:Name( "TimeFromSampleDispense:sec" ) < Num(normalizationTime), 0
			,
				:Name( "TimeFromSampleDispense:sec" ) >= Num(normalizationTime) & Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ) < Num(normalizationTime), 0
			,
				Lag( parseReadTime, 1 ) + (:Name( "TimeFromSampleDispense:sec" ) - Lag( :Name( "TimeFromSampleDispense:sec" ), 1 ))
			)
		)
	);
	
	tableName << New Column( curveArea,
		Numeric,
		Continuous,
		Formula(
			If( :Name( "TimeFromSampleDispense:sec" ) < Num(normalizationTime), 0
			,
				Lag( parseCurveArea, 1 ) + parseNormRD * (parseReadTime - Lag( parseReadTime, 1 ))
			)
		)
	);
	
	tableName << New Column( xInt,
		Numeric,
		Continuous,
		Formula(
			N = Num( numberRegressionPoints );
			ra = Num( thresholdTime );
			rb = Num( thresholdArea );
			x1 = parseReadTime;
			y1 = parseCurveArea;
			x0 = Lag( parseReadTime, 1 );
			y0 = Lag( parseCurveArea, 1 );
			First_Point_Outside_Ellipse = If(
				x1 ^ 2 / ra ^ 2 + y1 ^ 2 / rb ^ 2 > 1 & x0 ^ 2 / ra ^ 2 + y0 ^ 2 / rb ^ 2 <= 1,
				1,
				0
			);
			Index = Row();
			StartPoint = Index - N / 2;
			EndPoint = Index + (N / 2 - 1);
			SumX = Summation( i = StartPoint, EndPoint, parseReadTime[i, Empty()] );
			SumY = Summation( i = StartPoint, EndPoint, parseCurveArea[i, Empty()] );
			SumXY = Summation(
				i = StartPoint,
				EndPoint,
				parseReadTime[i, Empty()] * parseCurveArea[i, Empty()]
			);
			SumXSumY = Summation( i = StartPoint, EndPoint, parseReadTime[i, Empty()] ) *
			Summation( i = StartPoint, EndPoint, parseCurveArea[i, Empty()] );
			SumXSqrd = Summation( i = StartPoint, EndPoint, parseReadTime[i, Empty()] ^ 2 );
			SumSqrdX = Summation( i = StartPoint, EndPoint, parseReadTime[i, Empty()] ) ^ 2;
			m = (N * SumXY - SumXSumY) / (N * SumXSqrd - SumSqrdX);
			b = (SumY - m * SumX) / N;
			Qa = 1 / ra ^ 2 + m ^ 2 / rb ^ 2;
			Qb = (2 * m * b) / rb ^ 2;
			Qc = b ^ 2 / rb ^ 2 - 1;
			x = ((0 - Qb) + Root( Qb ^ 2 - 4 * Qa * Qc, 2 )) / (2 * Qa);
			If(
				First_Point_Outside_Ellipse == 1, x,
				x1 ^ 2 / ra ^ 2 + y1 ^ 2 / rb ^ 2 > 1,
					Lag( parseXint, 1 ),
				0
			);
		)
	);
	
	tableName << New Column( yInt,
		Numeric,
		Continuous,
		Formula(
			N = Num( numberRegressionPoints );
			ra = Num( thresholdTime );
			rb = Num( thresholdArea );
			x1 = parseReadTime;
			y1 = parseCurveArea;
			x0 = Lag( parseReadTime, 1 );
			y0 = Lag( parseCurveArea, 1 );
			First_Point_Outside_Ellipse = If(
				x1 ^ 2 / ra ^ 2 + y1 ^ 2 / rb ^ 2 > 1 & x0 ^ 2 / ra ^ 2 + y0 ^ 2 / rb ^ 2 <= 1,
				1,
				0
			);
			Index = Row();
			StartPoint = Index - N / 2;
			EndPoint = Index + (N / 2 - 1);
			SumX = Summation( i = StartPoint, EndPoint, parseReadTime[i, Empty()] );
			SumY = Summation( i = StartPoint, EndPoint, parseCurveArea[i, Empty()] );
			SumXY = Summation(
				i = StartPoint,
				EndPoint,
				parseReadTime[i, Empty()] * parseCurveArea[i, Empty()]
			);
			SumXSumY = Summation( i = StartPoint, EndPoint, parseReadTime[i, Empty()] ) *
			Summation( i = StartPoint, EndPoint, parseCurveArea[i, Empty()] );
			SumXSqrd = Summation( i = StartPoint, EndPoint, parseReadTime[i, Empty()] ^ 2 );
			SumSqrdX = Summation( i = StartPoint, EndPoint, parseReadTime[i, Empty()] ) ^ 2;
			m = (N * SumXY - SumXSumY) / (N * SumXSqrd - SumSqrdX);
			b = (SumY - m * SumX) / N;
			x = parseXint;
			y = m * x + b;
			If(
				First_Point_Outside_Ellipse == 1, y,
				x1 ^ 2 / ra ^ 2 + y1 ^ 2 / rb ^ 2 > 1,
					Lag( parseYint, 1 ),
				0
			);
		)
	);
	
	tableName << New Column( angleAR,
		Numeric,
		Continuous,
		Formula( 
			ArcTangent( parseYint / parseXint ) 
		)
	);
	
	Column(tableName,rdNormRead)<<deleteformula;
	Column(tableName,normRD)<<deleteformula;
	Column(tableName,readTime)<<deleteformula;
	Column(tableName,curveArea)<<deleteformula;
	Column(tableName,xInt)<<deleteformula;
	Column(tableName,yInt)<<deleteformula;
	Column(tableName,angleAR)<<deleteformula;
);

//-------------------------------------End/genericAngleCalc------------------------------------------

//-------------------------------------chemCalculatedConcentration------------------------------------------
//Function calculates assay concentration
//Assumptions are as follows:
//	curveData is a matrix from the most recent curve file (opened and matrixed in parent script)
//	equations are added as necessary as an expression
//
//Inputs are as follows:
//	tableName - variable for table or Datatable("actual table name")
//	curveRef - text for which database table to use for coefficients
//	columName - desired final column name, quoted string
//	equationMethod - desired formula, quoted string
//		biExp_4P = 4 Parameter bi-exponential equation ... initially developed for TT4
//		logTransCubic_3P = 3 Parameter log transformed cubic fit ... initially developed for CRP
//		stdCharCubic = old method using cubic fit in terms of Concentration
//	ARsource - column name that will contain the AR, quoted string (ex: "Angle")
//
//Outputs are as follows:
//	chemName = assay name based on chemCode
//	parseARsource - column version of ARsource ("Angle" to :Angle)
//	parseEquationMethod - Removed quotes from equation method ("eq1" to eq1)
//
//	column in table but deleted formula

chemCalculatedConcentration = Function({chemCode,curveRef,tableName,columnName,equationMethod,ARsource},
	
	Match(curveRef,
		"calCurve", curveTable = open("$ADDIN_HOME(com.idexx.assayDevLibraries)\calCurves.jmp",private),
		"nonCubic", curveTable = open("$ADDIN_HOME(com.idexx.assayDevLibraries)\nonCubicCurves.jmp",private)
	);
	curveData=curveTable<<getasmatrix;
	close(curveTable,nosave);
	//show(curveData);

	chemName = Match(chemCode,
		9, "ALB",
		65, "ALKP",
		62, "ALT",
		60, "AMYL",
		73, "AST",
		1, "BUN/UREA",
		3, "CA",
		8, "CHOL",
		64, "CK",
		15, "CREA",
		67, "GGT",
		0, "GLU",
		35, "LAC",
		63, "LDH",
		59, "LIPA",
		32, "MG",
		10, "NH3",
		25, "PHBR",
		12, "PHOS",
		14, "TBIL",
		6, "TP",
		7, "TRIG",
		70, "UCRE",
		54, "UPRO",
		5, "URIC",
		16, "FRU",
		28, "TT4",
		42, "NA+",
		41, "K+",
		40, "CL-",
		17, "CRP"
	);

	biExp_4P = Expr((curveData[cR,9]) + curveData[cR,5] * Exp( curveData[cR,6] * parseARsource ) + curveData[cR,7] * Exp( curveData[cR,8] * parseARsource )); // requires nonCubic file
	logTransCubcic_3P = Expr(Exp(curveData[cR,5] + curveData[cR,6]*(parseARsource) + curveData[cR,7]*(parseARsource)^2 + curveData[cR,8]*(parseARsource)^3) – 1); // requires calCurve file
	stdCharCubic = Expr(
		Num(
			::p = ((3 * curveData[cR,6]) / curveData[cR,8] - (curveData[cR,7] / curveData[cR,8]) ^ 2) / 3;
			::q = ((2 * (curveData[cR,7] / curveData[cR,8]) ^ 3 - ((9 * curveData[cR,7] * curveData[cR,6]) / curveData[cR,8]) / curveData[cR,8]) + (27 * (curveData[cR,5] -
			parseARsource)) / curveData[cR,8]) / 27;
			::D = (::p / 3) ^ 3 + (::q / 2) ^ 2;
			::phi = ArcCosine( (- ::q / 2) / (Abs( ::p ) ^ 3 / 27) ^ 0.5 );
			If( ::D >= 0,
				::u = Root( - ::q / 2 + ::D ^ 0.5, 3 );
				::v = Root( - ::q / 2 - ::D ^ 0.5, 3 );
				::y1 = ::u + ::v;
				::x1 = ::y1 - (curveData[cR,7] / curveData[cR,8]) / 3;
				Char( ::x1 );
			,
				::y1 = 2 * (Abs( ::p ) / 3) ^ 0.5 * Cosine( ::phi / 3 );
				::y2 = -2 * (Abs( ::p ) / 3) ^ 0.5 * Cosine( (::phi + Pi()) / 3 );
				::y3 = -2 * (Abs( ::p ) / 3) ^ 0.5 * Cosine( (::phi - Pi()) / 3 );
				::x1 = ::y1 - (curveData[cR,7] / curveData[cR,8]) / 3;
				::x2 = ::y2 - (curveData[cR,7] / curveData[cR,8]) / 3;
				::x3 = ::y3 - (curveData[cR,7] / curveData[cR,8]) / 3;
				Char( ::x1 ) || " " || Char( ::x2 ) || " " || Char( ::x3 );
			)
		)
	); // requires calCurve file

	parseARsource = Parse(Eval Insert( ":name(\!"^ARsource^\!" )"));
	parseEquationMethod = parse(equationMethod);
	calParseColName = Parse( Eval Insert( ":name(\!"^columnName^\!" )" ) );
	
	tableName<<new column(columnName,
		Formula(
			If(isMissing(parseARsource),
				//Print("not even starting");
				Empty()
			,
				//Print("entering IF");
				//show(row(),Eval(parseARsource),Lag(parseARsource,1));
				If(Row() == 1 | IsMissing(parseARsource != Lag(parseARsource,1)) | parseARsource != Lag(parseARsource,1),
					//Print("found start");
					If(chemName == :Chem Type,
						//Print("matched type");
						If(:Chem Type == "CRP",
							curveSpp = "99"
						,
							curveSpp = Match(Lowercase(:Species Name[Row()]),
								"feline", "2", "99"
							);
							//Print("this is correct too");
						);
						For(i=1,i<=nrow(curveData),i++,
							curveCombo = Char(curveData[i,1])||Char(curveData[i,2])||Char(curveData[i,3]);
							dataCombo = Char(chemCode)||Char(:Lot[Row()])||curveSpp;
							If(
								dataCombo == curveCombo, cR = i;
								//Print("found match row "||char(i));
								break()
							);
						);
						If(parseARsource == -999,
							parseARsource
						,
							i != nrow(curveData) + 1,
							//Print("evaluating eqn");
							Eval(parseEquationMethod)
						,
							Empty()
						)
					,
						Empty()
					)
				,
					Lag(calParseColName,1)
				)
			)
		)
	);
	Column(tableName, columnName)<<DeleteFormula;
);

//-------------------------------------End/chemCalculatedConcentration------------------------------------------

//-------------------------------------assayDevFlagging------------------------------------------
//Function calculates progress curve flags in both a text and number format (2 columns)
//Assumptions are as follows:
//	assayFlagParams is a list of flags and their thresholds within the main script
//
//Inputs are as follows:
//	tableName - variable for table or Datatable("actual table name")
//	assayFlagParams - list of lists of each flag, thresholds, and base description
//		EX: tt4Flags = {
//				{dryReadFlag, 0.06, 0.13, "Dry[*77]"},
//				{sampConjMinusDry, 0.25, 0.54, "S/C - DR[*78]"},
//				{washMinusSampConj, -0.25, -0.03, "Wash - S/C[*79]"},
//				{subMinusWash, -0.01, 0.35, "Sub - Wash[*80]"},
//				... add as many flags as necessary ...
//			};
//			NOTE: function must have matching flag names along with mathematical expression for flag
//	assayName - Assay abbreviation, quoted string
//
//Outputs are as follows:
//	mutltiple columns for flag expressions
//
//	Flag and Flag_nums columns in table but deleted formula

assayDevFlagging = Function({tableName,assayFlagParams,assay_Name},

	///////Flags as they correspond to columns in table////////
	//try to overlap as much as possible as assays added
		//original for TT4
	dryReadFlag = Expr(:Dry Read);//**77 8095
	sampConjMinusDry = Expr(:Name( "Sample Mix" ) - :Dry Read);//**78
	washMinusSampConj = Expr(:Wash - :Name( "Sample Mix" ));//**79
	subMinusWash = Expr(:Substrate - :Wash);//**80
	anomProgCurve10_60 = Expr(:Name("Slope (10-60s)"));//**82
	avgAllFlag = Expr((:Dry Read + :Name( "Sample Mix" ) + :Wash + :Substrate)/4);//85
	anomInitSlopeVSub = Expr(:Name("Slope (10-60s)"));//**86
	lateSlope50_60 = Expr(:Name("Slope (50-60s)"));//**87
	
		//new for CRP
	sampMixMinusDry = Expr(:Name("SampMix - Dry")); //78 8096 (same as TT4)
	sampMixMinusRespAvg = Expr(:Name("SampMix - AR")); //79 8097 (same as TT4)
	responseRange = Expr(:Name("Response Range")); //91 8100
	
	//////////////////////////////////////////////////////////////
	tableName<<New Column("Flag",Character(200),
		Formula(
			If(IsMissing(Lag(:Name( "TimeFromSampleDispense:sec" ),1)) | :Name( "TimeFromSampleDispense:sec" ) < 0 & Lag(:Name( "TimeFromSampleDispense:sec" ),1) >= 0,
				If(:Chem Type == assay_Name,
					flagList={};
					For(i=1,i<=nitems(assayFlagParams),i++,
					//show(row(),i,eval(assayFlagParams[i][1]));
						If(assayFlagParams[i][1] == Expr(anomInitSlopeVSub),
							If(
								Round(assayFlagParams[i][4] * :Substrate + assayFlagParams[i][5], 10) <= eval(assayFlagParams[i][1]) <= Round(assayFlagParams[i][2] * :Substrate + assayFlagParams[i][3], 10),
								flagList[i] = "NF("||assayFlagParams[i][6]||")",
								flagList[i] = assayFlagParams[i][6]
							)
						,
							If(
								assayFlagParams[i][2] <= eval(assayFlagParams[i][1]) <= assayFlagParams[i][3],
								flagList[i] = "NF("||assayFlagParams[i][4]||")"
							,
								flagList[i] = assayFlagParams[i][4]
							);
						);
						
					);
					flagList1="";
					For(j=1,j<=nitems(flagList),j++,
						flagList1 = flagList1 || " " || flagList[j]
					);
					Trim(flagList1);
				)
			,
				Lag(:Flag,1);
			)
		)
	);
	
	tableName<<New Column("Flag_nums",Character(20),
		Formula(
			If(:Chem Type == assay_Name,
				flagNumList = Words(:Flag,"[");
				flagNumList1 = "";
				For(k=1,k<=nitems(flagNumList)-1,k++,
					If(Contains(flagNumList[k],"NF") == 0,
						flagNumList1 = flagNumList1 || " " || Word(1,flagNumList[k+1],"]")
					)
				);
				If(flagNumList1 == "",
					"None"
				,
					Trim(flagNumList1);
				)
			)
		)
	);
	Column(tableName,"Flag")<<deleteformula;
	Column(tableName,"Flag_nums")<<deleteformula;
);

//-------------------------------------End/assayDefFlagging------------------------------------------